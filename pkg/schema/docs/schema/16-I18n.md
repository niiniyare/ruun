# Internationalization (I18n) in Schema-Driven Architecture

Implementing internationalization across our schema-driven UI system using Go, Fiber v2, and our existing architecture patterns.

---

## Table of Contents

1. [Schema I18n Structure](#schema-i18n-structure)
2. [Builder Integration](#builder-integration)
3. [Registry & Storage](#registry--storage)
4. [Enricher I18n Support](#enricher-i18n-support)
5. [Runtime Localization](#runtime-localization)
6. [Translation Management](#translation-management)
7. [Best Practices](#best-practices)

---

## Schema I18n Structure

### Field-Level Internationalization

```go
// FieldI18n holds field translations for multiple locales (from field.go)
type FieldI18n struct {
    Label       map[string]string `json:"label,omitempty"`       // Localized labels
    Placeholder map[string]string `json:"placeholder,omitempty"` // Localized placeholders
    Help        map[string]string `json:"help,omitempty"`        // Localized help text
    Tooltip     map[string]string `json:"tooltip,omitempty"`     // Localized tooltips
    Error       map[string]string `json:"error,omitempty"`       // Localized error messages
}

// Field with I18n support
type Field struct {
    Name        string     `json:"name"`
    Type        FieldType  `json:"type"`
    Label       string     `json:"label"`       // Default/fallback text
    Placeholder string     `json:"placeholder"` // Default/fallback text
    Help        string     `json:"help"`        // Default/fallback text
    Tooltip     string     `json:"tooltip"`     // Default/fallback text
    
    // Internationalization support
    I18n *FieldI18n `json:"i18n,omitempty"` // Multi-locale translations
    
    // ... other fields
}
```

### Schema-Level Internationalization

```go
// SchemaI18n holds schema-level translations
type SchemaI18n struct {
    Title       map[string]string `json:"title,omitempty"`       // Schema titles
    Description map[string]string `json:"description,omitempty"` // Schema descriptions
    Messages    map[string]string `json:"messages,omitempty"`    // Custom messages
}

// Schema with I18n support
type Schema struct {
    ID          string       `json:"id"`
    Title       string       `json:"title"`       // Default title
    Description string       `json:"description"` // Default description
    Fields      []Field      `json:"fields"`
    
    // Internationalization
    I18n *SchemaI18n `json:"i18n,omitempty"` // Schema translations
}
```

---

## Builder Integration

### Creating Multilingual Schemas

```go
// Using the Builder to create schemas with I18n support
func BuildUserRegistrationForm() *schema.Schema {
    builder := schema.NewBuilder()
    
    // Add field with multiple language support
    builder.AddField(&schema.Field{
        Name:        "first_name",
        Type:        schema.FieldText,
        Label:       "First Name",           // English default
        Placeholder: "Enter your first name", // English default
        Help:        "Your legal first name", // English default
        Required:    true,
        
        // Multi-language translations
        I18n: &schema.FieldI18n{
            Label: map[string]string{
                "en": "First Name",
                "es": "Nombre",
                "fr": "Prénom",
                "ar": "الاسم الأول",
            },
            Placeholder: map[string]string{
                "en": "Enter your first name",
                "es": "Ingresa tu nombre",
                "fr": "Entrez votre prénom",
                "ar": "أدخل اسمك الأول",
            },
            Help: map[string]string{
                "en": "Your legal first name",
                "es": "Tu nombre legal",
                "fr": "Votre prénom légal",
                "ar": "اسمك القانوني الأول",
            },
        },
    })
    
    schema := builder.Build()
    
    // Add schema-level translations
    schema.I18n = &schema.SchemaI18n{
        Title: map[string]string{
            "en": "User Registration",
            "es": "Registro de Usuario",
            "fr": "Inscription Utilisateur",
            "ar": "تسجيل المستخدم",
        },
        Description: map[string]string{
            "en": "Create your account",
            "es": "Crea tu cuenta",
            "fr": "Créez votre compte",
            "ar": "أنشئ حسابك",
        },
    }
    
    return schema
}
```

---

## Registry & Storage

### Translation Storage in Database

```go
// Database model for storing schema translations
type SchemaTranslation struct {
    ID        uuid.UUID `gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
    TenantID  uuid.UUID `gorm:"type:uuid;not null;index:idx_schema_translation_lookup"`
    SchemaID  string    `gorm:"not null;index:idx_schema_translation_lookup;size:100"`
    Locale    string    `gorm:"not null;index:idx_schema_translation_lookup;size:10"`
    Version   int       `gorm:"not null;default:1"`
    
    // Translation data stored as JSONB
    Translations JSONB `gorm:"type:jsonb;not null"`
    
    // Metadata
    Status       string    `gorm:"default:'active';size:20"`     // active, draft, archived
    TranslatedBy uuid.UUID `gorm:"type:uuid"`                     // Who created the translation
    
    // Audit timestamps
    CreatedAt time.Time `gorm:"not null;default:now()"`
    UpdatedAt time.Time `gorm:"not null;default:now()"`
    
    // Composite unique index
    // UNIQUE: (tenant_id, schema_id, locale, version)
}

// Registry methods for I18n
func (r *Registry) GetSchemaWithLocale(ctx context.Context, schemaID, locale string) (*schema.Schema, error) {
    // Get base schema
    baseSchema, err := r.Get(ctx, schemaID)
    if err != nil {
        return nil, err
    }
    
    // Apply translations if locale is not default
    if locale != "en" {
        translations, err := r.getTranslations(ctx, schemaID, locale)
        if err != nil {
            log.Warn().Err(err).Str("schema_id", schemaID).Str("locale", locale).
                Msg("Failed to load translations, using defaults")
            return baseSchema, nil
        }
        
        return r.applyTranslations(baseSchema, translations, locale), nil
    }
    
    return baseSchema, nil
}

// Apply translations to schema
func (r *Registry) applyTranslations(schema *schema.Schema, translations map[string]interface{}, locale string) *schema.Schema {
    localizedSchema := schema.Clone()
    
    // Apply schema-level translations
    if schemaTranslations, ok := translations["schema"].(map[string]interface{}); ok {
        if title, exists := schemaTranslations["title"].(string); exists {
            localizedSchema.Title = title
        }
        if desc, exists := schemaTranslations["description"].(string); exists {
            localizedSchema.Description = desc
        }
    }
    
    // Apply field-level translations
    if fieldTranslations, ok := translations["fields"].(map[string]interface{}); ok {
        for i := range localizedSchema.Fields {
            field := &localizedSchema.Fields[i]
            if fieldTrans, exists := fieldTranslations[field.Name].(map[string]interface{}); exists {
                if label, ok := fieldTrans["label"].(string); ok {
                    field.Label = label
                }
                if placeholder, ok := fieldTrans["placeholder"].(string); ok {
                    field.Placeholder = placeholder
                }
                if help, ok := fieldTrans["help"].(string); ok {
                    field.Help = help
                }
                if tooltip, ok := fieldTrans["tooltip"].(string); ok {
                    field.Tooltip = tooltip
                }
            }
        }
    }
    
    return localizedSchema
}
```

---

## Enricher I18n Support

### Locale-Aware Enrichment

```go
// Enhanced User interface with locale preference
type User interface {
    GetID() string
    GetTenantID() string
    GetPermissions() []string
    GetRoles() []string
    HasPermission(permission string) bool
    HasRole(role string) bool
    GetPreferredLocale() string  // New method for I18n
}

// Enricher with I18n support
func (e *DefaultEnricher) EnrichWithLocale(
    ctx context.Context, 
    schema *schema.Schema, 
    user User,
    locale string,
) (*schema.Schema, error) {
    // First enrich with user context (permissions, defaults, etc.)
    enrichedSchema, err := e.Enrich(ctx, schema, user)
    if err != nil {
        return nil, err
    }
    
    // Then apply locale-specific translations
    if locale != "" && locale != "en" {
        enrichedSchema = e.applyLocalization(enrichedSchema, locale)
    }
    
    return enrichedSchema, nil
}

// Apply localization to enriched schema
func (e *DefaultEnricher) applyLocalization(schema *schema.Schema, locale string) *schema.Schema {
    localizedSchema := schema.Clone()
    
    // Apply schema-level localization
    if localizedSchema.I18n != nil {
        if title, exists := localizedSchema.I18n.Title[locale]; exists {
            localizedSchema.Title = title
        }
        if desc, exists := localizedSchema.I18n.Description[locale]; exists {
            localizedSchema.Description = desc
        }
    }
    
    // Apply field-level localization
    for i := range localizedSchema.Fields {
        field := &localizedSchema.Fields[i]
        if field.I18n != nil {
            if label, exists := field.I18n.Label[locale]; exists {
                field.Label = label
            }
            if placeholder, exists := field.I18n.Placeholder[locale]; exists {
                field.Placeholder = placeholder
            }
            if help, exists := field.I18n.Help[locale]; exists {
                field.Help = help
            }
            if tooltip, exists := field.I18n.Tooltip[locale]; exists {
                field.Tooltip = tooltip
            }
        }
    }
    
    return localizedSchema
}
```

---

## Runtime Localization

### Locale-Aware Runtime

```go
// Runtime with I18n support
type Runtime struct {
    schema    *schema.Schema
    state     *State
    validator *validate.Validator
    events    *EventHandler
    locale    string              // Current locale
    i18n      *I18nManager        // Translation manager
    mu        sync.RWMutex
}

// I18nManager handles runtime translations
type I18nManager struct {
    locale        string
    fallbackLocale string
    messages      map[string]map[string]string // [locale][key]message
}

// Get localized validation message
func (i *I18nManager) GetValidationMessage(key string, params map[string]interface{}) string {
    // Try current locale first
    if message, exists := i.messages[i.locale][key]; exists {
        return i.interpolateMessage(message, params)
    }
    
    // Fall back to default locale
    if message, exists := i.messages[i.fallbackLocale][key]; exists {
        return i.interpolateMessage(message, params)
    }
    
    // Return key if no translation found
    return key
}

// Localized validation error messages
func (r *Runtime) ValidateFieldWithLocale(ctx context.Context, fieldName string, value interface{}) []string {
    field, exists := r.schema.GetField(fieldName)
    if !exists {
        return []string{r.i18n.GetValidationMessage("field_not_found", map[string]interface{}{
            "field": fieldName,
        })}
    }
    
    var errors []string
    
    // Required validation
    if field.Required && isEmpty(value) {
        message := r.i18n.GetValidationMessage("required", map[string]interface{}{
            "field": field.Label,
        })
        errors = append(errors, message)
    }
    
    // Type validation
    if !isValidType(value, field.Type) {
        message := r.i18n.GetValidationMessage("invalid_type", map[string]interface{}{
            "field": field.Label,
            "type":  string(field.Type),
        })
        errors = append(errors, message)
    }
    
    return errors
}
```

---

## Translation Management

### Translation File Structure

```go
// translations/en.json
{
    "validation": {
        "required": "{{.field}} is required",
        "invalid_type": "{{.field}} must be a valid {{.type}}",
        "min_length": "{{.field}} must be at least {{.min}} characters",
        "max_length": "{{.field}} cannot exceed {{.max}} characters",
        "invalid_email": "Please enter a valid email address",
        "field_not_found": "Field {{.field}} not found"
    },
    "actions": {
        "save": "Save",
        "cancel": "Cancel",
        "submit": "Submit",
        "delete": "Delete",
        "edit": "Edit"
    },
    "messages": {
        "save_success": "Changes saved successfully",
        "save_error": "Failed to save changes",
        "validation_failed": "Please correct the errors below"
    }
}

// translations/es.json
{
    "validation": {
        "required": "{{.field}} es requerido",
        "invalid_type": "{{.field}} debe ser un {{.type}} válido",
        "min_length": "{{.field}} debe tener al menos {{.min}} caracteres",
        "max_length": "{{.field}} no puede exceder {{.max}} caracteres",
        "invalid_email": "Por favor ingresa un email válido",
        "field_not_found": "Campo {{.field}} no encontrado"
    },
    "actions": {
        "save": "Guardar",
        "cancel": "Cancelar",
        "submit": "Enviar",
        "delete": "Eliminar",
        "edit": "Editar"
    },
    "messages": {
        "save_success": "Cambios guardados exitosamente",
        "save_error": "Error al guardar cambios",
        "validation_failed": "Por favor corrige los errores abajo"
    }
}
```

### Loading Translations

```go
// I18nLoader loads translations from files or database
type I18nLoader struct {
    translationsDir string
    cache          map[string]map[string]string
    mu             sync.RWMutex
}

func NewI18nLoader(translationsDir string) *I18nLoader {
    return &I18nLoader{
        translationsDir: translationsDir,
        cache:          make(map[string]map[string]string),
    }
}

func (l *I18nLoader) LoadLocale(locale string) (map[string]string, error) {
    l.mu.RLock()
    if cached, exists := l.cache[locale]; exists {
        l.mu.RUnlock()
        return cached, nil
    }
    l.mu.RUnlock()
    
    filePath := filepath.Join(l.translationsDir, locale+".json")
    data, err := os.ReadFile(filePath)
    if err != nil {
        return nil, fmt.Errorf("failed to load translations for locale %s: %w", locale, err)
    }
    
    var translations map[string]string
    if err := json.Unmarshal(data, &translations); err != nil {
        return nil, fmt.Errorf("failed to parse translations for locale %s: %w", locale, err)
    }
    
    // Flatten nested JSON structure
    flattened := flattenJSON(translations)
    
    l.mu.Lock()
    l.cache[locale] = flattened
    l.mu.Unlock()
    
    return flattened, nil
}

// Flatten nested JSON for easier key access
func flattenJSON(data map[string]interface{}) map[string]string {
    result := make(map[string]string)
    flatten(data, "", result)
    return result
}

func flatten(data map[string]interface{}, prefix string, result map[string]string) {
    for key, value := range data {
        fullKey := key
        if prefix != "" {
            fullKey = prefix + "." + key
        }
        
        switch v := value.(type) {
        case string:
            result[fullKey] = v
        case map[string]interface{}:
            flatten(v, fullKey, result)
        }
    }
}
```

---

## Best Practices

### 1. Fallback Strategy
```go
// Always provide English defaults
field := &schema.Field{
    Label: "Email Address",  // English fallback
    I18n: &schema.FieldI18n{
        Label: map[string]string{
            "es": "Dirección de Email",
            "fr": "Adresse Email",
        },
    },
}
```

### 2. Key Naming Convention
```go
// Use hierarchical keys
"validation.required"
"validation.min_length" 
"actions.save"
"messages.success.save"
"fields.user.first_name"
```

### 3. Parameter Interpolation
```go
// Use template-style parameters
"{{.field}} must be at least {{.min}} characters"

// Apply in runtime
message := i18n.GetMessage("validation.min_length", map[string]interface{}{
    "field": "First Name",
    "min":   2,
})
// Result: "First Name must be at least 2 characters"
```

### 4. Right-to-Left (RTL) Support
```go
// Include text direction in schema
type SchemaI18n struct {
    Title       map[string]string `json:"title"`
    Description map[string]string `json:"description"`
    Direction   map[string]string `json:"direction"` // "ltr" or "rtl"
}

// Apply in templates
if direction := schema.I18n.Direction[locale]; direction == "rtl" {
    // Apply RTL CSS classes
}
```

### 5. Pluralization Support
```go
// Handle plural forms
type PluralForms struct {
    Zero  string `json:"zero,omitempty"`
    One   string `json:"one"`
    Two   string `json:"two,omitempty"`
    Few   string `json:"few,omitempty"`
    Many  string `json:"many,omitempty"`
    Other string `json:"other"`
}

func (i *I18nManager) GetPluralMessage(key string, count int, locale string) string {
    // Implement plural rules for different languages
    // English: 1 = "one", else = "other"
    // Arabic: complex plural rules
    // etc.
}
```

---

## Integration Example

### Complete Localized Form Handler

```go
func HandleLocalizedForm(c *fiber.Ctx) error {
    // 1. Get user and locale
    user := GetUserFromContext(c)
    locale := c.Get("Accept-Language", user.GetPreferredLocale())
    
    // 2. Get schema with locale
    registry := GetRegistry(c)
    schema, err := registry.GetSchemaWithLocale(c.Context(), "user-form", locale)
    if err != nil {
        return err
    }
    
    // 3. Enrich with user context and locale
    enricher := GetEnricher(c)
    enriched, err := enricher.EnrichWithLocale(c.Context(), schema, user, locale)
    if err != nil {
        return err
    }
    
    // 4. Create runtime with I18n support
    runtime := NewRuntimeWithI18n(enriched, locale)
    
    // 5. Render with localized context
    return views.LocalizedForm(enriched, runtime, locale).Render(
        c.Context(),
        c.Response().BodyWriter(),
    )
}
```

This I18n implementation integrates seamlessly with our existing schema-driven architecture, providing comprehensive multilingual support while maintaining consistency with our Builder → Registry → Enricher → Runtime pattern.

---

[← Back: Runtime](./15-runtime.md) | [Next: Complete Example →](17-example.md)