package organisms

import (
	"fmt"
	"strconv"
	"strings"
	"time"
	"github.com/niiniyare/ruun/pkg/utils"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
)

// Helper function for min calculation
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// DataTableVariant defines the visual style variants
type DataTableVariant string

const (
	DataTableDefault  DataTableVariant = "default"
	DataTableBordered DataTableVariant = "bordered"
	DataTableStriped  DataTableVariant = "striped"
	DataTableHover    DataTableVariant = "hover"
	DataTableCompact  DataTableVariant = "compact"
)

// DataTableSize defines the size variants
type DataTableSize string

const (
	DataTableSizeSM DataTableSize = "sm"
	DataTableSizeMD DataTableSize = "md"
	DataTableSizeLG DataTableSize = "lg"
)

// DataTableDensity defines the row density variants
type DataTableDensity string

const (
	DataTableDensityComfortable DataTableDensity = "comfortable"
	DataTableDensityCompact     DataTableDensity = "compact"
	DataTableDensityCondensed   DataTableDensity = "condensed"
)

// ColumnType defines the type of column for rendering
type ColumnType string

const (
	ColumnTypeText     ColumnType = "text"
	ColumnTypeNumber   ColumnType = "number"
	ColumnTypeDate     ColumnType = "date"
	ColumnTypeBadge    ColumnType = "badge"
	ColumnTypeProgress ColumnType = "progress"
	ColumnTypeImage    ColumnType = "image"
	ColumnTypeLink     ColumnType = "link"
	ColumnTypeButton   ColumnType = "button"
	ColumnTypeActions  ColumnType = "actions"
)

// ExportFormat defines supported export formats
type ExportFormat string

const (
	ExportCSV   ExportFormat = "csv"
	ExportExcel ExportFormat = "excel"
	ExportPDF   ExportFormat = "pdf"
)

// DataTableColumn represents a table column configuration
type DataTableColumn struct {
	// Core properties
	Key           string `json:"key"`
	Title         string `json:"title"`
	Type          ColumnType `json:"type"`
	Width         string `json:"width"`
	MinWidth      string `json:"minWidth"`
	MaxWidth      string `json:"maxWidth"`
	
	// Features
	Sortable      bool `json:"sortable"`
	Searchable    bool `json:"searchable"`
	Filterable    bool `json:"filterable"`
	Resizable     bool `json:"resizable"`
	Visible       bool `json:"visible"`
	Clickable     bool `json:"clickable"`
	
	// Appearance
	Align         string `json:"align"`
	Format        string `json:"format"`
	
	// Type-specific configurations
	BadgeMap      map[string]string `json:"badgeMap"`
	CurrencyCode  string `json:"currencyCode"`
	Precision     int    `json:"precision"`
	DateFormat    string `json:"dateFormat"`
	
	// Actions for this column
	ActionItems   []molecules.MenuItemProps `json:"actionItems"`
	OnClick       string `json:"onClick"`
}

// DataTableRow represents a table row with data and metadata
type DataTableRow struct {
	// Core data
	ID       string         `json:"id"`
	Data     map[string]any `json:"data"`
	
	// State
	Selected bool `json:"selected"`
	Expanded bool `json:"expanded"`
	Disabled bool `json:"disabled"`
	
	// Appearance
	Class    string `json:"class"`
	
	// Row-specific actions
	Actions  []molecules.MenuItemProps `json:"actions"`
	
	// Additional metadata
	Meta     map[string]any `json:"meta"`
}

// DataTableSearch defines search configuration
type DataTableSearch struct {
	Enabled       bool     `json:"enabled"`
	Placeholder   string   `json:"placeholder"`
	Value         string   `json:"value"`
	Columns       []string `json:"columns"`
	CaseSensitive bool     `json:"caseSensitive"`
	MinLength     int      `json:"minLength"`
	Delay         int      `json:"delay"`
	Highlight     bool     `json:"highlight"`
	ServerSide    bool     `json:"serverSide"`
	Advanced      bool     `json:"advanced"`
}

// DataTablePagination defines pagination configuration
type DataTablePagination struct {
	Enabled         bool  `json:"enabled"`
	CurrentPage     int   `json:"currentPage"`
	PageSize        int   `json:"pageSize"`
	TotalPages      int   `json:"totalPages"`
	TotalItems      int   `json:"totalItems"`
	PageSizeOptions []int `json:"pageSizeOptions"`
	ShowTotal       bool  `json:"showTotal"`
	ShowPageSize    bool  `json:"showPageSize"`
	ShowQuickJump   bool  `json:"showQuickJump"`
	ServerSide      bool  `json:"serverSide"`
	Compact         bool  `json:"compact"`
}

// DataTableAction defines table-level actions
type DataTableAction struct {
	ID          string              `json:"id"`
	Text        string              `json:"text"`
	Icon        string              `json:"icon"`
	Variant     string `json:"variant"`
	Size        string    `json:"size"`
	Position    string              `json:"position"`
	OnClick     string              `json:"onClick"`
	HXGet       string              `json:"hxGet"`
	HXPost      string              `json:"hxPost"`
	HXTarget    string              `json:"hxTarget"`
	HXSwap      string              `json:"hxSwap"`
	AlpineClick string              `json:"alpineClick"`
	Condition   string              `json:"condition"`
}

// DataTableBulkAction defines bulk actions for selected rows
type DataTableBulkAction struct {
	ID          string              `json:"id"`
	Text        string              `json:"text"`
	Icon        string              `json:"icon"`
	Variant     string `json:"variant"`
	Destructive bool                `json:"destructive"`
	Confirm     bool                `json:"confirm"`
	OnClick     string              `json:"onClick"`
}

// DataTableExport defines export configuration
type DataTableExport struct {
	Enabled    bool           `json:"enabled"`
	Formats    []ExportFormat `json:"formats"`
	Filename   string         `json:"filename"`
	AllData    bool           `json:"allData"`
	ServerSide bool           `json:"serverSide"`
}

// DataTableFilter defines column-specific filters
type DataTableFilter struct {
	Column    string   `json:"column"`
	Type      string   `json:"type"`
	Value     string   `json:"value"`
	Options   []string `json:"options"`
	Multiple  bool     `json:"multiple"`
	ServerSide bool    `json:"serverSide"`
}

// DataTableProps defines all properties for the DataTable organism using progressive enhancement
type DataTableProps struct {
	// Core properties (always required)
	ID      string              `json:"id"`
	Columns []DataTableColumn   `json:"columns"`
	Rows    []DataTableRow      `json:"rows"`
	
	// Basic Enhancement (optional)
	Title       string           `json:"title"`
	Description string           `json:"description"`
	Variant     DataTableVariant `json:"variant"`
	Size        DataTableSize    `json:"size"`
	Density     DataTableDensity `json:"density"`
	
	// Progressive Enhancement (nil = disabled)
	Selection  *SelectionConfig  `json:"selection"`  // Row selection features
	Sorting    *SortingConfig    `json:"sorting"`    // Sorting functionality
	Filtering  *FilteringConfig  `json:"filtering"`  // Filtering and search
	Pagination *PaginationConfig `json:"pagination"` // Pagination features
	Actions    *ActionsConfig    `json:"actions"`    // Table and row actions
	Export     *ExportConfig     `json:"export"`     // Export functionality
	Layout     *DataTableLayoutConfig     `json:"layout"`     // Responsive, resizing
	Performance *PerformanceConfig `json:"performance"` // Virtualization, lazy loading
	Storage    *DataTableStorageConfig    `json:"storage"`    // State persistence
	Analytics  *DataTableAnalyticsConfig  `json:"analytics"`  // Usage tracking
	
	// Accessibility
	AriaLabels  map[string]string `json:"ariaLabels"`
}

// SelectionConfig defines row selection features
type SelectionConfig struct {
	Enabled     bool `json:"enabled"`
	MultiSelect bool `json:"multiSelect"`
	Checkbox    bool `json:"checkbox"`    // Show selection checkboxes
	RowClick    bool `json:"rowClick"`    // Select on row click
	Sticky      bool `json:"sticky"`     // Persist selection across pages
	Limit       int  `json:"limit"`      // Max selection limit
}

// SortingConfig defines sorting functionality
type SortingConfig struct {
	Enabled     bool     `json:"enabled"`
	MultiColumn bool     `json:"multiColumn"`
	DefaultSort string   `json:"defaultSort"`     // "column:asc" format
	ServerSide  bool     `json:"serverSide"`
	URL         string   `json:"url"`             // Server-side sorting endpoint
	Columns     []string `json:"columns"`         // Sortable columns (if not all)
}

// FilteringConfig defines filtering and search functionality
type FilteringConfig struct {
	Enabled       bool                `json:"enabled"`
	Search        *SearchConfig       `json:"search"`        // Global search
	ColumnFilters bool                `json:"columnFilters"` // Per-column filtering
	Filters       []DataTableFilter   `json:"filters"`       // Active filters
	Advanced      bool                `json:"advanced"`      // Advanced filter UI
	ServerSide    bool                `json:"serverSide"`
	URL           string              `json:"url"`           // Server-side filtering endpoint
}

// PaginationConfig defines pagination features
type PaginationConfig struct {
	Enabled         bool  `json:"enabled"`
	CurrentPage     int   `json:"currentPage"`
	PageSize        int   `json:"pageSize"`
	TotalPages      int   `json:"totalPages"`
	TotalItems      int   `json:"totalItems"`
	PageSizeOptions []int `json:"pageSizeOptions"`
	ShowTotal       bool  `json:"showTotal"`
	ShowPageSize    bool  `json:"showPageSize"`
	ShowQuickJump   bool  `json:"showQuickJump"`
	ServerSide      bool  `json:"serverSide"`
	URL             string `json:"url"`    // Server-side pagination endpoint
	Compact         bool  `json:"compact"`
}

// ActionsConfig defines table and row actions
type ActionsConfig struct {
	Enabled     bool                    `json:"enabled"`
	TableActions []DataTableAction      `json:"tableActions"`  // Header actions
	RowActions  []DataTableAction       `json:"rowActions"`    // Per-row actions
	BulkActions []DataTableBulkAction   `json:"bulkActions"`   // Bulk/selection actions
	Position    string                  `json:"position"`      // "top", "bottom", "both"
	Sticky      bool                    `json:"sticky"`        // Sticky action buttons
}

// ExportConfig defines export functionality
type ExportConfig struct {
	Enabled    bool           `json:"enabled"`
	Formats    []ExportFormat `json:"formats"`
	Filename   string         `json:"filename"`
	AllData    bool           `json:"allData"`     // Export all data vs current page
	ServerSide bool           `json:"serverSide"`
	URL        string         `json:"url"`         // Server-side export endpoint
}

// LayoutConfig defines responsive and layout features
type DataTableLayoutConfig struct {
	Responsive  bool   `json:"responsive"`
	Resizable   bool   `json:"resizable"`   // Column resizing
	Expandable  bool   `json:"expandable"`  // Row expansion
	Sticky      bool   `json:"sticky"`      // Sticky headers
	Bordered    bool   `json:"bordered"`
	Striped     bool   `json:"striped"`
	Hover       bool   `json:"hover"`
	Compact     bool   `json:"compact"`
}

// PerformanceConfig defines performance optimization features
type PerformanceConfig struct {
	Virtualized bool `json:"virtualized"` // Virtual scrolling
	LazyLoad    bool `json:"lazyLoad"`    // Lazy load rows
	CacheData   bool `json:"cacheData"`   // Cache data client-side
	Debounce    int  `json:"debounce"`    // Debounce delay for search/filter
}

// StorageConfig defines state persistence
type DataTableStorageConfig struct {
	Enabled       bool   `json:"enabled"`
	Key           string `json:"key"`           // Storage key
	Strategy      string `json:"strategy"`      // "local", "session"
	PersistSort   bool   `json:"persistSort"`   // Persist sort state
	PersistFilter bool   `json:"persistFilter"` // Persist filter state
	PersistPage   bool   `json:"persistPage"`   // Persist pagination state
	TTL           int    `json:"ttl"`           // Time to live (seconds)
}

// AnalyticsConfig defines usage tracking for DataTable
type DataTableAnalyticsConfig struct {
	Enabled        bool   `json:"enabled"`
	TrackSort      bool   `json:"trackSort"`      // Track column sorting
	TrackFilter    bool   `json:"trackFilter"`    // Track filtering usage
	TrackExport    bool   `json:"trackExport"`    // Track export usage
	TrackSelection bool   `json:"trackSelection"` // Track row selection
	EventPrefix    string `json:"eventPrefix"`
}

// getDataTableClasses builds CSS classes for the datatable
// Uses minimal classes with Basecoat styling  
func getDataTableClasses(props DataTableProps) string {
	// Base wrapper class for the table container
	class := "overflow-x-auto"
	
	// Add responsive wrapper if needed
	if props.Layout != nil && props.Layout.Responsive {
		class += " w-full"
	}
	
	return class
}

// Feature detection functions for progressive enhancement
func hasSelection(props DataTableProps) bool {
	return props.Selection != nil && props.Selection.Enabled
}

func hasSorting(props DataTableProps) bool {
	return props.Sorting != nil && props.Sorting.Enabled
}

func hasFiltering(props DataTableProps) bool {
	return props.Filtering != nil && props.Filtering.Enabled
}

func hasPagination(props DataTableProps) bool {
	return props.Pagination != nil && props.Pagination.Enabled
}

func hasActions(props DataTableProps) bool {
	return props.Actions != nil && props.Actions.Enabled
}

func hasExport(props DataTableProps) bool {
	return props.Export != nil && props.Export.Enabled
}

func hasPerformance(props DataTableProps) bool {
	return props.Performance != nil
}

func hasStorage(props DataTableProps) bool {
	return props.Storage != nil && props.Storage.Enabled
}

func hasDataTableAnalytics(props DataTableProps) bool {
	return props.Analytics != nil && props.Analytics.Enabled
}

// getTableClasses builds CSS classes for the table element
// Uses Basecoat .table class instead of custom classes
func getTableClasses(props DataTableProps) string {
	// Basecoat provides .table class with all necessary styling
	// Variants are handled via CSS instead of multiple classes
	return "table"
}

// DataTable renders the main datatable organism using progressive enhancement
templ DataTable(props DataTableProps) {
	<div 
		class={ getDataTableClasses(props) }
		if props.ID != "" {
			id={ props.ID }
		}
		if props.AriaLabels["table"] != "" {
			aria-label={ props.AriaLabels["table"] }
		}
		x-data={ buildDataTableAlpineData(props) }
	>
		<!-- Header Section -->
		@dataTableHeader(props)
		
		<!-- Progressive Enhancement: Toolbar -->
		if hasFiltering(props) || hasExport(props) || hasActions(props) {
			@dataTableToolbar(props)
		}
		
		<!-- Progressive Enhancement: Bulk Actions -->
		if hasSelection(props) && hasActions(props) {
			@dataTableBulkActions(props)
		}
		
		<!-- Core Table Content -->
		<div class="datatable-container">
			@dataTableContent(props)
		</div>
		
		<!-- Progressive Enhancement: Pagination -->
		if hasPagination(props) {
			@dataTablePagination(props.Pagination)
		}
		
		<!-- Progressive Enhancement: Export Modal -->
		if hasExport(props) {
			@dataTableExportModal(props)
		}
		
		<!-- Progressive Enhancement: Analytics -->
		if hasDataTableAnalytics(props) {
			@dataTableAnalytics(props.Analytics)
		}
		
		<!-- JavaScript Integration -->
		@dataTableJavaScript(props)
	</div>
}

// buildDataTableAlpineData creates the Alpine.js data object based on enabled features
func buildDataTableAlpineData(props DataTableProps) string {
	data := `{ 
		// Core state
		loading: false,
		error: null`
	
	// Progressive Enhancement: Selection
	if hasSelection(props) {
		data += `, 
		selectedRows: [],
		selectAll: false`
	}
	
	// Progressive Enhancement: Sorting
	if hasSorting(props) {
		defaultSort := `null`
		if props.Sorting.DefaultSort != "" {
			defaultSort = `"` + props.Sorting.DefaultSort + `"`
		}
		data += fmt.Sprintf(`, 
		sortColumn: %s,
		sortDirection: 'asc'`, defaultSort)
	}
	
	// Progressive Enhancement: Filtering
	if hasFiltering(props) {
		data += `, 
		searchQuery: '',
		activeFilters: {},
		showAdvancedFilters: false`
	}
	
	// Progressive Enhancement: Pagination
	if hasPagination(props) {
		data += fmt.Sprintf(`, 
		currentPage: 1,
		pageSize: %d,
		totalPages: 1,
		totalItems: %d`, 
			utils.IfElse(props.Pagination.PageSize > 0, props.Pagination.PageSize, 10),
			len(props.Rows))
	}
	
	// Progressive Enhancement: Export
	if hasExport(props) {
		data += `, 
		showExportModal: false,
		exportFormat: 'csv',
		exporting: false`
	}
	
	// Core methods
	data += `, 
		// Core table methods
		refreshTable() { 
			this.loading = true; 
			// Trigger refresh logic
			setTimeout(() => this.loading = false, 1000);
		}`
	
	// Progressive Enhancement: Selection methods
	if hasSelection(props) {
		data += `, 
		// Selection methods
		toggleRowSelection(rowId) {
			const index = this.selectedRows.indexOf(rowId);
			if (index > -1) {
				this.selectedRows.splice(index, 1);
			} else {
				this.selectedRows.push(rowId);
			}
			this.selectAll = this.selectedRows.length === this.getVisibleRows().length;
		},
		toggleSelectAll() {
			if (this.selectAll) {
				this.selectedRows = [];
			} else {
				this.selectedRows = this.getVisibleRows().map(row => row.id);
			}
			this.selectAll = !this.selectAll;
		},
		getVisibleRows() {
			return $refs.tableBody?.querySelectorAll('tr[data-row-id]') || [];
		}`
	}
	
	// Progressive Enhancement: Sorting methods
	if hasSorting(props) {
		data += `, 
		// Sorting methods
		sortBy(column) {
			if (this.sortColumn === column) {
				this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
			} else {
				this.sortColumn = column;
				this.sortDirection = 'asc';
			}
			this.performSort();
		},
		performSort() {
			// Trigger sort logic (client or server-side)
			console.log('Sorting by:', this.sortColumn, this.sortDirection);
		}`
	}
	
	// Progressive Enhancement: Filtering methods
	if hasFiltering(props) {
		data += `, 
		// Filtering methods
		performSearch() {
			// Trigger search logic
			console.log('Searching:', this.searchQuery);
		},
		clearFilters() {
			this.searchQuery = '';
			this.activeFilters = {};
			this.performSearch();
		}`
	}
	
	// Progressive Enhancement: Export methods
	if hasExport(props) {
		data += `, 
		// Export methods
		showExport() {
			this.showExportModal = true;
		},
		hideExport() {
			this.showExportModal = false;
		},
		performExport() {
			this.exporting = true;
			// Trigger export logic
			setTimeout(() => {
				this.exporting = false;
				this.showExportModal = false;
			}, 2000);
		}`
	}
	
	data += " }"
	return data
}

// dataTableHeader renders the table header with title and description
templ dataTableHeader(props DataTableProps) {
	if props.Title != "" || props.Description != "" || hasActions(props) {
		<div class="datatable-header">
			<div class="datatable-header-content">
				if props.Title != "" {
					<h3 class="datatable-title">{ props.Title }</h3>
				}
				if props.Description != "" {
					<p class="datatable-description">{ props.Description }</p>
				}
			</div>
			
			if hasActions(props) && len(props.Actions.TableActions) > 0 {
				<div class="datatable-header-actions">
					for _, action := range props.Actions.TableActions {
						@dataTableAction(action)
					}
				</div>
			}
		</div>
	}
}

// dataTableToolbar renders search, filters, and table controls
templ dataTableToolbar(props DataTableProps) {
	if props.Filtering.Enabled || len(props.Filtering.Filters) > 0 || props.Export.Enabled {
		<div class="datatable-toolbar">
			<div class="datatable-toolbar-left">
				if props.Filtering.Enabled {
					@dataTableSearch(props.Filtering)
				}
				
				if len(props.Filtering.Filters) > 0 {
					@dataTableFilters(props.Filtering.Filters)
				}
			</div>
			
			<div class="datatable-toolbar-right">
				if props.Export.Enabled {
					@dataTableExportButton(props.Export)
				}
				
				@dataTableViewOptions(props)
			</div>
		</div>
	}
}

// dataTableSearch renders the search input
templ dataTableSearch(filtering *FilteringConfig) {
	<div class="datatable-search">
		<input
			type="text"
			class="datatable-search-input"
			placeholder={ utils.IfElse(filtering.Search.Placeholder != "", filtering.Search.Placeholder, "Search...") }
			value={ filtering.Search.Value }
			x-model="searchQuery"
			if filtering.Search.Delay > 0 {
				x-on:input={ "debounce." + fmt.Sprintf("%dms", filtering.Search.Delay) + ":performSearch()" }
			} else {
				x-on:input="performSearch()"
			}
		/>
		@atoms.Icon(atoms.IconProps{
			Name: "search",
			Size: atoms.IconSizeSM,
		})
		
		if filtering.Search.Advanced {
			@atoms.Button(atoms.ButtonProps{
				Variant: "ghost",
				Size:    "sm",
				OnClick: "showAdvancedSearch = !showAdvancedSearch",
				AriaLabel: "Toggle advanced search",
			}) {
				@atoms.Icon(atoms.IconProps{
					Name: "filter",
					Size: atoms.IconSizeSM,
				})
			}
		}
	</div>
}

// dataTableFilters renders column filters
templ dataTableFilters(filters []DataTableFilter) {
	<div class="datatable-filters">
		for _, filter := range filters {
			<div class="datatable-filter">
				<select class="datatable-filter-select" x-model={ fmt.Sprintf("filters.%s", filter.Column) }>
					<option value="">{ filter.Column }</option>
					for _, option := range filter.Options {
						<option value={ option }>{ option }</option>
					}
				</select>
			</div>
		}
		
		<button class="datatable-filter-clear" x-on:click="clearFilters()">
			Clear filters
		</button>
	</div>
}

// dataTableBulkActions renders bulk actions for selected rows
templ dataTableBulkActions(props DataTableProps) {
	if props.Actions != nil && len(props.Actions.BulkActions) > 0 {
		<div 
			class="datatable-bulk-actions"
			x-show="selectedRows.length > 0"
			x-transition
		>
			<div class="datatable-bulk-actions-content">
				<span class="datatable-bulk-actions-count" x-text="`${selectedRows.length} items selected`"></span>
				
				<div class="datatable-bulk-actions-buttons">
					for _, action := range props.Actions.BulkActions {
						@dataTableBulkAction(action)
					}
				</div>
			</div>
		</div>
	}
}

// dataTableBulkAction renders a single bulk action button
templ dataTableBulkAction(action DataTableBulkAction) {
	@atoms.Button(atoms.ButtonProps{
		Text:    action.Text,
		Variant: action.Variant,
		Size:    "sm",
		OnClick: utils.IfElse(action.Confirm, fmt.Sprintf("confirmBulkAction('%s')", action.ID), action.OnClick),
	}) {
		if action.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name: action.Icon,
				Size: atoms.IconSizeXS,
			})
		}
	}
}

// dataTableContent renders the main table content
templ dataTableContent(props DataTableProps) {
	if props.Virtualized {
		@dataTableVirtualized(props)
	} else {
		@dataTableStandard(props)
	}
}

// dataTableStandard renders the standard table
templ dataTableStandard(props DataTableProps) {
	<table class={ getTableClasses(props) }>
		<thead class="datatable-thead">
			@dataTableHeaderRow(props)
		</thead>
		<tbody class="datatable-tbody">
			for _, row := range props.Rows {
				@dataTableRow(row, props)
			}
		</tbody>
		if props.Pagination.ShowTotal {
			<tfoot class="datatable-tfoot">
				<tr>
					<td colspan={ strconv.Itoa(len(props.Columns)) } class="datatable-footer">
						Total: { strconv.Itoa(props.Pagination.TotalItems) } items
					</td>
				</tr>
			</tfoot>
		}
	</table>
}

// dataTableHeaderRow renders the table header row
templ dataTableHeaderRow(props DataTableProps) {
	<tr class="datatable-header-row">
		if props.Selectable {
			<th class="datatable-th datatable-th-checkbox">
				if props.MultiSelect {
					@atoms.Checkbox(atoms.CheckboxProps{
						ID:       "select-all",
						Name:     "select-all",
						Size:     atoms.CheckboxSizeMD,
						OnChange: "toggleAllRows()",
						AriaLabel: "Select all rows",
					})
				}
			</th>
		}
		
		for _, column := range props.Columns {
			@dataTableHeaderCell(column, props)
		}
		
		if len(props.RowActions) > 0 {
			<th class="datatable-th datatable-th-actions">Actions</th>
		}
	</tr>
}

// dataTableHeaderCell renders a table header cell
templ dataTableHeaderCell(column DataTableColumn, props DataTableProps) {
	<th 
		class="datatable-th"
		if column.Width != "" {
			style={ fmt.Sprintf("width: %s", column.Width) }
		}
		if column.Sortable {
			x-on:click={ fmt.Sprintf("sortColumn('%s')", column.Key) }
		}
	>
		<div class="datatable-th-content">
			<span class="datatable-th-text">{ column.Title }</span>
			
			if column.Sortable {
				<div class="datatable-th-sort">
					@atoms.Icon(atoms.IconProps{
						Name: "chevron-up",
						Size: atoms.IconSizeXS,
						})
					@atoms.Icon(atoms.IconProps{
						Name: "chevron-down",
						Size: atoms.IconSizeXS,
						})
				</div>
			}
			
			if column.Filterable {
				@atoms.Button(atoms.ButtonProps{
					Variant: "ghost",
					Size:    "sm",
					OnClick: fmt.Sprintf("toggleColumnFilter('%s')", column.Key),
				}) {
					@atoms.Icon(atoms.IconProps{
						Name: "filter",
						Size: atoms.IconSizeXS,
					})
				}
			}
		</div>
		
		if column.Resizable {
			<div class="datatable-th-resizer" x-on:mousedown={ fmt.Sprintf("startResize('%s', $event)", column.Key) }></div>
		}
	</th>
}

// dataTableRow renders a table row
templ dataTableRow(row DataTableRow, props DataTableProps) {
	<tr 
		class="datatable-tr"
		data-row-id={ row.ID }
		if props.OnRowClick != "" {
			x-on:click={ fmt.Sprintf("handleRowClick('%s', $event)", row.ID) }
		}
	>
		if props.Selectable {
			<td class="datatable-td datatable-td-checkbox">
				@atoms.Checkbox(atoms.CheckboxProps{
					ID:       fmt.Sprintf("select-%s", row.ID),
					Name:     "row-select",
					Value:    row.ID,
					Checked:  row.Selected,
					Size:     atoms.CheckboxSizeMD,
					OnChange: fmt.Sprintf("toggleRow('%s')", row.ID),
				})
			</td>
		}
		
		for _, column := range props.Columns {
			@dataTableCell(row, column, props)
		}
		
		if len(props.RowActions) > 0 || len(row.Actions) > 0 {
			<td class="datatable-td datatable-td-actions">
				@dataTableRowActions(row, props)
			</td>
		}
	</tr>
}

// dataTableCell renders a table cell with appropriate content
templ dataTableCell(row DataTableRow, column DataTableColumn, props DataTableProps) {
	<td 
		class="datatable-td"
		if column.Clickable {
			x-on:click={ fmt.Sprintf("handleCellClick('%s', '%s', $event)", row.ID, column.Key) }
		}
	>
		@dataTableCellContent(row.Data[column.Key], column)
	</td>
}

// dataTableCellContent renders cell content based on column type
templ dataTableCellContent(value any, column DataTableColumn) {
	switch column.Type {
	case ColumnTypeBadge:
		if strValue, ok := value.(string); ok {
			if variant, exists := column.BadgeMap[strValue]; exists {
				@atoms.Badge(atoms.BadgeProps{
					Text:    strValue,
					Variant: variant,
					Size:    atoms.BadgeSizeSM,
				})
			} else {
				@atoms.Badge(atoms.BadgeProps{
					Text:    strValue,
					Variant: "primary",
					Size:    atoms.BadgeSizeSM,
				})
			}
		}
	case ColumnTypeDate:
		if timeValue, ok := value.(time.Time); ok {
			<span class="datatable-cell-date">
				{ utils.IfElse(column.DateFormat != "", timeValue.Format(column.DateFormat), timeValue.Format("2006-01-02")) }
			</span>
		} else if strValue, ok := value.(string); ok {
			<span class="datatable-cell-date">{ strValue }</span>
		}
	case ColumnTypeNumber:
		if floatValue, ok := value.(float64); ok {
			<span class="datatable-cell-number">
				{ fmt.Sprintf("%."+strconv.Itoa(column.Precision)+"f", floatValue) }
			</span>
		} else if intValue, ok := value.(int); ok {
			<span class="datatable-cell-number">{ strconv.Itoa(intValue) }</span>
		} else if strValue, ok := value.(string); ok {
			<span class="datatable-cell-number">{ strValue }</span>
		}
	case ColumnTypeProgress:
		if floatValue, ok := value.(float64); ok {
			<div class="datatable-cell-progress">
				<div class="datatable-progress-bar">
					<div 
						class="datatable-progress-fill" 
						style={ fmt.Sprintf("width: %.1f%%", floatValue) }
					></div>
				</div>
				<span class="datatable-progress-text">{ fmt.Sprintf("%.1f%%", floatValue) }</span>
			</div>
		}
	case ColumnTypeLink:
		if strValue, ok := value.(string); ok {
			<a href={ strValue } class="datatable-cell-link">{ strValue }</a>
		}
	case ColumnTypeImage:
		if strValue, ok := value.(string); ok {
			<img src={ strValue } alt="Cell image" class="datatable-cell-image" />
		}
	default:
		if strValue, ok := value.(string); ok {
			<span class="datatable-cell-text">{ strValue }</span>
		} else if value != nil {
			<span class="datatable-cell-text">{ fmt.Sprintf("%v", value) }</span>
		}
	}
}

// dataTableRowActions renders actions for a specific row
templ dataTableRowActions(row DataTableRow, props DataTableProps) {
	<div class="datatable-row-actions" x-data="{ open: false }">
		@atoms.Button(atoms.ButtonProps{
			Variant: "ghost",
			Size:    "sm",
			OnClick: "open = !open",
		}) {
			@atoms.Icon(atoms.IconProps{
				Name: "more-vertical",
				Size: atoms.IconSizeXS,
			})
		}
		
		<div 
			class="datatable-row-actions-dropdown"
			x-show="open"
			x-on:click.away="open = false"
			x-transition
		>
			for _, action := range row.Actions {
				@molecules.MenuItem(molecules.MenuItemProps{
					Type: molecules.MenuItemTypeButton,
					Text: action.Text,
					Icon: action.Icon,
					OnClick: action.OnClick,
					HXGet: action.HXGet,
					HXPost: action.HXPost,
					HXTarget: action.HXTarget,
					AlpineClick: action.AlpineClick,
				})
			}
			
			for _, action := range props.RowActions {
				@molecules.MenuItem(molecules.MenuItemProps{
					Type: molecules.MenuItemTypeButton,
					Text: action.Text,
					Icon: action.Icon,
					OnClick: fmt.Sprintf("%s('%s')", action.OnClick, row.ID),
				})
			}
		</div>
	</div>
}

// dataTableVirtualized renders the virtualized table for large datasets
templ dataTableVirtualized(props DataTableProps) {
	<div class="datatable-virtual-container" x-ref="virtualContainer">
		<div class="datatable-virtual-header">
			<table class={ getTableClasses(props) }>
				<thead>
					@dataTableHeaderRow(props)
				</thead>
			</table>
		</div>
		
		<div 
			class="datatable-virtual-body" 
			x-ref="virtualBody"
			x-on:scroll="handleVirtualScroll()"
		>
			<div class="datatable-virtual-spacer-top" x-ref="spacerTop"></div>
			
			<table class={ getTableClasses(props) }>
				<tbody>
					<template x-for="row in visibleRows" :key="row.id">
						@dataTableRow(DataTableRow{}, props)
					</template>
				</tbody>
			</table>
			
			<div class="datatable-virtual-spacer-bottom" x-ref="spacerBottom"></div>
		</div>
	</div>
}

// dataTablePagination renders pagination controls
templ dataTablePagination(pagination *PaginationConfig) {
	if pagination.Enabled {
		<div class="datatable-pagination">
			<div class="datatable-pagination-info">
				if pagination.ShowTotal {
					<span class="datatable-pagination-total">
						{ fmt.Sprintf("Showing %d-%d of %d entries", 
							(pagination.CurrentPage-1)*pagination.PageSize+1,
							min(pagination.CurrentPage*pagination.PageSize, pagination.TotalItems),
							pagination.TotalItems,
						) }
					</span>
				}
				
				if pagination.ShowPageSize {
					<select class="datatable-pagination-page-size" x-model="pageSize" x-on:change="changePageSize()">
						for _, size := range pagination.PageSizeOptions {
							<option value={ strconv.Itoa(size) }>{ strconv.Itoa(size) } per page</option>
						}
					</select>
				}
			</div>
			
			<div class="datatable-pagination-controls">
				@atoms.Button(atoms.ButtonProps{
					Variant: "outline",
					Size:    "sm",
					OnClick: "previousPage()",
					Disabled: pagination.CurrentPage <= 1,
				}) {
					@atoms.Icon(atoms.IconProps{
						Name: "chevron-left",
						Size: atoms.IconSizeXS,
					})
				}
				
				<div class="datatable-pagination-pages">
					for i := 1; i <= pagination.TotalPages; i++ {
						@atoms.Button(atoms.ButtonProps{
							Text:    strconv.Itoa(i),
							Variant: utils.IfElse(i == pagination.CurrentPage, "primary", "ghost"),
							Size:    "sm",
							OnClick: fmt.Sprintf("goToPage(%d)", i),
						})
					}
				</div>
				
				@atoms.Button(atoms.ButtonProps{
					Variant: "outline",
					Size:    "sm",
					OnClick: "nextPage()",
					Disabled: pagination.CurrentPage >= pagination.TotalPages,
				}) {
					@atoms.Icon(atoms.IconProps{
						Name: "chevron-right",
						Size: atoms.IconSizeXS,
					})
				}
			</div>
		</div>
	}
}

// dataTableAction renders a single table action
templ dataTableAction(action DataTableAction) {
	@atoms.Button(atoms.ButtonProps{
		ID:      action.ID,
		Text:    action.Text,
		Variant: action.Variant,
		Size:    action.Size,
		OnClick: action.OnClick,
	}) {
		if action.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name: action.Icon,
				Size: atoms.IconSizeXS,
			})
		}
	}
}

// dataTableExportButton renders the export button
templ dataTableExportButton(export *ExportConfig) {
	<div class="datatable-export" x-data="{ open: false }">
		@atoms.Button(atoms.ButtonProps{
			Variant: "outline",
			Size:    "sm",
			OnClick: "open = !open",
		}) {
			@atoms.Icon(atoms.IconProps{
				Name: "download",
				Size: atoms.IconSizeXS,
			})
			Export
		}
		
		<div 
			class="datatable-export-dropdown"
			x-show="open"
			x-on:click.away="open = false"
			x-transition
		>
			for _, format := range export.Formats {
				@molecules.MenuItem(molecules.MenuItemProps{
					Type: molecules.MenuItemTypeButton,
					Text: strings.ToUpper(string(format)),
					OnClick: fmt.Sprintf("exportData('%s')", format),
				})
			}
		</div>
	</div>
}

// dataTableViewOptions renders view options (density, etc.)
templ dataTableViewOptions(props DataTableProps) {
	<div class="datatable-view-options" x-data="{ open: false }">
		@atoms.Button(atoms.ButtonProps{
			Variant: "ghost",
			Size:    "sm",
			OnClick: "open = !open",
			AriaLabel: "View options",
		}) {
			@atoms.Icon(atoms.IconProps{
				Name: "settings",
				Size: atoms.IconSizeXS,
			})
		}
		
		<div 
			class="datatable-view-options-dropdown"
			x-show="open"
			x-on:click.away="open = false"
			x-transition
		>
			<div class="datatable-view-options-section">
				<span class="datatable-view-options-label">Density</span>
				@molecules.MenuRadio(molecules.MenuItemProps{
					Text:    "Comfortable",
					Name:    "density",
					Value:   "comfortable",
					Checked: props.Density == DataTableDensityComfortable,
				})
				@molecules.MenuRadio(molecules.MenuItemProps{
					Text:    "Compact",
					Name:    "density",
					Value:   "compact",
					Checked: props.Density == DataTableDensityCompact,
				})
				@molecules.MenuRadio(molecules.MenuItemProps{
					Text:    "Condensed",
					Name:    "density",
					Value:   "condensed",
					Checked: props.Density == DataTableDensityCondensed,
				})
			</div>
			
			<div class="datatable-view-options-section">
				<span class="datatable-view-options-label">Columns</span>
				for _, column := range props.Columns {
					@molecules.MenuCheckbox(molecules.MenuItemProps{
						Text:    column.Title,
						Name:    "columns",
						Value:   column.Key,
						Checked: column.Visible,
					})
				}
			</div>
		</div>
	</div>
}

// dataTableExportModal renders the export modal
templ dataTableExportModal(props DataTableProps) {
	if props.Export.Enabled {
		<div 
			class="datatable-export-modal"
			x-show="showExportModal"
			x-transition
		>
			<div class="datatable-export-modal-content">
				<div class="datatable-export-modal-header">
					<h3>Export Data</h3>
					@atoms.Button(atoms.ButtonProps{
						Variant: "ghost",
						Size:    "sm",
						OnClick: "showExportModal = false",
					}) {
						@atoms.Icon(atoms.IconProps{
							Name: "x",
							Size: atoms.IconSizeXS,
						})
					}
				</div>
				
				<div class="datatable-export-modal-body">
					<!-- Export options would go here -->
				</div>
				
				<div class="datatable-export-modal-footer">
					@atoms.Button(atoms.ButtonProps{
						Text:    "Cancel",
						Variant: "outline",
						OnClick: "showExportModal = false",
					})
					@atoms.Button(atoms.ButtonProps{
						Text:    "Export",
						Variant: stringPrimary,
						OnClick: "confirmExport()",
					})
				</div>
			</div>
		</div>
	}
}

// Helper function to build Alpine.js data for the datatable
func buildDataTableAlpineDataV2(props DataTableProps) string {
	return fmt.Sprintf(`{
		// Data
		rows: %s,
		filteredRows: [],
		visibleRows: [],
		
		// State
		selectedRows: [],
		sortColumn: '',
		sortDirection: 'asc',
		searchQuery: '',
		filters: {},
		currentPage: %d,
		pageSize: %d,
		
		// UI State
		showAdvancedSearch: false,
		showExportModal: false,
		loading: false,
		
		// Virtual scrolling
		virtualScrollTop: 0,
		virtualItemHeight: 40,
		
		// Methods
		init() {
			this.filteredRows = [...this.rows];
			this.updateVisibleRows();
			%s
		},
		
		performSearch() {
			// Search implementation
			console.log('Searching for:', this.searchQuery);
		},
		
		sortColumn(column) {
			if (this.sortColumn === column) {
				this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
			} else {
				this.sortColumn = column;
				this.sortDirection = 'asc';
			}
			this.applySorting();
		},
		
		applySorting() {
			// Sorting implementation
			console.log('Sorting by:', this.sortColumn, this.sortDirection);
		},
		
		toggleRow(rowId) {
			const index = this.selectedRows.indexOf(rowId);
			if (index > -1) {
				this.selectedRows.splice(index, 1);
			} else {
				this.selectedRows.push(rowId);
			}
		},
		
		toggleAllRows() {
			if (this.selectedRows.length === this.filteredRows.length) {
				this.selectedRows = [];
			} else {
				this.selectedRows = this.filteredRows.map(row => row.id);
			}
		},
		
		clearFilters() {
			this.filters = {};
			this.searchQuery = '';
			this.performSearch();
		},
		
		exportData(format) {
			console.log('Exporting as:', format);
			this.showExportModal = true;
		},
		
		updateVisibleRows() {
			// Update visible rows for pagination/virtualization
		},
		
		%s
	}`,
		"props.rows", // This would be replaced with actual row data
		props.Pagination.CurrentPage,
		props.Pagination.PageSize,
		utils.IfElse(props.StatePersist, "this.loadState();", ""),
		utils.IfElse(props.Virtualized, `
		handleVirtualScroll() {
			// Virtual scrolling implementation
		},
		`, ""),
	)
}

// dataTableAnalytics renders analytics tracking components for DataTable
templ dataTableAnalytics(analytics *DataTableAnalyticsConfig) {
	<script>
		// DataTable analytics tracking
		if (typeof gtag !== 'undefined' || typeof analytics !== 'undefined') {
			// Track sorting actions
			if ({ fmt.Sprintf("%t", analytics.TrackSort) }) {
				document.addEventListener('table-sorted', function(e) {
					const eventName = '{ analytics.EventPrefix }datatable_sort';
					const eventData = {
						column: e.detail.column,
						direction: e.detail.direction,
						timestamp: new Date().toISOString()
					};
					
					if (typeof gtag !== 'undefined') {
						gtag('event', eventName, eventData);
					}
					
					if (typeof analytics !== 'undefined') {
						analytics.track(eventName, eventData);
					}
				});
			}
			
			// Track filtering actions
			if ({ fmt.Sprintf("%t", analytics.TrackFilter) }) {
				document.addEventListener('table-filtered', function(e) {
					const eventName = '{ analytics.EventPrefix }datatable_filter';
					const eventData = {
						filter_type: e.detail.type,
						filter_value: e.detail.value,
						results_count: e.detail.results || 0,
						timestamp: new Date().toISOString()
					};
					
					if (typeof gtag !== 'undefined') {
						gtag('event', eventName, eventData);
					}
					
					if (typeof analytics !== 'undefined') {
						analytics.track(eventName, eventData);
					}
				});
			}
			
			// Track export actions
			if ({ fmt.Sprintf("%t", analytics.TrackExport) }) {
				document.addEventListener('table-exported', function(e) {
					const eventName = '{ analytics.EventPrefix }datatable_export';
					const eventData = {
						format: e.detail.format,
						row_count: e.detail.rowCount || 0,
						timestamp: new Date().toISOString()
					};
					
					if (typeof gtag !== 'undefined') {
						gtag('event', eventName, eventData);
					}
					
					if (typeof analytics !== 'undefined') {
						analytics.track(eventName, eventData);
					}
				});
			}
			
			// Track selection actions
			if ({ fmt.Sprintf("%t", analytics.TrackSelection) }) {
				document.addEventListener('table-selection-changed', function(e) {
					const eventName = '{ analytics.EventPrefix }datatable_selection';
					const eventData = {
						selection_type: e.detail.type, // 'single', 'multiple', 'all'
						selected_count: e.detail.count,
						timestamp: new Date().toISOString()
					};
					
					if (typeof gtag !== 'undefined') {
						gtag('event', eventName, eventData);
					}
					
					if (typeof analytics !== 'undefined') {
						analytics.track(eventName, eventData);
					}
				});
			}
		}
	</script>
}

// dataTableJavaScript integrates the JavaScript DataTable library with the Go templ component
templ dataTableJavaScript(props DataTableProps) {
	<script type="module">
		// Import the DataTable JavaScript library
		import { DataTable } from '/static/dist/datatable.js';
		
		// Wait for DOM to be ready
		document.addEventListener('DOMContentLoaded', function() {
			// Find the table element
			const tableElement = document.querySelector('#{ props.ID } table');
			if (!tableElement) return;
			
			// Configure DataTable options from Go props
			const config = {
				// Core configuration
				data: {
					columns: [
						{ for i, column := range props.Columns }
							{
								key: '{ column.Key }',
								title: '{ column.Title }',
								type: '{ string(column.Type) }',
								sortable: { fmt.Sprintf("%t", column.Sortable) },
								searchable: { fmt.Sprintf("%t", column.Searchable) },
								width: '{ column.Width }',
								align: '{ column.Align }'
							}{ if i < len(props.Columns)-1 },{ end }
						{ end }
					],
					rows: [
						{ for i, row := range props.Data }
							{
								{ for j, column := range props.Columns }
									'{ column.Key }': { if value, exists := row[column.Key]; exists }'{ fmt.Sprintf("%v", value) }'{ else }''{ end }{ if j < len(props.Columns)-1 },{ end }
								{ end }
							}{ if i < len(props.Data)-1 },{ end }
						{ end }
					]
				},
				
				// Feature configuration
				features: {
					{ if hasSorting(props) }
						sorting: {
							enabled: true,
							{ if props.Sorting.MultiColumn }multiColumn: true,{ end }
							{ if props.Sorting.DefaultSort.Column != "" }
								defaultSort: {
									column: '{ props.Sorting.DefaultSort.Column }',
									direction: '{ props.Sorting.DefaultSort.Direction }'
								}
							{ end }
						},
					{ end }
					
					{ if hasFiltering(props) }
						filtering: {
							enabled: true,
							{ if props.Filtering.GlobalSearch }globalSearch: true,{ end }
							{ if props.Filtering.ColumnFilters }columnFilters: true,{ end }
						},
					{ end }
					
					{ if hasPagination(props) }
						pagination: {
							enabled: true,
							pageSize: { props.Pagination.PageSize },
							{ if props.Pagination.ShowPageSize }showPageSize: true,{ end }
							{ if props.Pagination.ShowInfo }showInfo: true,{ end }
						},
					{ end }
					
					{ if hasSelection(props) }
						selection: {
							enabled: true,
							{ if props.Selection.Multiple }multiple: true,{ end }
							{ if props.Selection.ShowSelectAll }showSelectAll: true,{ end }
						},
					{ end }
					
					{ if hasExport(props) }
						export: {
							enabled: true,
							formats: [
								{ for i, format := range props.Export.Formats }
									'{ string(format) }'{ if i < len(props.Export.Formats)-1 },{ end }
								{ end }
							]
						},
					{ end }
					
					{ if hasPerformance(props) && props.Performance.VirtualScrolling }
						virtualScrolling: {
							enabled: true,
							rowHeight: { props.Performance.RowHeight },
							overscan: { props.Performance.Overscan }
						},
					{ end }
				},
				
				// Integration with Alpine.js
				{ if props.Alpine != nil }
					alpine: {
						data: '{ props.Alpine.DataName }',
						{ if props.Alpine.SelectionCallback != "" }
							onSelectionChange: '{ props.Alpine.SelectionCallback }',
						{ end }
						{ if props.Alpine.SortCallback != "" }
							onSortChange: '{ props.Alpine.SortCallback }',
						{ end }
						{ if props.Alpine.FilterCallback != "" }
							onFilterChange: '{ props.Alpine.FilterCallback }',
						{ end }
					},
				{ end }
				
				// HTMX integration
				{ if props.HTMX != nil }
					htmx: {
						{ if props.HTMX.SortEndpoint != "" }
							sortEndpoint: '{ props.HTMX.SortEndpoint }',
						{ end }
						{ if props.HTMX.FilterEndpoint != "" }
							filterEndpoint: '{ props.HTMX.FilterEndpoint }',
						{ end }
						{ if props.HTMX.PaginationEndpoint != "" }
							paginationEndpoint: '{ props.HTMX.PaginationEndpoint }',
						{ end }
						{ if props.HTMX.Target != "" }
							target: '{ props.HTMX.Target }',
						{ end }
						{ if props.HTMX.Swap != "" }
							swap: '{ props.HTMX.Swap }',
						{ end }
					},
				{ end }
			};
			
			// Initialize the DataTable
			const dataTable = new DataTable(tableElement, config);
			
			// Store reference for external access
			tableElement.dataTable = dataTable;
			
			// Emit initialization event for analytics
			{ if hasDataTableAnalytics(props) }
				document.dispatchEvent(new CustomEvent('table-initialized', {
					detail: {
						id: '{ props.ID }',
						rowCount: { len(props.Data) },
						columnCount: { len(props.Columns) },
						features: Object.keys(config.features || {})
					}
				}));
			{ end }
			
			// Handle window resize for responsive behavior
			{ if props.Layout != nil && props.Layout.Responsive }
				let resizeTimeout;
				window.addEventListener('resize', function() {
					clearTimeout(resizeTimeout);
					resizeTimeout = setTimeout(function() {
						dataTable.handleResize();
					}, 250);
				});
			{ end }
			
			// Initial load completion
			dataTable.on('ready', function() {
				// Remove loading state if present
				const loadingEl = document.querySelector('#{ props.ID } .datatable-loading');
				if (loadingEl) {
					loadingEl.style.display = 'none';
				}
				
				// Show table content
				const tableContainer = document.querySelector('#{ props.ID } .datatable-container');
				if (tableContainer) {
					tableContainer.style.opacity = '1';
				}
			});
			
			// Error handling
			dataTable.on('error', function(error) {
				console.error('DataTable error:', error);
				
				// Show error message
				const errorEl = document.querySelector('#{ props.ID } .datatable-error');
				if (errorEl) {
					errorEl.textContent = error.message || 'An error occurred';
					errorEl.style.display = 'block';
				}
				
				// Emit error event for analytics
				{ if hasDataTableAnalytics(props) }
					document.dispatchEvent(new CustomEvent('table-error', {
						detail: {
							id: '{ props.ID }',
							error: error.message,
							timestamp: new Date().toISOString()
						}
					}));
				{ end }
			});
		});
	</script>
}
