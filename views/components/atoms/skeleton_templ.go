// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.943
package atoms

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

// SkeletonProps defines all properties for the Skeleton atom using custom CSS extension
// Uses /static/css/components/skeleton.css following Basecoat conventions
type SkeletonProps struct {
	// Core properties
	ID string `json:"id,omitempty"`

	// Visual properties
	Shape   string `json:"shape,omitempty"`   // "text", "heading", "avatar", "button", "card"
	Size    string `json:"size,omitempty"`    // "sm", "md", "lg", "xl"
	Variant string `json:"variant,omitempty"` // "", "wave"

	// Custom dimensions (when not using predefined shapes)
	Width  string `json:"width,omitempty"`
	Height string `json:"height,omitempty"`

	// Additional attributes
	DataAttrs  map[string]string `json:"dataAttrs,omitempty"`
	Attributes templ.Attributes  `json:"attributes,omitempty"`
}

// getSkeletonClass generates the skeleton class using our CSS extension
func getSkeletonClass(shape, size, variant string) string {
	class := "skeleton"

	// Add shape modifier
	if shape != "" {
		class = "skeleton-" + shape
	}

	// Add size modifier (only if no shape or if shape is generic)
	if size != "" && (shape == "" || shape == "text") {
		class += " skeleton-" + size
	}

	// Add animation variant
	if variant == "wave" {
		class += " skeleton-wave"
	}

	return class
}

// buildSkeletonAttributes creates div attributes
func buildSkeletonAttributes(props SkeletonProps) templ.Attributes {
	attrs := templ.Attributes{
		"class": getSkeletonClass(props.Shape, props.Size, props.Variant),
	}

	if props.ID != "" {
		attrs["id"] = props.ID
	}

	// Custom dimensions
	if props.Width != "" || props.Height != "" {
		style := ""
		if props.Width != "" {
			style += "width: " + props.Width + ";"
		}
		if props.Height != "" {
			style += "height: " + props.Height + ";"
		}
		attrs["style"] = style
	}

	// Data attributes
	for key, value := range props.DataAttrs {
		attrs["data-"+key] = value
	}

	// Merge custom attributes
	for key, value := range props.Attributes {
		attrs[key] = value
	}

	return attrs
}

// Skeleton renders a loading skeleton using custom CSS extension
func Skeleton(props SkeletonProps) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templ.RenderAttributes(ctx, templ_7745c5c3_Buffer, buildSkeletonAttributes(props))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
