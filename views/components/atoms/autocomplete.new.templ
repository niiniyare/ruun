package atoms

import (
	"encoding/json"
	"fmt"
	"strings"
)

// AutoCompleteOption represents an option in the autocomplete dropdown
type AutoCompleteOption struct {
	Value       string `json:"value"`
	Label       string `json:"label"`
	Description string `json:"description"`
	Disabled    bool   `json:"disabled"`
	Icon        string `json:"icon"`
	Meta        string `json:"meta"` // Additional metadata to display
}

// AutoCompleteProps defines the properties for the AutoComplete component
type AutoCompleteProps struct {
	ID           string
	Name         string
	Value        string // Selected value
	DisplayValue string // Display value (may differ from value)
	Options      []AutoCompleteOption
	Placeholder  string
	MinChars     int    // Minimum characters before showing suggestions
	MaxResults   int    // Maximum number of results to show
	Required     bool
	Disabled     bool
	Readonly     bool
	Error        bool
	Class        string
	// Search configuration
	SearchURL    string // URL for dynamic option loading via HTMX
	Debounce     int    // Debounce delay in milliseconds
	// Display options
	ShowClear    bool   // Show clear button
	ShowIcon     bool   // Show search icon
	FreeForm     bool   // Allow free-form text entry
	// HTMX attributes
	HXPost       string
	HXGet        string
	HXTarget     string
	HXSwap       string
	HXTrigger    string
	// Alpine.js attributes
	AlpineModel  string
	AlpineChange string
	AlpineBlur   string
	AlpineFocus  string
	// Accessibility
	AriaLabel           string
	AriaDescribedBy     string
	// Display customization
	NoResultsText       string // Custom "no results" message
	LoadingText         string // Custom loading message
}

// escapeJSString safely escapes a string for use in JavaScript
func escapeJSString(s string) string {
	if s == "" {
		return "''"
	}
	// Use JSON marshaling for proper escaping
	b, err := json.Marshal(s)
	if err != nil {
		// Fallback to empty string if marshaling fails
		return "''"
	}
	return string(b)
}

// autoCompleteClasses generates Tailwind CSS classes for the autocomplete container
func autoCompleteClasses(props AutoCompleteProps) string {
	var classes []string

	// Base classes
	classes = append(classes,
		"autocomplete",
		"relative",
		"w-full",
	)

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return strings.Join(classes, " ")
}

// autoCompleteInputClasses generates Tailwind CSS classes for the input
func autoCompleteInputClasses(props AutoCompleteProps) string {
	var classes []string

	// Base classes
	classes = append(classes,
		"flex",
		"w-full",
		"rounded-md",
		"border",
		"border-input",
		"bg-background",
		"text-sm",
		"ring-offset-background",
		"file:border-0",
		"file:bg-transparent",
		"file:text-sm",
		"file:font-medium",
		"placeholder:text-muted-foreground",
		"focus-visible:outline-none",
		"focus-visible:ring-2",
		"focus-visible:ring-ring",
		"focus-visible:ring-offset-2",
		"disabled:cursor-not-allowed",
		"disabled:opacity-50",
	)

	// Fixed padding logic based on icons
	paddingClasses := []string{"py-2"}
	
	// Left padding
	if props.ShowIcon {
		paddingClasses = append(paddingClasses, "pl-10")
	} else {
		paddingClasses = append(paddingClasses, "pl-3")
	}
	
	// Right padding
	if props.ShowClear {
		paddingClasses = append(paddingClasses, "pr-10")
	} else {
		paddingClasses = append(paddingClasses, "pr-3")
	}
	
	classes = append(classes, paddingClasses...)

	// Error state
	if props.Error {
		classes = append(classes, "border-destructive")
	}

	return strings.Join(classes, " ")
}

// autoCompleteDropdownClasses generates Tailwind CSS classes for the dropdown
func autoCompleteDropdownClasses() string {
	return strings.Join([]string{
		"absolute",
		"z-50",
		"w-full",
		"mt-1",
		"max-h-60",
		"overflow-auto",
		"rounded-md",
		"border",
		"bg-popover",
		"p-1",
		"text-popover-foreground",
		"shadow-md",
	}, " ")
}

// autoCompleteOptionClasses generates Tailwind CSS classes for dropdown options
func autoCompleteOptionClasses(option AutoCompleteOption, isHighlighted bool) string {
	var classes []string

	// Base classes
	classes = append(classes,
		"relative",
		"flex",
		"w-full",
		"cursor-default",
		"select-none",
		"items-start",
		"rounded-sm",
		"px-2",
		"py-1.5",
		"text-sm",
		"outline-none",
	)

	// State classes
	if isHighlighted {
		classes = append(classes, "bg-accent", "text-accent-foreground")
	} else {
		classes = append(classes,
			"hover:bg-accent",
			"hover:text-accent-foreground",
		)
	}

	// Disabled state
	if option.Disabled {
		classes = append(classes, "pointer-events-none", "opacity-50")
	}

	return strings.Join(classes, " ")
}

// getAlpineModelName extracts the model name from AlpineModel prop
func getAlpineModelName(alpineModel string) string {
	if alpineModel == "" {
		return "selectedValue"
	}
	// Remove x-model= prefix if present
	modelName := strings.TrimPrefix(alpineModel, "x-model=")
	modelName = strings.TrimSpace(modelName)
	if modelName == "" {
		return "selectedValue"
	}
	return modelName
}

// generateAutoCompleteAlpineData generates Alpine.js data for the autocomplete component
func generateAutoCompleteAlpineData(props AutoCompleteProps) string {
	debounce := props.Debounce
	if debounce == 0 {
		debounce = 300 // Default 300ms debounce
	}

	minChars := props.MinChars
	if minChars == 0 {
		minChars = 1 // Default minimum 1 character
	}

	maxResults := props.MaxResults
	if maxResults == 0 {
		maxResults = 10 // Default maximum 10 results
	}

	modelName := getAlpineModelName(props.AlpineModel)
	
	// Use proper JSON encoding for safety
	optionsJSON, _ := json.Marshal(props.Options)
	if optionsJSON == nil {
		optionsJSON = []byte("[]")
	}

	// Build the Alpine data object with proper escaping
	return fmt.Sprintf(`{
		open: false,
		query: %s,
		selectedValue: %s,
		highlightedIndex: -1,
		options: %s,
		loading: false,
		searchTimeout: null,
		freeForm: %t,
		
		init() {
			this.$watch('query', (value) => {
				if (value.length >= %d) {
					this.searchOptions();
				} else {
					this.open = false;
				}
			});
		},
		
		searchOptions() {
			if (this.query.length < %d) {
				this.open = false;
				return;
			}
			
			this.loading = true;
			this.highlightedIndex = -1;
			
			// Debounced search
			clearTimeout(this.searchTimeout);
			this.searchTimeout = setTimeout(() => {
				this.performSearch();
			}, %d);
		},
		
		performSearch() {
			if (%s && this.query.length >= %d) {
				// HTMX will handle the search request
				// Set open to true, but HTMX will populate options
				this.open = true;
				// Don't set loading to false yet - HTMX indicator will handle it
			} else {
				// Filter local options
				const filtered = this.filterLocalOptions(this.query);
				this.options = filtered.slice(0, %d);
				this.open = filtered.length > 0;
				this.loading = false;
			}
		},
		
		filterLocalOptions(query) {
			const searchTerm = query.toLowerCase();
			return %s.filter(option => 
				!option.disabled && (
					option.label.toLowerCase().includes(searchTerm) ||
					(option.description && option.description.toLowerCase().includes(searchTerm)) ||
					(option.meta && option.meta.toLowerCase().includes(searchTerm))
				)
			);
		},
		
		selectOption(option) {
			if (option.disabled) return;
			
			this.selectedValue = option.value;
			this.query = option.label;
			this.open = false;
			this.highlightedIndex = -1;
			
			// Update the bound model if different from selectedValue
			if ('%s' !== 'selectedValue') {
				this.%s = option.value;
			}
			
			// Trigger change event
			this.$el.querySelector('input[type="hidden"]').dispatchEvent(new Event('change', { bubbles: true }));
		},
		
		clearSelection() {
			this.selectedValue = '';
			this.query = '';
			this.open = false;
			
			if ('%s' !== 'selectedValue') {
				this.%s = '';
			}
			
			// Trigger change event
			this.$el.querySelector('input[type="hidden"]').dispatchEvent(new Event('change', { bubbles: true }));
		},
		
		handleKeydown(event) {
			if (!this.open && ['ArrowDown', 'ArrowUp'].includes(event.key)) {
				// Open dropdown on arrow key if there are options
				if (this.query.length >= %d) {
					event.preventDefault();
					this.open = true;
					this.highlightedIndex = 0;
				}
				return;
			}
			
			if (!this.open) return;
			
			switch (event.key) {
				case 'ArrowDown':
					event.preventDefault();
					this.highlightedIndex = Math.min(this.highlightedIndex + 1, this.options.length - 1);
					this.scrollToHighlighted();
					break;
				case 'ArrowUp':
					event.preventDefault();
					this.highlightedIndex = Math.max(this.highlightedIndex - 1, -1);
					this.scrollToHighlighted();
					break;
				case 'Enter':
					event.preventDefault();
					if (this.highlightedIndex >= 0 && this.options[this.highlightedIndex]) {
						this.selectOption(this.options[this.highlightedIndex]);
					} else if (this.freeForm && this.query) {
						// Allow free-form entry
						this.selectedValue = this.query;
						if ('%s' !== 'selectedValue') {
							this.%s = this.query;
						}
						this.open = false;
					}
					break;
				case 'Escape':
					event.preventDefault();
					this.open = false;
					this.highlightedIndex = -1;
					break;
				case 'Tab':
					// Allow tab to close dropdown without preventing default
					this.open = false;
					this.highlightedIndex = -1;
					break;
			}
		},
		
		scrollToHighlighted() {
			// Scroll highlighted option into view
			this.$nextTick(() => {
				const dropdown = this.$el.querySelector('[role="listbox"]');
				const highlighted = dropdown?.querySelector('[data-highlighted="true"]');
				if (highlighted) {
					highlighted.scrollIntoView({ block: 'nearest' });
				}
			});
		},
		
		onFocus() {
			if (this.query.length >= %d) {
				this.open = true;
			}
		},
		
		onBlur() {
			// Delay to allow option selection
			setTimeout(() => {
				// If freeForm is enabled and query doesn't match selected, update value
				if (this.freeForm && this.query && this.query !== this.selectedValue) {
					this.selectedValue = this.query;
					if ('%s' !== 'selectedValue') {
						this.%s = this.query;
					}
				}
				
				this.open = false;
				this.highlightedIndex = -1;
			}, 200);
		},
		
		// HTMX integration: Call this after HTMX replaces options
		updateOptionsFromHTMX(newOptions) {
			this.options = newOptions;
			this.open = newOptions.length > 0;
			this.loading = false;
		}
	}`,
		escapeJSString(props.DisplayValue),
		escapeJSString(props.Value),
		string(optionsJSON),
		props.FreeForm,
		minChars,
		minChars,
		debounce,
		escapeJSString(props.SearchURL),
		minChars,
		maxResults,
		string(optionsJSON),
		modelName,
		modelName,
		modelName,
		modelName,
		minChars,
		modelName,
		modelName,
		minChars,
		modelName,
		modelName,
	)
}

// formatOptionsForAlpine formats options for Alpine.js data (kept for backward compatibility but uses JSON now)
func formatOptionsForAlpine(options []AutoCompleteOption) string {
	optionsJSON, err := json.Marshal(options)
	if err != nil {
		return "[]"
	}
	return string(optionsJSON)
}

// AutoComplete renders an autocomplete input component
templ AutoComplete(props AutoCompleteProps) {
	// Set defaults for display text
	if props.NoResultsText == "" {
		props.NoResultsText = "No results found"
	}
	if props.LoadingText == "" {
		props.LoadingText = "Loading..."
	}
	
	<div
		class={ autoCompleteClasses(props) }
		if props.ID != "" {
			id={ props.ID + "-container" }
		}
		x-data={ generateAutoCompleteAlpineData(props) }
		@click.outside="onBlur()"
	>
		<!-- Hidden input for form submission -->
		<input 
			type="hidden" 
			name={ props.Name } 
			x-model="selectedValue"
			if props.AlpineModel != "" {
				x-model={ getAlpineModelName(props.AlpineModel) }
			}
		/>
		
		<!-- Input container -->
		<div class="relative">
			<!-- Search icon -->
			if props.ShowIcon {
				<div 
					class="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground pointer-events-none"
					aria-hidden="true"
				>
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<circle cx="11" cy="11" r="8"></circle>
						<path d="m21 21-4.35-4.35"></path>
					</svg>
				</div>
			}
			
			<!-- Input field -->
			<input
				type="text"
				if props.ID != "" {
					id={ props.ID }
				}
				x-model="query"
				@input="searchOptions()"
				@keydown="handleKeydown($event)"
				@focus="onFocus()"
				@blur="onBlur()"
				if props.Placeholder != "" {
					placeholder={ props.Placeholder }
				}
				if props.Required && !props.FreeForm {
					required
				}
				if props.Disabled {
					disabled
				}
				if props.Readonly {
					readonly
				}
				class={ autoCompleteInputClasses(props) }
				autocomplete="off"
				role="combobox"
				aria-expanded="false"
				x-bind:aria-expanded="open.toString()"
				if props.ID != "" {
					aria-controls={ props.ID + "-listbox" }
				}
				aria-autocomplete="list"
				if props.AriaLabel != "" {
					aria-label={ props.AriaLabel }
				}
				if props.AriaDescribedBy != "" {
					aria-describedby={ props.AriaDescribedBy }
				}
				if props.HXPost != "" {
					hx-post={ props.HXPost }
				}
				if props.HXGet != "" {
					hx-get={ props.HXGet }
				}
				if props.HXTarget != "" {
					hx-target={ props.HXTarget }
				}
				if props.HXSwap != "" {
					hx-swap={ props.HXSwap }
				}
				if props.HXTrigger != "" {
					hx-trigger={ props.HXTrigger }
				}
				if props.SearchURL != "" {
					hx-get={ props.SearchURL }
					hx-trigger="input changed delay:300ms"
					if props.ID != "" {
						hx-target={ "#" + props.ID + "-options" }
					}
					hx-swap="innerHTML"
					if props.ID != "" {
						hx-indicator={ "#" + props.ID + "-loading" }
					}
				}
				if props.AlpineChange != "" {
					x-on:change={ props.AlpineChange }
				}
				if props.AlpineBlur != "" {
					x-on:blur={ props.AlpineBlur }
				}
				if props.AlpineFocus != "" {
					x-on:focus={ props.AlpineFocus }
				}
			/>
			
			<!-- Clear button -->
			if props.ShowClear {
				<button
					type="button"
					@click="clearSelection()"
					x-show="selectedValue !== ''"
					class="absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground hover:text-foreground focus:outline-none"
					aria-label="Clear selection"
					tabindex="-1"
				>
					<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<line x1="18" y1="6" x2="6" y2="18"></line>
						<line x1="6" y1="6" x2="18" y2="18"></line>
					</svg>
				</button>
			}
			
			<!-- Loading indicator -->
			<div 
				if props.ID != "" {
					id={ props.ID + "-loading" }
				}
				class="absolute right-3 top-1/2 transform -translate-y-1/2 htmx-indicator"
				x-show="loading"
				style="display: none;"
				aria-hidden="true"
			>
				<svg class="w-4 h-4 animate-spin text-muted-foreground" fill="none" viewBox="0 0 24 24">
					<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
					<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
				</svg>
			</div>
		</div>
		
		<!-- Dropdown -->
		<div
			class={ autoCompleteDropdownClasses() }
			x-show="open && (options.length > 0 || loading)"
			x-transition
			if props.ID != "" {
				id={ props.ID + "-listbox" }
			}
			role="listbox"
		>
			<!-- Options container -->
			<div 
				if props.ID != "" {
					id={ props.ID + "-options" }
				}
			>
				<template x-for="(option, index) in options" :key="option.value">
					<div
						class="relative flex w-full cursor-default select-none items-start rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground"
						x-bind:class="{ 'bg-accent text-accent-foreground': index === highlightedIndex, 'pointer-events-none opacity-50': option.disabled }"
						x-bind:data-highlighted="index === highlightedIndex"
						@click="selectOption(option)"
						@mouseenter="highlightedIndex = index"
						role="option"
						x-bind:aria-selected="(index === highlightedIndex).toString()"
						x-bind:aria-disabled="option.disabled ? 'true' : 'false'"
					>
						<!-- Option content -->
						<div class="flex-1 min-w-0">
							<div class="flex items-center gap-2">
								<template x-if="option.icon">
									<span class="text-muted-foreground" x-text="option.icon" aria-hidden="true"></span>
								</template>
								<span class="truncate" x-text="option.label"></span>
								<template x-if="option.meta">
									<span class="text-xs text-muted-foreground" x-text="option.meta"></span>
								</template>
							</div>
							<template x-if="option.description">
								<p class="text-xs text-muted-foreground truncate mt-0.5" x-text="option.description"></p>
							</template>
						</div>
					</div>
				</template>
			</div>
			
			<!-- Loading message -->
			<div 
				x-show="loading && options.length === 0" 
				class="px-2 py-1.5 text-sm text-muted-foreground"
				role="status"
			>
				{ props.LoadingText }
			</div>
			
			<!-- No results message -->
			<div 
				x-show="open && options.length === 0 && !loading" 
				class="px-2 py-1.5 text-sm text-muted-foreground"
				role="status"
			>
				{ props.NoResultsText }
			</div>
		</div>
	</div>
}
