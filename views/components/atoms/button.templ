package atoms

import "github.com/niiniyare/ruun/views/components"

// ButtonProps defines all properties for the Button atom 
// Combines Basecoat semantic classes with Tailwind utilities
type ButtonProps struct {
	// Content
	Text string          `json:"text"`
	Icon templ.Component `json:"icon,omitempty"`
	
	// Basecoat variants (using shared types)
	Variant components.ButtonVariant `json:"variant,omitempty"`
	Size    components.Size          `json:"size,omitempty"`
	
	// Icon positioning (for Tailwind spacing utilities)
	IconPosition string `json:"iconPosition,omitempty"` // "start" | "end" (default: "start")
	
	// HTML attributes  
	Type  string `json:"type,omitempty"` // "button", "submit", "reset"
	Name  string `json:"name,omitempty"`
	Value string `json:"value,omitempty"`
	
	// Form attributes
	Form       string `json:"form,omitempty"`
	FormAction string `json:"formAction,omitempty"`
	FormMethod string `json:"formMethod,omitempty"`
	FormTarget string `json:"formTarget,omitempty"`
	
	// Additional attributes using templ.Attributes for extensibility
	Attrs templ.Attributes `json:"attrs,omitempty"`
	
	// Shared component props (includes ClassName for Tailwind utilities)
	Base components.BaseProps `json:"base,omitempty"`
}

// getButtonClass returns the correct single Basecoat class
// Uses exact patterns from documentation - no dynamic class building
func getButtonClass(variant components.ButtonVariant, size components.Size, iconOnly bool) string {
	// Static switch-based approach following documentation exactly
	if iconOnly {
		switch size {
		case components.SizeSm:
			switch variant {
			case components.ButtonSecondary:
				return "btn-sm-icon-secondary"
			case components.ButtonOutline:
				return "btn-sm-icon-outline"
			case components.ButtonGhost:
				return "btn-sm-icon-ghost"
			case components.ButtonLink:
				return "btn-sm-icon-link"
			case components.ButtonDestructive:
				return "btn-sm-icon-destructive"
			default: // primary, default, or empty
				return "btn-sm-icon"
			}
		case components.SizeLg:
			switch variant {
			case components.ButtonSecondary:
				return "btn-lg-icon-secondary"
			case components.ButtonOutline:
				return "btn-lg-icon-outline" 
			case components.ButtonGhost:
				return "btn-lg-icon-ghost"
			case components.ButtonLink:
				return "btn-lg-icon-link"
			case components.ButtonDestructive:
				return "btn-lg-icon-destructive"
			default: // primary, default, or empty
				return "btn-lg-icon"
			}
		default: // default size
			switch variant {
			case components.ButtonSecondary:
				return "btn-icon-secondary"
			case components.ButtonOutline:
				return "btn-icon-outline"
			case components.ButtonGhost:
				return "btn-icon-ghost"
			case components.ButtonLink:
				return "btn-icon-link"
			case components.ButtonDestructive:
				return "btn-icon-destructive"
			default: // primary, default, or empty
				return "btn-icon"
			}
		}
	} else {
		switch size {
		case components.SizeSm:
			switch variant {
			case components.ButtonSecondary:
				return "btn-sm-secondary"
			case components.ButtonOutline:
				return "btn-sm-outline"
			case components.ButtonGhost:
				return "btn-sm-ghost"
			case components.ButtonLink:
				return "btn-sm-link"
			case components.ButtonDestructive:
				return "btn-sm-destructive"
			default: // primary, default, or empty
				return "btn-sm"
			}
		case components.SizeLg:
			switch variant {
			case components.ButtonSecondary:
				return "btn-lg-secondary"
			case components.ButtonOutline:
				return "btn-lg-outline"
			case components.ButtonGhost:
				return "btn-lg-ghost"
			case components.ButtonLink:
				return "btn-lg-link"
			case components.ButtonDestructive:
				return "btn-lg-destructive"
			default: // primary, default, or empty
				return "btn-lg"
			}
		default: // default size
			switch variant {
			case components.ButtonSecondary:
				return "btn-secondary"
			case components.ButtonOutline:
				return "btn-outline"
			case components.ButtonGhost:
				return "btn-ghost"
			case components.ButtonLink:
				return "btn-link"
			case components.ButtonDestructive:
				return "btn-destructive"
			default: // primary, default, or empty - matches doc examples
				return "btn"
			}
		}
	}
}

// buildButtonAttributes creates all HTML attributes for the button element
func buildButtonAttributes(props ButtonProps) templ.Attributes {
	attrs := templ.Attributes{
		"class": templ.Classes(
			getButtonClass(props.Variant, props.Size, props.Icon != nil && props.Text == ""),
			props.Base.ClassName,
		),
	}

	// Button type
	if props.Type != "" {
		attrs["type"] = props.Type
	} else {
		attrs["type"] = "button"
	}

	// Base attributes
	if props.Base.ID != "" {
		attrs["id"] = props.Base.ID
	}
	if props.Name != "" {
		attrs["name"] = props.Name
	}
	if props.Value != "" {
		attrs["value"] = props.Value
	}

	// Form attributes
	if props.Form != "" {
		attrs["form"] = props.Form
	}
	if props.FormAction != "" {
		attrs["formaction"] = props.FormAction
	}
	if props.FormEncType != "" {
		attrs["formenctype"] = props.FormEncType
	}
	if props.FormMethod != "" {
		attrs["formmethod"] = props.FormMethod
	}
	if props.FormTarget != "" {
		attrs["formtarget"] = props.FormTarget
	}

	// State
	if props.Base.State.Disabled {
		attrs["disabled"] = ""
	}

	// HTMX attributes
	if props.Base.HTMX.Post != "" {
		attrs["hx-post"] = props.Base.HTMX.Post
	}
	if props.Base.HTMX.Get != "" {
		attrs["hx-get"] = props.Base.HTMX.Get
	}
	if props.Base.HTMX.Put != "" {
		attrs["hx-put"] = props.Base.HTMX.Put
	}
	if props.Base.HTMX.Patch != "" {
		attrs["hx-patch"] = props.Base.HTMX.Patch
	}
	if props.Base.HTMX.Delete != "" {
		attrs["hx-delete"] = props.Base.HTMX.Delete
	}
	if props.Base.HTMX.Target != "" {
		attrs["hx-target"] = props.Base.HTMX.Target
	}
	if props.Base.HTMX.Swap != "" {
		attrs["hx-swap"] = props.Base.HTMX.Swap
	}
	if props.Base.HTMX.Trigger != "" {
		attrs["hx-trigger"] = props.Base.HTMX.Trigger
	}
	if props.Base.HTMX.Confirm != "" {
		attrs["hx-confirm"] = props.Base.HTMX.Confirm
	}

	// Accessibility attributes
	if props.Base.A11y.AriaLabel != "" {
		attrs["aria-label"] = props.Base.A11y.AriaLabel
	}
	if props.Base.A11y.AriaDescribedBy != "" {
		attrs["aria-describedby"] = props.Base.A11y.AriaDescribedBy
	}
	if props.Base.A11y.AriaLabelledBy != "" {
		attrs["aria-labelledby"] = props.Base.A11y.AriaLabelledBy
	}
	if props.Base.A11y.AriaExpanded != "" {
		attrs["aria-expanded"] = props.Base.A11y.AriaExpanded
	}
	if props.Base.A11y.AriaHaspopup != "" {
		attrs["aria-haspopup"] = props.Base.A11y.AriaHaspopup
	}
	if props.Base.A11y.AriaPressed != "" {
		attrs["aria-pressed"] = props.Base.A11y.AriaPressed
	}
	if props.Base.A11y.AriaSelected != "" {
		attrs["aria-selected"] = props.Base.A11y.AriaSelected
	}
	if props.Base.A11y.Role != "" {
		attrs["role"] = props.Base.A11y.Role
	}

	// Event handlers (as strings for HTML attributes)
	if props.Base.Events.OnClick != "" {
		attrs["onclick"] = props.Base.Events.OnClick
	}

	// Merge custom attributes
	for key, value := range props.Attrs {
		attrs[key] = value
	}

	return attrs
}

// Button renders a Basecoat button atom with Tailwind utilities support
// Follows documentation pattern: Basecoat classes + Tailwind utilities
templ Button(props ButtonProps) {
	<button {buildButtonAttributes(props)...}>
		if props.Icon != nil && props.Text != "" {
			if props.IconPosition == "end" {
				{props.Text}
				@props.Icon
			} else {
				@props.Icon
				{props.Text}
			}
		} else if props.Icon != nil {
			@props.Icon
		} else if props.Text != "" {
			{props.Text}
		}
	</button>
}