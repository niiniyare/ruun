package organisms

// SCHEMA INTEGRATION UPDATE GUIDE
// This file shows how to update the existing SchemaForm component to support all new field types

// Enhanced mapping function for schema types to form field types
func mapSchemaTypeToFormType(schemaType string, widget string) molecules.FormFieldType {
	// Widget override - highest priority
	if widget != "" {
		switch widget {
		// Text widgets
		case "textarea":
			return molecules.FormFieldTextarea
		case "password":
			return molecules.FormFieldPassword
		case "email":
			return molecules.FormFieldEmail
		case "search":
			return molecules.FormFieldSearch
		
		// Selection widgets
		case "select":
			return molecules.FormFieldSelect
		case "radio":
			return molecules.FormFieldRadio
		case "checkbox":
			return molecules.FormFieldCheckbox
		case "checkbox-group":
			return molecules.FormFieldCheckboxGroup
		case "multi-select":
			return molecules.FormFieldMultiSelect
		case "autocomplete":
			return molecules.FormFieldAutoComplete
		case "tags":
			return molecules.FormFieldTags
			
		// Date/time widgets
		case "date":
			return molecules.FormFieldDate
		case "time":
			return molecules.FormFieldTime
		case "datetime":
			return molecules.FormFieldDateTime
		case "date-range":
			return molecules.FormFieldDateRange
		}
	}
	
	// Schema type mapping - fallback to type-based mapping
	switch schemaType {
	// Text types
	case "string":
		return molecules.FormFieldText
	case "email":
		return molecules.FormFieldEmail
	case "password":
		return molecules.FormFieldPassword
	case "text", "longtext":
		return molecules.FormFieldTextarea
	case "url":
		return molecules.FormFieldText
	case "phone":
		return molecules.FormFieldText
		
	// Number types
	case "number", "integer", "float":
		return molecules.FormFieldNumber
	case "currency":
		return molecules.FormFieldNumber // With currency formatting
		
	// Boolean types
	case "boolean":
		return molecules.FormFieldCheckbox
		
	// Date/time types
	case "date":
		return molecules.FormFieldDate
	case "time":
		return molecules.FormFieldTime
	case "datetime", "timestamp":
		return molecules.FormFieldDateTime
	case "date-range":
		return molecules.FormFieldDateRange
		
	// Array/selection types
	case "array":
		// Check if it has predefined options
		return molecules.FormFieldCheckboxGroup
	case "enum":
		return molecules.FormFieldRadio
	case "reference", "foreign-key":
		return molecules.FormFieldAutoComplete
		
	// File types
	case "file":
		return molecules.FormFieldText // File upload component when implemented
	case "image":
		return molecules.FormFieldText // Image upload component when implemented
		
	default:
		return molecules.FormFieldText
	}
}

// Enhanced field conversion function for schema form
func convertSchemaToFormFieldsEnhanced(fields []SchemaField, props SchemaFormProps) []molecules.FormFieldProps {
	var formFields []molecules.FormFieldProps
	
	for _, field := range fields {
		// Skip hidden fields
		if field.Hidden {
			continue
		}
		
		// Determine field type
		fieldType := mapSchemaTypeToFormType(field.Type, field.Widget)
		
		// Convert schema options to form field options
		var options []molecules.SelectOption
		for _, opt := range field.Options {
			options = append(options, molecules.SelectOption{
				Value:       opt.Value,
				Label:       opt.Label,
				Description: opt.Description,
				Disabled:    opt.Disabled,
				Icon:        opt.Icon,
			})
		}
		
		// Handle multi-value fields
		var values []string
		if field.Multiple && fieldType == molecules.FormFieldCheckboxGroup {
			// Convert current value to string array if needed
			if arrayVal, ok := getFieldValue(field.Name, props.Data).([]string); ok {
				values = arrayVal
			}
		}
		
		// Build form field props
		formField := molecules.FormFieldProps{
			Type:        fieldType,
			ID:          field.Name,
			Name:        field.Name,
			Label:       getFieldLabel(field, props.Locale),
			Value:       convertToString(getFieldValue(field.Name, props.Data)),
			Values:      values,
			Placeholder: getFieldPlaceholder(field, props.Locale),
			HelpText:    getFieldDescription(field, props.Locale),
			ErrorText:   getFieldError(field.Name, props.Errors),
			Required:    field.Required,
			Disabled:    props.ReadOnly || field.ReadOnly,
			Readonly:    field.ReadOnly,
			Options:     options,
			Multiple:    field.Multiple,
			
			// Validation props
			MinLength:   field.MinLength,
			MaxLength:   field.MaxLength,
			Min:         convertToString(field.Min),
			Max:         convertToString(field.Max),
			Pattern:     field.Pattern,
			
			// Layout props
			Inline:      field.Widget == "inline",
			Columns:     field.ColumnSpan,
			
			// Date/time props
			ShowCalendar: fieldType == molecules.FormFieldDate,
			Format24:     field.Widget == "time24",
			
			// AutoComplete props
			SearchURL:    getFieldDataSourceURL(field),
			MinChars:     getFieldMinChars(field),
			MaxResults:   getFieldMaxResults(field),
			Debounce:     300, // Default debounce
			ShowClear:    true,
			ShowIcon:     fieldType == molecules.FormFieldAutoComplete,
			FreeForm:     field.Widget == "autocomplete-free",
			
			// HTMX integration
			HXPost:       getFieldValidationURL(field.Reference, field.Name),
			HXTarget:     "#field-" + field.Name + "-feedback",
			HXTrigger:    getFieldTrigger(props.Schema.Validation.RealTime),
			
			// Alpine.js integration
			AlpineModel:  "formData." + field.Name,
			AlpineChange: "validateField('" + field.Name + "')",
			AlpineBlur:   getFieldBlurValidation(props.Schema.Validation.OnBlur, field.Name),
		}
		
		formFields = append(formFields, formField)
	}
	
	return formFields
}

// Helper functions for enhanced schema integration
func getFieldDataSourceURL(field SchemaField) string {
	if field.Reference != "" {
		return "/api/search/" + field.Reference
	}
	return ""
}

func getFieldMinChars(field SchemaField) int {
	if minChars, ok := field.Attributes["minChars"].(int); ok {
		return minChars
	}
	return 2 // Default
}

func getFieldMaxResults(field SchemaField) int {
	if maxResults, ok := field.Attributes["maxResults"].(int); ok {
		return maxResults
	}
	return 10 // Default
}

// Example of how to use the enhanced FormField in SchemaForm
templ SchemaFormEnhanced(props SchemaFormProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ "schema-form " + props.Class }
		x-data={ getSchemaFormAlpineDataEnhanced(props) }
		x-init="initForm()"
	>
		@Form(FormProps{
			Layout:      props.Schema.Layout,
			Method:      props.Schema.Method,
			Action:      props.Schema.Action,
			Class:       "space-y-6",
			HXPost:      props.Schema.SubmitURL,
			HXTarget:    "#" + props.ID + "-result",
			HXSwap:      "innerHTML",
		}) {
			// Render sections
			for _, section := range props.Schema.Sections {
				<div class="form-section space-y-4">
					if section.Title != "" {
						<h3 class="text-lg font-medium leading-6 text-foreground">
							{ section.Title }
						</h3>
					}
					if section.Description != "" {
						<p class="text-sm text-muted-foreground">
							{ section.Description }
						</p>
					}
					
					// Grid layout for fields
					<div class="grid gap-4" style={ getGridColumns(props.Schema.GridCols) }>
						for _, field := range convertSchemaToFormFieldsEnhanced(section.Fields, props) {
							@molecules.FormFieldEnhanced(field)
						}
					</div>
				</div>
			}
			
			// Fields not in sections
			if len(props.Schema.Fields) > 0 {
				<div class="grid gap-4" style={ getGridColumns(props.Schema.GridCols) }>
					for _, field := range convertSchemaToFormFieldsEnhanced(props.Schema.Fields, props) {
						@molecules.FormFieldEnhanced(field)
					}
				</div>
			}
			
			// Form actions
			<div class="form-actions flex gap-3">
				for _, action := range getSchemaFormActions(props) {
					@atoms.Button(action)
				}
			</div>
		}
		
		// Debug information (if enabled)
		if props.Debug {
			<div class="debug-info mt-8 p-4 bg-muted rounded-md">
				<h4 class="font-medium mb-2">Debug Information</h4>
				<pre class="text-xs text-muted-foreground" x-text="JSON.stringify(formData, null, 2)"></pre>
			</div>
		}
	</div>
}

// Enhanced Alpine.js data for schema form
func getSchemaFormAlpineDataEnhanced(props SchemaFormProps) string {
	return fmt.Sprintf(`{
		formData: %s,
		errors: %s,
		touched: {},
		dirty: {},
		submitting: false,
		
		initForm() {
			// Initialize form state
			this.setupValidation();
			this.setupConditionalLogic();
			this.setupAutoSave();
		},
		
		validateField(fieldName) {
			// Mark field as touched
			this.touched[fieldName] = true;
			
			// Trigger validation
			if (%t) {
				this.performValidation(fieldName);
			}
		},
		
		performValidation(fieldName) {
			// Real-time validation logic
			if (fieldName) {
				// Validate single field
				this.validateSingleField(fieldName);
			} else {
				// Validate all fields
				this.validateAllFields();
			}
		},
		
		validateSingleField(fieldName) {
			// HTMX will handle server-side validation
			// This can also include client-side validation
		},
		
		validateAllFields() {
			// Comprehensive validation
			Object.keys(this.formData).forEach(field => {
				this.validateSingleField(field);
			});
		},
		
		setupConditionalLogic() {
			// Watch for field changes that trigger conditional logic
			Object.keys(this.formData).forEach(fieldName => {
				this.$watch('formData.' + fieldName, (value, oldValue) => {
					this.evaluateConditions(fieldName, value, oldValue);
				});
			});
		},
		
		evaluateConditions(fieldName, value, oldValue) {
			// Evaluate conditional field visibility/requirements
			// This would integrate with the schema condition engine
		},
		
		setupAutoSave() {
			if (%t) {
				this.$watch('formData', () => {
					this.autoSave();
				});
			}
		},
		
		autoSave() {
			// Auto-save form data
			if (this.isDirty()) {
				// Debounced save logic
			}
		},
		
		isDirty() {
			return Object.keys(this.dirty).some(key => this.dirty[key]);
		},
		
		markFieldDirty(fieldName) {
			this.dirty[fieldName] = true;
		},
		
		handleSubmit() {
			this.submitting = true;
			this.validateAllFields();
			// HTMX will handle the actual submission
		},
		
		resetForm() {
			this.formData = %s;
			this.errors = {};
			this.touched = {};
			this.dirty = {};
			this.submitting = false;
		}
	}`, 
		formatMapForAlpine(props.Data),
		formatMapForAlpine(props.Errors),
		props.Schema.Validation.RealTime,
		props.Schema.AutoSave,
		formatMapForAlpine(props.Data))
}

// NOTE: To integrate these new components into the existing system:
//
// 1. Update the existing FormField component to include the new field types
// 2. Update the schema form component to use the enhanced field mapping
// 3. Update the schema package to export the new field type constants
// 4. Add the new field types to the schema validation
// 5. Update the CSS to include styles for the new components
// 6. Test all new components with real schema data
//
// The new components provide:
// - Complete radio button and checkbox support
// - Advanced multi-select with search
// - Comprehensive date/time pickers
// - Autocomplete with dynamic loading
// - Full HTMX and Alpine.js integration
// - Accessibility compliance
// - Schema contract adherence