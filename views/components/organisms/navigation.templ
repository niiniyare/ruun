package organisms

import (
	"strings"
	"strconv"
	"fmt"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
	"github.com/niiniyare/ruun/pkg/utils"
)

// NavigationType defines the type of navigation
type NavigationType string

const (
	NavigationSidebar    NavigationType = "sidebar"
	NavigationTopbar     NavigationType = "topbar"
	NavigationBreadcrumb NavigationType = "breadcrumb"
	NavigationTabs       NavigationType = "tabs"
	NavigationSteps      NavigationType = "steps"
)

// NavigationSize defines the size variants
type NavigationSize string

const (
	NavigationSizeSM NavigationSize = "sm"
	NavigationSizeMD NavigationSize = "md"
	NavigationSizeLG NavigationSize = "lg"
)

// NavigationItem represents a navigation item
type NavigationItem struct {
	ID          string
	Text        string
	Description string
	URL         string
	Icon        string
	Badge       string
	BadgeVariant atoms.BadgeVariant
	Active      bool
	Disabled    bool
	External    bool  // Opens in new tab
	Divider     bool  // Render as divider
	Class       string
	// Nested items
	Items       []NavigationItem
	Collapsible bool
	Collapsed   bool
	// HTMX attributes
	HXGet       string
	HXPost      string
	HXTarget    string
	HXSwap      string
	// Alpine.js attributes
	AlpineClick string
	// Events
	OnClick     string
}

// NavigationProps defines the properties for enhanced Navigation components
type NavigationProps struct {
	// Core properties
	Type        NavigationType
	Size        NavigationSize
	Items       []NavigationItem
	Title       string
	Description string
	Logo        string
	LogoURL     string
	Collapsible bool
	Collapsed   bool
	Class       string
	ID          string
	
	// Enhanced layout options
	Width       string // CSS width value
	Position    string // "left", "right"
	Variant     string // "default", "minimal", "card"
	
	// User interface
	UserMenu    []NavigationItem
	UserName    string
	UserAvatar  string
	UserOnline  bool
	UserRole    string
	
	// Search configuration
	Search      NavigationSearch
	
	// Breadcrumb configuration
	Breadcrumbs []BreadcrumbItem
	Separator   string // Custom separator
	
	// Tabs specific
	TabVariant  string // "default", "pills", "underline"
	
	// Steps specific
	CurrentStep int
	TotalSteps  int
	
	// Mobile menu
	MobileMenu  NavigationMobileMenu
	
	// Notifications
	Notifications []Notification
	
	// HTMX attributes
	HXGet       string
	HXTarget    string
	HXSwap      string
	HXTrigger   string
	
	// Alpine.js attributes
	AlpineData  string
	AlpineInit  string
	
	// Events
	OnItemClick string
	OnToggle    string
	OnSearch    string
	OnUserMenuToggle string
	
	// Auth and permissions
	AuthContext *AuthContext
	
	// Performance
	LazyLoad    bool
	CacheData   bool
	
	// Theme integration
	ThemeID     string
	DarkMode    bool
	
	// Accessibility
	AriaLabel   string
	AriaLabels  map[string]string
}

// NavigationSearch defines search configuration
type NavigationSearch struct {
	Enabled     bool
	Placeholder string
	MinLength   int
	Debounce    int
	Results     []NavigationSearchResult
	Loading     bool
	Visible     bool
}

// NavigationSearchResult represents a search result
type NavigationSearchResult struct {
	ID          string
	Text        string
	Description string
	URL         string
	Icon        string
	Score       int
	Highlighted string
}

// NavigationMobileMenu defines mobile menu configuration
type NavigationMobileMenu struct {
	Enabled     bool
	Position    string // "left", "right", "top", "bottom"
	Overlay     bool
	CloseButton bool
	Swipeable   bool
}

// navigationClasses generates classes for enhanced navigation containers
func navigationClasses(props NavigationProps) string {
	var classes []string

	// Base navigation classes
	classes = append(classes, "navigation")

	switch props.Type {
	case NavigationSidebar:
		classes = append(classes, "navigation-sidebar", "flex", "flex-col", "bg-background", "border-r", "border-border")
		
		// Variant classes
		switch props.Variant {
		case "minimal":
			classes = append(classes, "navigation-sidebar--minimal")
		case "card":
			classes = append(classes, "navigation-sidebar--card", "m-4", "rounded-lg", "shadow-sm")
		default:
			classes = append(classes, "navigation-sidebar--default")
		}
		
		// Width handling
		if props.Width != "" {
			// Width handled via inline style
		} else {
			if props.Collapsed {
				classes = append(classes, "w-16")
			} else {
				classes = append(classes, "w-64")
			}
		}
		
		// Collapsed state
		if props.Collapsed {
			classes = append(classes, "navigation-sidebar--collapsed")
		}
		
	case NavigationTopbar:
		classes = append(classes, "navigation-topbar", "flex", "items-center", "justify-between", "bg-background", "border-b", "border-border", "px-4")
		
		// Height based on size
		switch props.Size {
		case NavigationSizeSM:
			classes = append(classes, "h-12", "px-3")
		case NavigationSizeLG:
			classes = append(classes, "h-20", "px-6")
		default:
			classes = append(classes, "h-16")
		}
		
	case NavigationBreadcrumb:
		classes = append(classes, "navigation-breadcrumb", "flex", "items-center", "space-x-1", "text-sm", "text-muted-foreground")
		
	case NavigationTabs:
		classes = append(classes, "navigation-tabs", "flex", "border-b", "border-border")
		
		// Tab variant classes
		switch props.TabVariant {
		case "pills":
			classes = append(classes, "navigation-tabs--pills", "border-0", "space-x-1")
		case "underline":
			classes = append(classes, "navigation-tabs--underline")
		default:
			classes = append(classes, "navigation-tabs--default")
		}
		
	case NavigationSteps:
		classes = append(classes, "navigation-steps", "flex", "items-center", "justify-between")
	}

	// Search enabled class
	if props.Search.Enabled {
		classes = append(classes, "navigation--searchable")
	}

	// Mobile menu enabled class
	if props.MobileMenu.Enabled {
		classes = append(classes, "navigation--mobile")
	}

	// Theme classes
	if props.DarkMode {
		classes = append(classes, "navigation--dark")
	}

	// Performance classes
	if props.LazyLoad {
		classes = append(classes, "navigation--lazy")
	}

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return utils.TwMerge(classes...)
}

// Navigation renders enhanced navigation components with auth integration
templ Navigation(props NavigationProps) {
	// Navigation container with Alpine.js state
	<div
		if props.ID != "" {
			id={ props.ID }
		} else {
			id={ utils.RandomID() }
		}
		class={ navigationClasses(props) }
		if props.AlpineData != "" {
			x-data={ props.AlpineData }
		} else {
			x-data={ getDefaultNavigationAlpineData(props) }
		}
		if props.AlpineInit != "" {
			x-init={ props.AlpineInit }
		} else {
			x-init="initNavigation()"
		}
		if props.AriaLabel != "" {
			aria-label={ props.AriaLabel }
		}
		role="navigation"
	>
		// Render navigation content based on type
		switch props.Type {
		case NavigationSidebar:
			@enhancedSidebarNavigation(props)
		case NavigationTopbar:
			@enhancedTopbarNavigation(props)
		case NavigationBreadcrumb:
			@enhancedBreadcrumbNavigation(props)
		case NavigationTabs:
			@enhancedTabsNavigation(props)
		case NavigationSteps:
			@enhancedStepsNavigation(props)
		default:
			@enhancedSidebarNavigation(props)
		}
		
		// Search overlay
		if props.Search.Enabled {
			@navigationSearchOverlay(props)
		}
		
		// Mobile menu overlay
		if props.MobileMenu.Enabled {
			@navigationMobileOverlay(props)
		}
		
		// Notification toast container
		if len(props.Notifications) > 0 {
			@navigationNotifications(props)
		}
	</div>
}

// enhancedSidebarNavigation renders enhanced sidebar navigation with auth integration
templ enhancedSidebarNavigation(props NavigationProps) {
	<aside
		class="navigation-sidebar-content flex flex-col h-full"
		if props.Width != "" {
			style={ "width: " + props.Width }
		}
	>
		// Sidebar header with logo and controls
		<div class="navigation-header flex items-center justify-between p-4 border-b border-border">
			<div class="flex items-center gap-3" x-show="!sidebarCollapsed || !$root.isMobile">
				if props.Logo != "" {
					<img 
						src={ props.Logo } 
						alt="Logo" 
						class="h-8 w-8 rounded"
						if props.LogoURL != "" {
							x-on:click={ "window.location.href='" + props.LogoURL + "'" }
							style="cursor: pointer;"
						}
					/>
				}
				if props.Title != "" {
					<div x-show="!sidebarCollapsed">
						<h1 class="text-lg font-semibold text-foreground">{ props.Title }</h1>
						if props.Description != "" {
							<p class="text-xs text-muted-foreground">{ props.Description }</p>
						}
					</div>
				}
			</div>
			
			// Sidebar controls
			<div class="flex items-center gap-2">
				// Search toggle button
				if props.Search.Enabled {
					<button
						class="p-2 hover:bg-accent rounded-sm transition-colors"
						x-on:click="toggleSearch()"
						x-bind:class="{'bg-accent': searchOpen}"
						aria-label="Toggle search"
					>
						@atoms.Icon(atoms.IconProps{
							Name: "search",
							Size: atoms.IconSizeSM,
							Class: "text-muted-foreground",
						})
					</button>
				}
				
				// Collapse toggle button
				if props.Collapsible {
					<button
						class="p-2 hover:bg-accent rounded-sm transition-colors"
						x-on:click="toggleSidebar()"
						x-bind:aria-expanded="!sidebarCollapsed"
						aria-label="Toggle sidebar"
					>
						@atoms.Icon(atoms.IconProps{
							Name: "menu",
							Size: atoms.IconSizeSM,
							Class: "text-muted-foreground transition-transform duration-200",
							XBind: "{'rotate-90': sidebarCollapsed}",
						})
					</button>
				}
			</div>
		</div>

		// Search bar (when enabled and visible)
		if props.Search.Enabled {
			<div 
				class="navigation-search p-4 border-b border-border"
				x-show="searchOpen && !sidebarCollapsed"
				x-transition:enter="transition ease-out duration-200"
				x-transition:enter-start="opacity-0 transform -translate-y-2"
				x-transition:enter-end="opacity-100 transform translate-y-0"
			>
				@enhancedNavigationSearch(props)
			</div>
		}

		// Navigation content
		<nav class="navigation-content flex-1 overflow-auto p-2">
			@enhancedNavigationMenu(props)
		</nav>

		// User section at bottom
		if props.AuthContext != nil && props.AuthContext.User != nil {
			<div class="navigation-user border-t border-border p-4">
				@navigationUserSection(props)
			</div>
		}
	</aside>
}

// enhancedTopbarNavigation renders enhanced topbar navigation
templ enhancedTopbarNavigation(props NavigationProps) {
	<header class="navigation-topbar-content">
		// Left section with logo and main nav
		<div class="flex items-center gap-6">
			if props.Logo != "" || props.Title != "" {
				<div class="flex items-center gap-3">
					if props.Logo != "" {
						<img 
							src={ props.Logo } 
							alt="Logo" 
							class="h-8 w-8"
							if props.LogoURL != "" {
								x-on:click={ "window.location.href='" + props.LogoURL + "'" }
								style="cursor: pointer;"
							}
						/>
					}
					if props.Title != "" {
						<h1 class="text-lg font-semibold">{ props.Title }</h1>
					}
				</div>
			}
			
			// Main navigation items (desktop)
			<nav class="hidden md:flex items-center space-x-1">
				@enhancedTopbarMenu(props)
			</nav>
		</div>

		// Right section with search, notifications, and user menu
		<div class="flex items-center gap-3">
			// Search button/field
			if props.Search.Enabled {
				<div class="relative">
					<button
						class="p-2 hover:bg-accent rounded-md transition-colors"
						x-on:click="toggleSearch()"
						x-bind:class="{'bg-accent': searchOpen}"
					>
						@atoms.Icon(atoms.IconProps{Name: "search", Size: atoms.IconSizeSM})
					</button>
				</div>
			}
			
			// Notifications
			if len(props.Notifications) > 0 {
				@navigationNotificationButton(props)
			}
			
			// User menu
			if props.AuthContext != nil && props.AuthContext.User != nil {
				@navigationUserMenu(props)
			}

			// Mobile menu toggle
			if props.MobileMenu.Enabled {
				<button
					class="md:hidden p-2 hover:bg-accent rounded-md transition-colors"
					x-on:click="toggleMobileMenu()"
					aria-label="Toggle mobile menu"
				>
					@atoms.Icon(atoms.IconProps{
						Name: "menu",
						Size: atoms.IconSizeSM,
						Class: "transition-transform duration-200",
						XBind: "{'rotate-90': mobileMenuOpen}",
					})
				</button>
			}
		</div>
	</header>
}

// enhancedBreadcrumbNavigation renders enhanced breadcrumb navigation
templ enhancedBreadcrumbNavigation(props NavigationProps) {
	<nav
		class="navigation-breadcrumb-content"
		aria-label="Breadcrumb"
	>
		<ol class="flex items-center space-x-1">
			if len(props.Breadcrumbs) > 0 {
				for i, item := range props.Breadcrumbs {
					<li class="flex items-center">
						if i > 0 {
							<span class="mx-2 text-muted-foreground">
								if props.Separator != "" {
									{ props.Separator }
								} else {
									@atoms.Icon(atoms.IconProps{Name: "chevron-right", Size: atoms.IconSizeXS})
								}
							</span>
						}
						
						if item.Active {
							// Current page
							<span class="font-medium text-foreground" aria-current="page">
								if item.Icon != "" {
									@atoms.Icon(atoms.IconProps{Name: item.Icon, Size: atoms.IconSizeXS, Class: "mr-1"})
								}
								{ item.Text }
							</span>
						} else if item.Clickable && item.URL != "" {
							// Linked item
							<a
								href={ item.URL }
								class="text-muted-foreground hover:text-foreground transition-colors"
							>
								if item.Icon != "" {
									@atoms.Icon(atoms.IconProps{Name: item.Icon, Size: atoms.IconSizeXS, Class: "mr-1"})
								}
								{ item.Text }
							</a>
						} else {
							// Non-linked item
							<span class="text-muted-foreground">
								if item.Icon != "" {
									@atoms.Icon(atoms.IconProps{Name: item.Icon, Size: atoms.IconSizeXS, Class: "mr-1"})
								}
								{ item.Text }
							</span>
						}
					</li>
				}
			}
		</ol>
	</nav>
}

// enhancedTabsNavigation renders enhanced tabs navigation
templ enhancedTabsNavigation(props NavigationProps) {
	<nav
		class="navigation-tabs-content"
		role="tablist"
	>
		for _, item := range props.Items {
			@enhancedTabNavItem(item, props)
		}
	</nav>
}

// enhancedStepsNavigation renders enhanced steps navigation
templ enhancedStepsNavigation(props NavigationProps) {
	<nav
		class="navigation-steps-content"
		aria-label="Steps"
	>
		<div class="flex items-center justify-between">
			for i, item := range props.Items {
				@enhancedStepNavItem(item, i+1, props.CurrentStep, i < len(props.Items)-1, props.TotalSteps)
			}
		</div>
		
		// Progress indicator
		if props.TotalSteps > 0 {
			<div class="mt-4">
				<div class="flex justify-between text-sm text-muted-foreground mb-2">
					<span>Step { strconv.Itoa(props.CurrentStep) } of { strconv.Itoa(props.TotalSteps) }</span>
					<span>{ strconv.Itoa((props.CurrentStep * 100) / props.TotalSteps) }% complete</span>
				</div>
				<div class="w-full bg-secondary rounded-full h-2">
					<div 
						class="bg-primary h-2 rounded-full transition-all duration-300"
						style={ fmt.Sprintf("width: %d%%", (props.CurrentStep * 100) / props.TotalSteps) }
					></div>
				</div>
			</div>
		}
	</nav>
}

// sidebarNavigation renders a sidebar navigation
templ sidebarNavigation(props NavigationProps) {
	<aside
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		if props.Width != "" {
			style={ "width: " + props.Width }
		}
		if props.AlpineData != "" {
			x-data={ props.AlpineData }
		} else if props.Collapsible {
			x-data={ getNavigationAlpineData(props.Collapsed) }
		}
	>
		// Sidebar header
		<div class="flex items-center justify-between p-4 border-b border-border">
			<div class="flex items-center gap-3">
				if props.Logo != "" {
					<img 
						src={ props.Logo } 
						alt="Logo" 
						class="h-8 w-8"
						if props.LogoURL != "" {
							x-on:click={ "window.location.href='" + props.LogoURL + "'" }
							style="cursor: pointer;"
						}
					/>
				}
				if props.Title != "" {
					<h1 
						class="text-lg font-semibold"
						if props.Collapsible {
							x-show="!collapsed"
						}
					>{ props.Title }</h1>
				}
			</div>
			
			if props.Collapsible {
				<button
					class="p-1 hover:bg-accent rounded-sm"
					x-on:click="collapsed = !collapsed"
				>
					@atoms.Icon(atoms.IconProps{
						Name: "menu",
						Size: atoms.IconSizeSM,
						Class: "text-muted-foreground",
					})
				</button>
			}
		</div>

		// Navigation items
		<nav class="flex-1 overflow-auto p-2">
			<ul class="space-y-1">
				for _, item := range props.Items {
					@sidebarNavItem(item, props, 0)
				}
			</ul>
		</nav>
	</aside>
}

// sidebarNavItem renders a sidebar navigation item
templ sidebarNavItem(item NavigationItem, props NavigationProps, depth int) {
	<li>
		if item.Divider {
			<div class="h-px bg-border my-2 mx-2"></div>
		} else {
			<div class="relative">
				if item.URL != "" || item.HXGet != "" || item.HXPost != "" {
					// Link item
					<a
						if item.ID != "" {
							id={ item.ID }
						}
						if item.URL != "" {
							href={ item.URL }
						}
						if item.External {
							target="_blank"
							rel="noopener noreferrer"
						}
						class={ getSidebarItemClasses(item, depth, props.Collapsible) }
						if item.HXGet != "" {
							hx-get={ item.HXGet }
						}
						if item.HXPost != "" {
							hx-post={ item.HXPost }
						}
						if item.HXTarget != "" {
							hx-target={ item.HXTarget }
						}
						if item.HXSwap != "" {
							hx-swap={ item.HXSwap }
						}
						if item.AlpineClick != "" {
							x-on:click={ item.AlpineClick }
						}
					>
						@sidebarItemContent(item, props.Collapsible)
					</a>
				} else {
					// Button item or parent item
					<button
						if item.ID != "" {
							id={ item.ID }
						}
						class={ getSidebarItemClasses(item, depth, props.Collapsible) }
						if len(item.Items) > 0 && item.Collapsible {
							x-data={ getNavItemAlpineData(item.Collapsed) }
							x-on:click="open = !open"
						}
						if item.AlpineClick != "" {
							x-on:click={ item.AlpineClick }
						}
						if item.Disabled {
							disabled
						}
					>
						@sidebarItemContent(item, props.Collapsible)
						if len(item.Items) > 0 && item.Collapsible {
							@atoms.Icon(atoms.IconProps{
								Name: "chevron-down",
								Size: atoms.IconSizeXS,
								Class: "ml-auto transition-transform duration-200 x-bind:class=\"{'rotate-180': !open}\"",
							})
						}
					</button>
				}

				// Nested items
				if len(item.Items) > 0 {
					<ul
						class={ getSubItemClasses(depth) }
						if item.Collapsible {
							x-show="open"
							x-transition
						}
					>
						for _, subItem := range item.Items {
							@sidebarNavItem(subItem, props, depth+1)
						}
					</ul>
				}
			</div>
		}
	</li>
}

// sidebarItemContent renders the content of a sidebar item
templ sidebarItemContent(item NavigationItem, collapsible bool) {
	<div class="flex items-center gap-3">
		if item.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name:  item.Icon,
				Size:  atoms.IconSizeSM,
				Class: "shrink-0",
			})
		}
		
		<div 
			class="flex-1 min-w-0"
			if collapsible {
				x-show="!collapsed"
			}
		>
			<div class="font-medium">{ item.Text }</div>
			if item.Description != "" {
				<div class="text-xs text-muted-foreground">{ item.Description }</div>
			}
		</div>
		
		if item.Badge != "" {
			<span 
				if collapsible {
					x-show="!collapsed"
				}
			>
				@atoms.Badge(atoms.BadgeProps{
					Variant: getNavItemBadgeVariant(item.BadgeVariant),
					Size:    atoms.BadgeSizeSM,
				}) {
					{ item.Badge }
				}
			</span>
		}
	</div>
}

// topbarNavigation renders a top navigation bar
templ topbarNavigation(props NavigationProps) {
	<header
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
	>
		// Left section with logo and main nav
		<div class="flex items-center gap-6">
			if props.Logo != "" || props.Title != "" {
				<div class="flex items-center gap-3">
					if props.Logo != "" {
						<img 
							src={ props.Logo } 
							alt="Logo" 
							class="h-8 w-8"
							if props.LogoURL != "" {
								x-on:click={ "window.location.href='" + props.LogoURL + "'" }
								style="cursor: pointer;"
							}
						/>
					}
					if props.Title != "" {
						<h1 class="text-lg font-semibold">{ props.Title }</h1>
					}
				</div>
			}
			
			// Main navigation items
			<nav class="hidden md:flex items-center space-x-1">
				for _, item := range props.Items {
					@topbarNavItem(item, props)
				}
			</nav>
		</div>

		// Right section with user menu
		<div class="flex items-center gap-4">
			// User menu
			if props.UserName != "" || len(props.UserMenu) > 0 {
				<div class="relative" x-data="{ open: false }">
					<button
						class="flex items-center gap-2 px-3 py-2 rounded-md hover:bg-accent"
						x-on:click="open = !open"
					>
						if props.UserAvatar != "" {
							<img src={ props.UserAvatar } alt="User" class="w-8 h-8 rounded-full"/>
						} else {
							@atoms.Icon(atoms.IconProps{Name: "user", Size: atoms.IconSizeSM})
						}
						if props.UserName != "" {
							<span class="hidden md:block">{ props.UserName }</span>
						}
						@atoms.Icon(atoms.IconProps{Name: "chevron-down", Size: atoms.IconSizeXS})
					</button>
					
					<div
						class="absolute right-0 top-full mt-1 w-48 rounded-md border bg-popover p-1 shadow-md z-50"
						x-show="open"
						x-on:click.away="open = false"
						x-transition
					>
						for _, menuItem := range props.UserMenu {
							@molecules.MenuItem(molecules.MenuItemProps{
								Type:        molecules.MenuItemLink,
								Text:        menuItem.Text,
								Description: menuItem.Description,
								URL:         menuItem.URL,
								Icon:        menuItem.Icon,
								IconLeft:    menuItem.Icon,
								Active:      menuItem.Active,
								Disabled:    menuItem.Disabled,
								HXGet:       menuItem.HXGet,
								HXPost:      menuItem.HXPost,
								HXTarget:    menuItem.HXTarget,
								HXSwap:      menuItem.HXSwap,
								AlpineClick: menuItem.AlpineClick,
							})
						}
					</div>
				</div>
			}

			// Mobile menu toggle
			<button
				class="md:hidden p-2 hover:bg-accent rounded-sm"
				x-data="{ mobileOpen: false }"
				x-on:click="mobileOpen = !mobileOpen"
			>
				@atoms.Icon(atoms.IconProps{Name: "menu", Size: atoms.IconSizeSM})
			</button>
		</div>
	</header>
}

// topbarNavItem renders a topbar navigation item
templ topbarNavItem(item NavigationItem, props NavigationProps) {
	if item.URL != "" || item.HXGet != "" || item.HXPost != "" {
		<a
			if item.ID != "" {
				id={ item.ID }
			}
			if item.URL != "" {
				href={ item.URL }
			}
			if item.External {
				target="_blank"
				rel="noopener noreferrer"
			}
			class={ getTopbarItemClasses(item) }
			if item.HXGet != "" {
				hx-get={ item.HXGet }
			}
			if item.HXPost != "" {
				hx-post={ item.HXPost }
			}
			if item.HXTarget != "" {
				hx-target={ item.HXTarget }
			}
			if item.HXSwap != "" {
				hx-swap={ item.HXSwap }
			}
		>
			@topbarItemContent(item)
		</a>
	} else {
		<button
			if item.ID != "" {
				id={ item.ID }
			}
			class={ getTopbarItemClasses(item) }
			if item.AlpineClick != "" {
				x-on:click={ item.AlpineClick }
			}
			if item.Disabled {
				disabled
			}
		>
			@topbarItemContent(item)
		</button>
	}
}

// topbarItemContent renders the content of a topbar item
templ topbarItemContent(item NavigationItem) {
	<div class="flex items-center gap-2">
		if item.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name: item.Icon,
				Size: atoms.IconSizeSM,
			})
		}
		<span>{ item.Text }</span>
		if item.Badge != "" {
			@atoms.Badge(atoms.BadgeProps{
				Variant: getNavItemBadgeVariant(item.BadgeVariant),
				Size:    atoms.BadgeSizeSM,
			}) {
				{ item.Badge }
			}
		}
	</div>
}

// breadcrumbNavigation renders breadcrumb navigation
templ breadcrumbNavigation(props NavigationProps) {
	<nav
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		aria-label="Breadcrumb"
	>
		<ol class="flex items-center space-x-1">
			for i, item := range props.Items {
				<li class="flex items-center">
					if i > 0 {
						<span class="mx-2 text-muted-foreground">
							if props.Separator != "" {
								{ props.Separator }
							} else {
								@atoms.Icon(atoms.IconProps{Name: "chevron-right", Size: atoms.IconSizeXS})
							}
						</span>
					}
					
					if i == len(props.Items)-1 {
						// Last item (current page)
						<span class="font-medium text-foreground">{ item.Text }</span>
					} else if item.URL != "" {
						// Linked item
						<a
							href={ item.URL }
							class="text-muted-foreground hover:text-foreground transition-colors"
							if item.HXGet != "" {
								hx-get={ item.HXGet }
							}
							if item.HXTarget != "" {
								hx-target={ item.HXTarget }
							}
						>
							{ item.Text }
						</a>
					} else {
						// Non-linked item
						<span class="text-muted-foreground">{ item.Text }</span>
					}
				</li>
			}
		</ol>
	</nav>
}

// tabsNavigation renders tab navigation
templ tabsNavigation(props NavigationProps) {
	<nav
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		role="tablist"
	>
		for _, item := range props.Items {
			@tabNavItem(item, props)
		}
	</nav>
}

// tabNavItem renders a tab navigation item
templ tabNavItem(item NavigationItem, props NavigationProps) {
	if item.URL != "" || item.HXGet != "" || item.HXPost != "" {
		<a
			if item.ID != "" {
				id={ item.ID }
			}
			if item.URL != "" {
				href={ item.URL }
			}
			class={ getTabItemClasses(item, props.Variant) }
			role="tab"
			if item.HXGet != "" {
				hx-get={ item.HXGet }
			}
			if item.HXPost != "" {
				hx-post={ item.HXPost }
			}
			if item.HXTarget != "" {
				hx-target={ item.HXTarget }
			}
			if item.HXSwap != "" {
				hx-swap={ item.HXSwap }
			}
		>
			@tabItemContent(item)
		</a>
	} else {
		<button
			if item.ID != "" {
				id={ item.ID }
			}
			class={ getTabItemClasses(item, props.Variant) }
			role="tab"
			if item.AlpineClick != "" {
				x-on:click={ item.AlpineClick }
			}
			if item.Disabled {
				disabled
			}
		>
			@tabItemContent(item)
		</button>
	}
}

// tabItemContent renders the content of a tab item
templ tabItemContent(item NavigationItem) {
	<div class="flex items-center gap-2">
		if item.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name: item.Icon,
				Size: atoms.IconSizeSM,
			})
		}
		<span>{ item.Text }</span>
		if item.Badge != "" {
			@atoms.Badge(atoms.BadgeProps{
				Variant: getNavItemBadgeVariant(item.BadgeVariant),
				Size:    atoms.BadgeSizeSM,
			}) {
				{ item.Badge }
			}
		}
	</div>
}

// stepsNavigation renders step navigation
templ stepsNavigation(props NavigationProps) {
	<nav
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		aria-label="Steps"
	>
		for i, item := range props.Items {
			@stepNavItem(item, i+1, props.CurrentStep, i < len(props.Items)-1)
		}
	</nav>
}

// stepNavItem renders a step navigation item
templ stepNavItem(item NavigationItem, stepNumber int, currentStep int, hasNext bool) {
	<div class="flex items-center">
		<div class="flex items-center">
			// Step circle
			<div class={ getStepCircleClasses(stepNumber, currentStep) }>
				if stepNumber < currentStep {
					@atoms.Icon(atoms.IconProps{Name: "check", Size: atoms.IconSizeXS, Class: "text-white"})
				} else {
					<span class="text-sm font-medium">{ strconv.Itoa(stepNumber) }</span>
				}
			</div>
			
			// Step text
			<div class="ml-3">
				<div class={ getStepTextClasses(stepNumber, currentStep) }>
					{ item.Text }
				</div>
				if item.Description != "" {
					<div class="text-xs text-muted-foreground">{ item.Description }</div>
				}
			</div>
		</div>
		
		// Connector line
		if hasNext {
			<div class={ getStepConnectorClasses(stepNumber, currentStep) }></div>
		}
	</div>
}

// Helper functions for ternary operators
func getNavigationAlpineData(collapsed bool) string {
	if collapsed {
		return "{ collapsed: true }"
	}
	return "{ collapsed: false }"
}

func getNavItemOpenState(collapsed bool) string {
	if collapsed {
		return "{ open: false }"
	}
	return "{ open: true }"
}

func getNavItemBadgeVariant(variant atoms.BadgeVariant) atoms.BadgeVariant {
	if variant != "" {
		return variant
	}
	return atoms.BadgeSecondary
}

func getSubItemClasses(depth int) string {
	if depth == 0 {
		return "mt-1 space-y-1 ml-6"
	}
	return "mt-1 space-y-1 ml-4"
}

// Helper functions for class generation

func getSidebarItemClasses(item NavigationItem, depth int, collapsible bool) string {
	classes := []string{
		"flex", "items-center", "w-full", "px-3", "py-2", "text-left", "rounded-md",
		"text-sm", "transition-colors", "focus:outline-none", "focus:ring-2", "focus:ring-ring",
	}
	
	if item.Active {
		classes = append(classes, "bg-accent", "text-accent-foreground")
	} else if item.Disabled {
		classes = append(classes, "text-muted-foreground", "cursor-not-allowed")
	} else {
		classes = append(classes, "hover:bg-accent", "hover:text-accent-foreground")
	}
	
	if depth > 0 {
		classes = append(classes, "text-xs")
	}
	
	if item.Class != "" {
		classes = append(classes, item.Class)
	}
	
	return strings.Join(classes, " ")
}

func getTopbarItemClasses(item NavigationItem) string {
	classes := []string{
		"px-3", "py-2", "rounded-md", "text-sm", "font-medium", "transition-colors",
		"focus:outline-none", "focus:ring-2", "focus:ring-ring",
	}
	
	if item.Active {
		classes = append(classes, "bg-accent", "text-accent-foreground")
	} else if item.Disabled {
		classes = append(classes, "text-muted-foreground", "cursor-not-allowed")
	} else {
		classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:bg-accent")
	}
	
	return strings.Join(classes, " ")
}

func getTabItemClasses(item NavigationItem, variant string) string {
	classes := []string{
		"px-4", "py-2", "text-sm", "font-medium", "transition-colors",
		"focus:outline-none", "focus:ring-2", "focus:ring-ring",
	}
	
	switch variant {
	case "pills":
		classes = append(classes, "rounded-md")
		if item.Active {
			classes = append(classes, "bg-accent", "text-accent-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:bg-accent")
		}
	case "underline":
		classes = append(classes, "border-b-2", "border-transparent")
		if item.Active {
			classes = append(classes, "border-primary", "text-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:border-muted-foreground")
		}
	default:
		classes = append(classes, "border-b", "border-transparent")
		if item.Active {
			classes = append(classes, "border-primary", "text-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground")
		}
	}
	
	if item.Disabled {
		classes = append(classes, "opacity-50", "cursor-not-allowed", "hover:text-muted-foreground", "hover:border-transparent", "hover:bg-transparent")
	}
	
	return strings.Join(classes, " ")
}

func getStepCircleClasses(stepNumber int, currentStep int) string {
	classes := []string{
		"flex", "items-center", "justify-center", "w-8", "h-8", "rounded-full",
		"text-sm", "font-medium", "transition-colors",
	}
	
	if stepNumber < currentStep {
		classes = append(classes, "bg-primary", "text-primary-foreground")
	} else if stepNumber == currentStep {
		classes = append(classes, "bg-primary", "text-primary-foreground")
	} else {
		classes = append(classes, "bg-muted", "text-muted-foreground")
	}
	
	return strings.Join(classes, " ")
}

func getStepTextClasses(stepNumber int, currentStep int) string {
	classes := []string{"text-sm", "font-medium"}
	
	if stepNumber <= currentStep {
		classes = append(classes, "text-foreground")
	} else {
		classes = append(classes, "text-muted-foreground")
	}
	
	return strings.Join(classes, " ")
}

func getStepConnectorClasses(stepNumber int, currentStep int) string {
	classes := []string{"flex-1", "h-px", "mx-4", "transition-colors"}
	
	if stepNumber < currentStep {
		classes = append(classes, "bg-primary")
	} else {
		classes = append(classes, "bg-muted")
	}
	
	return strings.Join(classes, " ")
}

// Enhanced helper functions for new navigation features

func getDefaultNavigationAlpineData(props NavigationProps) string {
	baseData := `{
		sidebarCollapsed: false,
		mobileMenuOpen: false,
		userMenuOpen: false,
		searchOpen: false,
		searchQuery: '',
		searchResults: [],
		searchLoading: false,
		collapsedItems: {},
		activePath: window.location.pathname,
		preferences: {
			sidebarCollapsed: false,
			theme: 'auto',
			recentMenuItems: []
		},
		notifications: [],
		unreadCount: 0
	}`
	
	if props.AuthContext != nil {
		return fmt.Sprintf("navigationWithAuth(%s)", baseData)
	}
	
	return fmt.Sprintf("navigationBase(%s)", baseData)
}

func getEnhancedSidebarItemClasses(item NavigationItem, depth int, collapsible bool) string {
	classes := []string{
		"flex", "items-center", "w-full", "px-3", "py-2", "text-left", "rounded-md",
		"text-sm", "transition-all", "duration-200", "focus:outline-none", "focus:ring-2", 
		"focus:ring-ring", "focus:ring-offset-2", "group",
	}
	
	// State classes
	if item.Active {
		classes = append(classes, "bg-accent", "text-accent-foreground", "font-medium")
	} else if item.Disabled {
		classes = append(classes, "text-muted-foreground", "cursor-not-allowed", "opacity-50")
	} else {
		classes = append(classes, "hover:bg-accent", "hover:text-accent-foreground")
	}
	
	// Depth classes
	if depth > 0 {
		classes = append(classes, fmt.Sprintf("ml-%d", depth*4), "text-xs")
	}
	
	// Custom classes
	if item.Class != "" {
		classes = append(classes, item.Class)
	}
	
	return utils.TwMerge(classes...)
}

func getEnhancedSubItemClasses(depth int) string {
	classes := []string{"mt-1", "space-y-1"}
	
	if depth == 0 {
		classes = append(classes, "ml-6")
	} else {
		classes = append(classes, "ml-4")
	}
	
	return strings.Join(classes, " ")
}

func getEnhancedTopbarItemClasses(item NavigationItem) string {
	classes := []string{
		"px-3", "py-2", "rounded-md", "text-sm", "font-medium", "transition-colors",
		"focus:outline-none", "focus:ring-2", "focus:ring-ring", "focus:ring-offset-2",
	}
	
	if item.Active {
		classes = append(classes, "bg-accent", "text-accent-foreground")
	} else if item.Disabled {
		classes = append(classes, "text-muted-foreground", "cursor-not-allowed", "opacity-50")
	} else {
		classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:bg-accent")
	}
	
	return utils.TwMerge(classes...)
}

func getEnhancedTabItemClasses(item NavigationItem, variant string) string {
	classes := []string{
		"px-4", "py-2", "text-sm", "font-medium", "transition-all", "duration-200",
		"focus:outline-none", "focus:ring-2", "focus:ring-ring", "focus:ring-offset-2",
	}
	
	switch variant {
	case "pills":
		classes = append(classes, "rounded-md")
		if item.Active {
			classes = append(classes, "bg-accent", "text-accent-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:bg-accent")
		}
	case "underline":
		classes = append(classes, "border-b-2", "border-transparent", "pb-3")
		if item.Active {
			classes = append(classes, "border-primary", "text-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:border-muted-foreground")
		}
	default:
		classes = append(classes, "border-b-2", "border-transparent")
		if item.Active {
			classes = append(classes, "border-primary", "text-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground")
		}
	}
	
	if item.Disabled {
		classes = append(classes, "opacity-50", "cursor-not-allowed", "hover:text-muted-foreground", "hover:border-transparent", "hover:bg-transparent")
	}
	
	return utils.TwMerge(classes...)
}

func getEnhancedStepCircleClasses(stepNumber int, currentStep int) string {
	classes := []string{
		"flex", "items-center", "justify-center", "w-10", "h-10", "rounded-full",
		"text-sm", "font-medium", "transition-all", "duration-200", "border-2",
	}
	
	if stepNumber < currentStep {
		classes = append(classes, "bg-primary", "border-primary", "text-primary-foreground")
	} else if stepNumber == currentStep {
		classes = append(classes, "bg-primary", "border-primary", "text-primary-foreground", "ring-4", "ring-primary/20")
	} else {
		classes = append(classes, "bg-muted", "border-muted", "text-muted-foreground")
	}
	
	return strings.Join(classes, " ")
}

func getEnhancedStepTextClasses(stepNumber int, currentStep int) string {
	classes := []string{"text-sm", "font-medium", "transition-colors"}
	
	if stepNumber <= currentStep {
		classes = append(classes, "text-foreground")
	} else {
		classes = append(classes, "text-muted-foreground")
	}
	
	return strings.Join(classes, " ")
}

func getEnhancedStepConnectorClasses(stepNumber int, currentStep int) string {
	classes := []string{"flex-1", "h-0.5", "mx-4", "transition-colors", "duration-200"}
	
	if stepNumber < currentStep {
		classes = append(classes, "bg-primary")
	} else {
		classes = append(classes, "bg-muted")
	}
	
	return strings.Join(classes, " ")
}

func getEnhancedNavItemBadgeVariant(variant atoms.BadgeVariant) atoms.BadgeVariant {
	if variant != "" {
		return variant
	}
	return atoms.BadgeSecondary
}

func getNavItemAlpineData(item NavigationItem) string {
	collapsed := "false"
	if item.Collapsed {
		collapsed = "true"
	}
	
	return fmt.Sprintf("{ collapsed: %s, toggleMenuItem() { this.collapsed = !this.collapsed; } }", collapsed)
}

func getSearchPlaceholder(placeholder string) string {
	if placeholder != "" {
		return placeholder
	}
	return "Search navigation..."
}

func getUserDisplayName(props NavigationProps) string {
	if props.UserName != "" {
		return props.UserName
	}
	if props.AuthContext != nil && props.AuthContext.User != nil {
		if props.AuthContext.User.DisplayName != "" {
			return props.AuthContext.User.DisplayName
		}
		if props.AuthContext.User.Username != "" {
			return props.AuthContext.User.Username
		}
		if props.AuthContext.User.Email != "" {
			return props.AuthContext.User.Email
		}
	}
	return "User"
}

func hasUnreadNotifications(notifications []Notification) bool {
	for _, n := range notifications {
		if !n.Read {
			return true
		}
	}
	return false
}

func getUnreadNotificationCount(notifications []Notification) int {
	count := 0
	for _, n := range notifications {
		if !n.Read {
			count++
		}
	}
	return count
}

func getNotificationClasses(notification Notification) string {
	classes := []string{
		"flex", "items-start", "gap-3", "p-4", "hover:bg-accent", "transition-colors",
		"cursor-pointer", "border-b", "border-border", "last:border-0",
	}
	
	if !notification.Read {
		classes = append(classes, "bg-accent/50")
	}
	
	return strings.Join(classes, " ")
}

func getNotificationIconClasses(notificationType string) string {
	classes := []string{"shrink-0", "w-8", "h-8", "rounded-full", "flex", "items-center", "justify-center"}
	
	switch notificationType {
	case "success":
		classes = append(classes, "bg-success/20", "text-success")
	case "warning":
		classes = append(classes, "bg-warning/20", "text-warning")
	case "error":
		classes = append(classes, "bg-destructive/20", "text-destructive")
	default:
		classes = append(classes, "bg-primary/20", "text-primary")
	}
	
	return strings.Join(classes, " ")
}

func getNotificationIcon(notification Notification) string {
	if notification.Icon != "" {
		return notification.Icon
	}
	
	switch notification.Type {
	case "success":
		return "check-circle"
	case "warning":
		return "alert-triangle"
	case "error":
		return "alert-circle"
	default:
		return "bell"
	}
}

func formatNotificationTime(createdAt any) string {
	// This would format the time appropriately
	// For now, return a placeholder
	return "2 minutes ago"
}

func getMobileMenuClasses(position string) string {
	classes := []string{
		"fixed", "bg-background", "border", "border-border", "z-40", "flex", "flex-col",
		"shadow-lg", "max-w-sm", "w-full", "h-full",
	}
	
	switch position {
	case "right":
		classes = append(classes, "right-0", "top-0")
	case "top":
		classes = append(classes, "top-0", "left-0", "right-0", "h-auto", "max-h-screen")
	case "bottom":
		classes = append(classes, "bottom-0", "left-0", "right-0", "h-auto", "max-h-screen")
	default: // left
		classes = append(classes, "left-0", "top-0")
	}
	
	return strings.Join(classes, " ")
}

func getMobileMenuEnterStart(position string) string {
	switch position {
	case "right":
		return "opacity-0 transform translate-x-full"
	case "top":
		return "opacity-0 transform -translate-y-full"
	case "bottom":
		return "opacity-0 transform translate-y-full"
	default: // left
		return "opacity-0 transform -translate-x-full"
	}
}