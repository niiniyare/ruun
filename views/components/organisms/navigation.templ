package organisms

import (
	"strings"
	"strconv"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
)

// NavigationType defines the type of navigation
type NavigationType string

const (
	NavigationSidebar    NavigationType = "sidebar"
	NavigationTopbar     NavigationType = "topbar"
	NavigationBreadcrumb NavigationType = "breadcrumb"
	NavigationTabs       NavigationType = "tabs"
	NavigationSteps      NavigationType = "steps"
)

// NavigationSize defines the size variants
type NavigationSize string

const (
	NavigationSizeSM NavigationSize = "sm"
	NavigationSizeMD NavigationSize = "md"
	NavigationSizeLG NavigationSize = "lg"
)

// NavigationItem represents a navigation item
type NavigationItem struct {
	ID          string
	Text        string
	Description string
	URL         string
	Icon        string
	Badge       string
	BadgeVariant atoms.BadgeVariant
	Active      bool
	Disabled    bool
	External    bool  // Opens in new tab
	Divider     bool  // Render as divider
	Class       string
	// Nested items
	Items       []NavigationItem
	Collapsible bool
	Collapsed   bool
	// HTMX attributes
	HXGet       string
	HXPost      string
	HXTarget    string
	HXSwap      string
	// Alpine.js attributes
	AlpineClick string
	// Events
	OnClick     string
}

// NavigationProps defines the properties for Navigation components
type NavigationProps struct {
	Type        NavigationType
	Size        NavigationSize
	Items       []NavigationItem
	Title       string
	Logo        string
	LogoURL     string
	Collapsible bool
	Collapsed   bool
	Class       string
	ID          string
	// Sidebar specific
	Width       string // CSS width value
	Position    string // "left", "right"
	// Topbar specific
	UserMenu    []NavigationItem
	UserName    string
	UserAvatar  string
	// Breadcrumb specific
	Separator   string // Custom separator
	// Tabs specific
	Variant     string // "default", "pills", "underline"
	// Steps specific
	CurrentStep int
	// HTMX attributes
	HXGet       string
	HXTarget    string
	HXSwap      string
	// Alpine.js attributes
	AlpineData  string
	// Events
	OnItemClick string
	OnToggle    string
}

// navigationClasses generates classes for navigation containers
func navigationClasses(props NavigationProps) string {
	var classes []string

	switch props.Type {
	case NavigationSidebar:
		classes = append(classes, "flex", "flex-col", "bg-background", "border-r", "border-border")
		if props.Width != "" {
			// Width handled via inline style
		} else {
			classes = append(classes, "w-64")
		}
	case NavigationTopbar:
		classes = append(classes, "flex", "items-center", "justify-between", "bg-background", "border-b", "border-border", "px-4", "h-16")
	case NavigationBreadcrumb:
		classes = append(classes, "flex", "items-center", "space-x-1", "text-sm", "text-muted-foreground")
	case NavigationTabs:
		classes = append(classes, "flex", "border-b", "border-border")
	case NavigationSteps:
		classes = append(classes, "flex", "items-center", "justify-between")
	}

	// Size classes
	switch props.Size {
	case NavigationSizeSM:
		if props.Type == NavigationTopbar {
			classes = append(classes, "h-12", "px-3")
		}
	case NavigationSizeLG:
		if props.Type == NavigationTopbar {
			classes = append(classes, "h-20", "px-6")
		}
	}

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return strings.Join(classes, " ")
}

// Navigation renders different types of navigation components
templ Navigation(props NavigationProps) {
	switch props.Type {
	case NavigationSidebar:
		@sidebarNavigation(props)
	case NavigationTopbar:
		@topbarNavigation(props)
	case NavigationBreadcrumb:
		@breadcrumbNavigation(props)
	case NavigationTabs:
		@tabsNavigation(props)
	case NavigationSteps:
		@stepsNavigation(props)
	default:
		@sidebarNavigation(props)
	}
}

// sidebarNavigation renders a sidebar navigation
templ sidebarNavigation(props NavigationProps) {
	<aside
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		if props.Width != "" {
			style={ "width: " + props.Width }
		}
		if props.AlpineData != "" {
			x-data={ props.AlpineData }
		} else if props.Collapsible {
			x-data={ getNavigationAlpineData(props.Collapsed) }
		}
	>
		// Sidebar header
		<div class="flex items-center justify-between p-4 border-b border-border">
			<div class="flex items-center gap-3">
				if props.Logo != "" {
					<img 
						src={ props.Logo } 
						alt="Logo" 
						class="h-8 w-8"
						if props.LogoURL != "" {
							x-on:click={ "window.location.href='" + props.LogoURL + "'" }
							style="cursor: pointer;"
						}
					/>
				}
				if props.Title != "" {
					<h1 
						class="text-lg font-semibold"
						if props.Collapsible {
							x-show="!collapsed"
						}
					>{ props.Title }</h1>
				}
			</div>
			
			if props.Collapsible {
				<button
					class="p-1 hover:bg-accent rounded-sm"
					x-on:click="collapsed = !collapsed"
				>
					@atoms.Icon(atoms.IconProps{
						Name: "menu",
						Size: atoms.IconSizeSM,
						Class: "text-muted-foreground",
					})
				</button>
			}
		</div>

		// Navigation items
		<nav class="flex-1 overflow-auto p-2">
			<ul class="space-y-1">
				for _, item := range props.Items {
					@sidebarNavItem(item, props, 0)
				}
			</ul>
		</nav>
	</aside>
}

// sidebarNavItem renders a sidebar navigation item
templ sidebarNavItem(item NavigationItem, props NavigationProps, depth int) {
	<li>
		if item.Divider {
			<div class="h-px bg-border my-2 mx-2"></div>
		} else {
			<div class="relative">
				if item.URL != "" || item.HXGet != "" || item.HXPost != "" {
					// Link item
					<a
						if item.ID != "" {
							id={ item.ID }
						}
						if item.URL != "" {
							href={ item.URL }
						}
						if item.External {
							target="_blank"
							rel="noopener noreferrer"
						}
						class={ getSidebarItemClasses(item, depth, props.Collapsible) }
						if item.HXGet != "" {
							hx-get={ item.HXGet }
						}
						if item.HXPost != "" {
							hx-post={ item.HXPost }
						}
						if item.HXTarget != "" {
							hx-target={ item.HXTarget }
						}
						if item.HXSwap != "" {
							hx-swap={ item.HXSwap }
						}
						if item.AlpineClick != "" {
							x-on:click={ item.AlpineClick }
						}
					>
						@sidebarItemContent(item, props.Collapsible)
					</a>
				} else {
					// Button item or parent item
					<button
						if item.ID != "" {
							id={ item.ID }
						}
						class={ getSidebarItemClasses(item, depth, props.Collapsible) }
						if len(item.Items) > 0 && item.Collapsible {
							x-data={ getNavItemAlpineData(item.Collapsed) }
							x-on:click="open = !open"
						}
						if item.AlpineClick != "" {
							x-on:click={ item.AlpineClick }
						}
						if item.Disabled {
							disabled
						}
					>
						@sidebarItemContent(item, props.Collapsible)
						if len(item.Items) > 0 && item.Collapsible {
							@atoms.Icon(atoms.IconProps{
								Name: "chevron-down",
								Size: atoms.IconSizeXS,
								Class: "ml-auto transition-transform duration-200 x-bind:class=\"{'rotate-180': !open}\"",
							})
						}
					</button>
				}

				// Nested items
				if len(item.Items) > 0 {
					<ul
						class={ getSubItemClasses(depth) }
						if item.Collapsible {
							x-show="open"
							x-transition
						}
					>
						for _, subItem := range item.Items {
							@sidebarNavItem(subItem, props, depth+1)
						}
					</ul>
				}
			</div>
		}
	</li>
}

// sidebarItemContent renders the content of a sidebar item
templ sidebarItemContent(item NavigationItem, collapsible bool) {
	<div class="flex items-center gap-3">
		if item.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name:  item.Icon,
				Size:  atoms.IconSizeSM,
				Class: "shrink-0",
			})
		}
		
		<div 
			class="flex-1 min-w-0"
			if collapsible {
				x-show="!collapsed"
			}
		>
			<div class="font-medium">{ item.Text }</div>
			if item.Description != "" {
				<div class="text-xs text-muted-foreground">{ item.Description }</div>
			}
		</div>
		
		if item.Badge != "" {
			<span 
				if collapsible {
					x-show="!collapsed"
				}
			>
				@atoms.Badge(atoms.BadgeProps{
					Variant: getNavItemBadgeVariant(item.BadgeVariant),
					Size:    atoms.BadgeSizeSM,
				}) {
					{ item.Badge }
				}
			</span>
		}
	</div>
}

// topbarNavigation renders a top navigation bar
templ topbarNavigation(props NavigationProps) {
	<header
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
	>
		// Left section with logo and main nav
		<div class="flex items-center gap-6">
			if props.Logo != "" || props.Title != "" {
				<div class="flex items-center gap-3">
					if props.Logo != "" {
						<img 
							src={ props.Logo } 
							alt="Logo" 
							class="h-8 w-8"
							if props.LogoURL != "" {
								x-on:click={ "window.location.href='" + props.LogoURL + "'" }
								style="cursor: pointer;"
							}
						/>
					}
					if props.Title != "" {
						<h1 class="text-lg font-semibold">{ props.Title }</h1>
					}
				</div>
			}
			
			// Main navigation items
			<nav class="hidden md:flex items-center space-x-1">
				for _, item := range props.Items {
					@topbarNavItem(item, props)
				}
			</nav>
		</div>

		// Right section with user menu
		<div class="flex items-center gap-4">
			// User menu
			if props.UserName != "" || len(props.UserMenu) > 0 {
				<div class="relative" x-data="{ open: false }">
					<button
						class="flex items-center gap-2 px-3 py-2 rounded-md hover:bg-accent"
						x-on:click="open = !open"
					>
						if props.UserAvatar != "" {
							<img src={ props.UserAvatar } alt="User" class="w-8 h-8 rounded-full"/>
						} else {
							@atoms.Icon(atoms.IconProps{Name: "user", Size: atoms.IconSizeSM})
						}
						if props.UserName != "" {
							<span class="hidden md:block">{ props.UserName }</span>
						}
						@atoms.Icon(atoms.IconProps{Name: "chevron-down", Size: atoms.IconSizeXS})
					</button>
					
					<div
						class="absolute right-0 top-full mt-1 w-48 rounded-md border bg-popover p-1 shadow-md z-50"
						x-show="open"
						x-on:click.away="open = false"
						x-transition
					>
						for _, menuItem := range props.UserMenu {
							@molecules.MenuItem(molecules.MenuItemProps{
								Type:        molecules.MenuItemLink,
								Text:        menuItem.Text,
								Description: menuItem.Description,
								URL:         menuItem.URL,
								Icon:        menuItem.Icon,
								IconLeft:    menuItem.Icon,
								Active:      menuItem.Active,
								Disabled:    menuItem.Disabled,
								HXGet:       menuItem.HXGet,
								HXPost:      menuItem.HXPost,
								HXTarget:    menuItem.HXTarget,
								HXSwap:      menuItem.HXSwap,
								AlpineClick: menuItem.AlpineClick,
							})
						}
					</div>
				</div>
			}

			// Mobile menu toggle
			<button
				class="md:hidden p-2 hover:bg-accent rounded-sm"
				x-data="{ mobileOpen: false }"
				x-on:click="mobileOpen = !mobileOpen"
			>
				@atoms.Icon(atoms.IconProps{Name: "menu", Size: atoms.IconSizeSM})
			</button>
		</div>
	</header>
}

// topbarNavItem renders a topbar navigation item
templ topbarNavItem(item NavigationItem, props NavigationProps) {
	if item.URL != "" || item.HXGet != "" || item.HXPost != "" {
		<a
			if item.ID != "" {
				id={ item.ID }
			}
			if item.URL != "" {
				href={ item.URL }
			}
			if item.External {
				target="_blank"
				rel="noopener noreferrer"
			}
			class={ getTopbarItemClasses(item) }
			if item.HXGet != "" {
				hx-get={ item.HXGet }
			}
			if item.HXPost != "" {
				hx-post={ item.HXPost }
			}
			if item.HXTarget != "" {
				hx-target={ item.HXTarget }
			}
			if item.HXSwap != "" {
				hx-swap={ item.HXSwap }
			}
		>
			@topbarItemContent(item)
		</a>
	} else {
		<button
			if item.ID != "" {
				id={ item.ID }
			}
			class={ getTopbarItemClasses(item) }
			if item.AlpineClick != "" {
				x-on:click={ item.AlpineClick }
			}
			if item.Disabled {
				disabled
			}
		>
			@topbarItemContent(item)
		</button>
	}
}

// topbarItemContent renders the content of a topbar item
templ topbarItemContent(item NavigationItem) {
	<div class="flex items-center gap-2">
		if item.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name: item.Icon,
				Size: atoms.IconSizeSM,
			})
		}
		<span>{ item.Text }</span>
		if item.Badge != "" {
			@atoms.Badge(atoms.BadgeProps{
				Variant: getNavItemBadgeVariant(item.BadgeVariant),
				Size:    atoms.BadgeSizeSM,
			}) {
				{ item.Badge }
			}
		}
	</div>
}

// breadcrumbNavigation renders breadcrumb navigation
templ breadcrumbNavigation(props NavigationProps) {
	<nav
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		aria-label="Breadcrumb"
	>
		<ol class="flex items-center space-x-1">
			for i, item := range props.Items {
				<li class="flex items-center">
					if i > 0 {
						<span class="mx-2 text-muted-foreground">
							if props.Separator != "" {
								{ props.Separator }
							} else {
								@atoms.Icon(atoms.IconProps{Name: "chevron-right", Size: atoms.IconSizeXS})
							}
						</span>
					}
					
					if i == len(props.Items)-1 {
						// Last item (current page)
						<span class="font-medium text-foreground">{ item.Text }</span>
					} else if item.URL != "" {
						// Linked item
						<a
							href={ item.URL }
							class="text-muted-foreground hover:text-foreground transition-colors"
							if item.HXGet != "" {
								hx-get={ item.HXGet }
							}
							if item.HXTarget != "" {
								hx-target={ item.HXTarget }
							}
						>
							{ item.Text }
						</a>
					} else {
						// Non-linked item
						<span class="text-muted-foreground">{ item.Text }</span>
					}
				</li>
			}
		</ol>
	</nav>
}

// tabsNavigation renders tab navigation
templ tabsNavigation(props NavigationProps) {
	<nav
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		role="tablist"
	>
		for _, item := range props.Items {
			@tabNavItem(item, props)
		}
	</nav>
}

// tabNavItem renders a tab navigation item
templ tabNavItem(item NavigationItem, props NavigationProps) {
	if item.URL != "" || item.HXGet != "" || item.HXPost != "" {
		<a
			if item.ID != "" {
				id={ item.ID }
			}
			if item.URL != "" {
				href={ item.URL }
			}
			class={ getTabItemClasses(item, props.Variant) }
			role="tab"
			if item.HXGet != "" {
				hx-get={ item.HXGet }
			}
			if item.HXPost != "" {
				hx-post={ item.HXPost }
			}
			if item.HXTarget != "" {
				hx-target={ item.HXTarget }
			}
			if item.HXSwap != "" {
				hx-swap={ item.HXSwap }
			}
		>
			@tabItemContent(item)
		</a>
	} else {
		<button
			if item.ID != "" {
				id={ item.ID }
			}
			class={ getTabItemClasses(item, props.Variant) }
			role="tab"
			if item.AlpineClick != "" {
				x-on:click={ item.AlpineClick }
			}
			if item.Disabled {
				disabled
			}
		>
			@tabItemContent(item)
		</button>
	}
}

// tabItemContent renders the content of a tab item
templ tabItemContent(item NavigationItem) {
	<div class="flex items-center gap-2">
		if item.Icon != "" {
			@atoms.Icon(atoms.IconProps{
				Name: item.Icon,
				Size: atoms.IconSizeSM,
			})
		}
		<span>{ item.Text }</span>
		if item.Badge != "" {
			@atoms.Badge(atoms.BadgeProps{
				Variant: getNavItemBadgeVariant(item.BadgeVariant),
				Size:    atoms.BadgeSizeSM,
			}) {
				{ item.Badge }
			}
		}
	</div>
}

// stepsNavigation renders step navigation
templ stepsNavigation(props NavigationProps) {
	<nav
		if props.ID != "" {
			id={ props.ID }
		}
		class={ navigationClasses(props) }
		aria-label="Steps"
	>
		for i, item := range props.Items {
			@stepNavItem(item, i+1, props.CurrentStep, i < len(props.Items)-1)
		}
	</nav>
}

// stepNavItem renders a step navigation item
templ stepNavItem(item NavigationItem, stepNumber int, currentStep int, hasNext bool) {
	<div class="flex items-center">
		<div class="flex items-center">
			// Step circle
			<div class={ getStepCircleClasses(stepNumber, currentStep) }>
				if stepNumber < currentStep {
					@atoms.Icon(atoms.IconProps{Name: "check", Size: atoms.IconSizeXS, Class: "text-white"})
				} else {
					<span class="text-sm font-medium">{ strconv.Itoa(stepNumber) }</span>
				}
			</div>
			
			// Step text
			<div class="ml-3">
				<div class={ getStepTextClasses(stepNumber, currentStep) }>
					{ item.Text }
				</div>
				if item.Description != "" {
					<div class="text-xs text-muted-foreground">{ item.Description }</div>
				}
			</div>
		</div>
		
		// Connector line
		if hasNext {
			<div class={ getStepConnectorClasses(stepNumber, currentStep) }></div>
		}
	</div>
}

// Helper functions for ternary operators
func getNavigationAlpineData(collapsed bool) string {
	if collapsed {
		return "{ collapsed: true }"
	}
	return "{ collapsed: false }"
}

func getNavItemAlpineData(collapsed bool) string {
	if collapsed {
		return "{ open: false }"
	}
	return "{ open: true }"
}

func getNavItemBadgeVariant(variant atoms.BadgeVariant) atoms.BadgeVariant {
	if variant != "" {
		return variant
	}
	return atoms.BadgeSecondary
}

func getSubItemClasses(depth int) string {
	if depth == 0 {
		return "mt-1 space-y-1 ml-6"
	}
	return "mt-1 space-y-1 ml-4"
}

// Helper functions for class generation

func getSidebarItemClasses(item NavigationItem, depth int, collapsible bool) string {
	classes := []string{
		"flex", "items-center", "w-full", "px-3", "py-2", "text-left", "rounded-md",
		"text-sm", "transition-colors", "focus:outline-none", "focus:ring-2", "focus:ring-ring",
	}
	
	if item.Active {
		classes = append(classes, "bg-accent", "text-accent-foreground")
	} else if item.Disabled {
		classes = append(classes, "text-muted-foreground", "cursor-not-allowed")
	} else {
		classes = append(classes, "hover:bg-accent", "hover:text-accent-foreground")
	}
	
	if depth > 0 {
		classes = append(classes, "text-xs")
	}
	
	if item.Class != "" {
		classes = append(classes, item.Class)
	}
	
	return strings.Join(classes, " ")
}

func getTopbarItemClasses(item NavigationItem) string {
	classes := []string{
		"px-3", "py-2", "rounded-md", "text-sm", "font-medium", "transition-colors",
		"focus:outline-none", "focus:ring-2", "focus:ring-ring",
	}
	
	if item.Active {
		classes = append(classes, "bg-accent", "text-accent-foreground")
	} else if item.Disabled {
		classes = append(classes, "text-muted-foreground", "cursor-not-allowed")
	} else {
		classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:bg-accent")
	}
	
	return strings.Join(classes, " ")
}

func getTabItemClasses(item NavigationItem, variant string) string {
	classes := []string{
		"px-4", "py-2", "text-sm", "font-medium", "transition-colors",
		"focus:outline-none", "focus:ring-2", "focus:ring-ring",
	}
	
	switch variant {
	case "pills":
		classes = append(classes, "rounded-md")
		if item.Active {
			classes = append(classes, "bg-accent", "text-accent-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:bg-accent")
		}
	case "underline":
		classes = append(classes, "border-b-2", "border-transparent")
		if item.Active {
			classes = append(classes, "border-primary", "text-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground", "hover:border-muted-foreground")
		}
	default:
		classes = append(classes, "border-b", "border-transparent")
		if item.Active {
			classes = append(classes, "border-primary", "text-foreground")
		} else {
			classes = append(classes, "text-muted-foreground", "hover:text-foreground")
		}
	}
	
	if item.Disabled {
		classes = append(classes, "opacity-50", "cursor-not-allowed", "hover:text-muted-foreground", "hover:border-transparent", "hover:bg-transparent")
	}
	
	return strings.Join(classes, " ")
}

func getStepCircleClasses(stepNumber int, currentStep int) string {
	classes := []string{
		"flex", "items-center", "justify-center", "w-8", "h-8", "rounded-full",
		"text-sm", "font-medium", "transition-colors",
	}
	
	if stepNumber < currentStep {
		classes = append(classes, "bg-primary", "text-primary-foreground")
	} else if stepNumber == currentStep {
		classes = append(classes, "bg-primary", "text-primary-foreground")
	} else {
		classes = append(classes, "bg-muted", "text-muted-foreground")
	}
	
	return strings.Join(classes, " ")
}

func getStepTextClasses(stepNumber int, currentStep int) string {
	classes := []string{"text-sm", "font-medium"}
	
	if stepNumber <= currentStep {
		classes = append(classes, "text-foreground")
	} else {
		classes = append(classes, "text-muted-foreground")
	}
	
	return strings.Join(classes, " ")
}

func getStepConnectorClasses(stepNumber int, currentStep int) string {
	classes := []string{"flex-1", "h-px", "mx-4", "transition-colors"}
	
	if stepNumber < currentStep {
		classes = append(classes, "bg-primary")
	} else {
		classes = append(classes, "bg-muted")
	}
	
	return strings.Join(classes, " ")
}