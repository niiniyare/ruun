// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.943
package organisms

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import (
	"encoding/json"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
	"strconv"
	"strings"
)

// SchemaField represents a field from the ERP schema system
type SchemaField struct {
	Name        string `json:"name"`
	Type        string `json:"type"`
	Label       string `json:"label"`
	Description string `json:"description"`
	Placeholder string `json:"placeholder"`
	Required    bool   `json:"required"`
	ReadOnly    bool   `json:"readOnly"`
	Hidden      bool   `json:"hidden"`
	Default     any    `json:"default"`
	// Validation
	MinLength int    `json:"minLength"`
	MaxLength int    `json:"maxLength"`
	Min       any    `json:"min"`
	Max       any    `json:"max"`
	Pattern   string `json:"pattern"`
	// Options for select/radio fields
	Options []SchemaFieldOption `json:"options"`
	// Relationships
	Reference string `json:"reference"` // For foreign key fields
	Multiple  bool   `json:"multiple"`  // For multi-select fields
	// UI hints
	Widget     string `json:"widget"`     // UI widget to use
	Group      string `json:"group"`      // Form section/group
	Order      int    `json:"order"`      // Field order
	ColumnSpan int    `json:"columnSpan"` // Grid column span
	// i18n
	I18n map[string]SchemaFieldI18n `json:"i18n"`
	// Conditional logic
	Conditions []SchemaFieldCondition `json:"conditions"`
	// Custom attributes
	Attributes map[string]any `json:"attributes"`
}

// SchemaFieldOption represents an option for select fields
type SchemaFieldOption struct {
	Value       string `json:"value"`
	Label       string `json:"label"`
	Description string `json:"description"`
	Icon        string `json:"icon"`
	Disabled    bool   `json:"disabled"`
	Group       string `json:"group"`
}

// SchemaFieldI18n represents internationalization for a field
type SchemaFieldI18n struct {
	Label       string   `json:"label"`
	Description string   `json:"description"`
	Placeholder string   `json:"placeholder"`
	Options     []string `json:"options"`
}

// SchemaFieldCondition represents conditional field logic
type SchemaFieldCondition struct {
	Field    string `json:"field"`    // Field name to watch
	Operator string `json:"operator"` // eq, ne, gt, lt, in, etc.
	Value    any    `json:"value"`    // Value to compare
	Action   string `json:"action"`   // show, hide, require, disable
}

// SchemaFormSection represents a form section
type SchemaFormSection struct {
	Name        string        `json:"name"`
	Title       string        `json:"title"`
	Description string        `json:"description"`
	Fields      []SchemaField `json:"fields"`
	Collapsible bool          `json:"collapsible"`
	Collapsed   bool          `json:"collapsed"`
	Order       int           `json:"order"`
}

// SchemaFormDefinition represents the complete form schema
type SchemaFormDefinition struct {
	Name        string              `json:"name"`
	Title       string              `json:"title"`
	Description string              `json:"description"`
	Method      string              `json:"method"`
	Action      string              `json:"action"`
	Sections    []SchemaFormSection `json:"sections"`
	Fields      []SchemaField       `json:"fields"` // Fields not in sections
	Layout      FormLayout          `json:"layout"`
	GridCols    int                 `json:"gridCols"`
	// Validation
	Validation SchemaFormValidation `json:"validation"`
	// Behavior
	AutoSave      bool `json:"autoSave"`
	ResetOnSubmit bool `json:"resetOnSubmit"`
	// i18n
	Locale string `json:"locale"`
	// API endpoints
	SubmitURL   string `json:"submitURL"`
	ValidateURL string `json:"validateURL"`
	LoadURL     string `json:"loadURL"`
	// Custom attributes
	Attributes map[string]any `json:"attributes"`
}

// SchemaFormValidation represents form validation configuration
type SchemaFormValidation struct {
	ClientSide  bool     `json:"clientSide"`
	ServerSide  bool     `json:"serverSide"`
	RealTime    bool     `json:"realTime"`
	OnSubmit    bool     `json:"onSubmit"`
	OnBlur      bool     `json:"onBlur"`
	CustomRules []string `json:"customRules"`
}

// SchemaFormProps defines properties for schema-driven forms
type SchemaFormProps struct {
	Schema   SchemaFormDefinition `json:"schema"`
	Data     map[string]any       `json:"data"`     // Pre-filled data
	Errors   map[string]string    `json:"errors"`   // Validation errors
	Locale   string               `json:"locale"`   // Current locale
	ReadOnly bool                 `json:"readOnly"` // Read-only mode
	Debug    bool                 `json:"debug"`    // Debug mode
	Class    string               `json:"class"`
	ID       string               `json:"id"`
	// HTMX configuration
	HXTarget string `json:"hxTarget"`
	HXSwap   string `json:"hxSwap"`
	// Events
	OnSubmit      string `json:"onSubmit"`
	OnValidate    string `json:"onValidate"`
	OnFieldChange string `json:"onFieldChange"`
}

// SchemaForm renders a complete form from schema definition
func SchemaForm(props SchemaFormProps) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		var templ_7745c5c3_Var2 = []any{"schema-form " + props.Class}
		templ_7745c5c3_Err = templ.RenderCSSItems(ctx, templ_7745c5c3_Buffer, templ_7745c5c3_Var2...)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if props.ID != "" {
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, " id=\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			var templ_7745c5c3_Var3 string
			templ_7745c5c3_Var3, templ_7745c5c3_Err = templ.JoinStringErrs(props.ID)
			if templ_7745c5c3_Err != nil {
				return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/organisms/schemaform.templ`, Line: 142, Col: 16}
			}
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var3))
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "\"")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, " class=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var4 string
		templ_7745c5c3_Var4, templ_7745c5c3_Err = templ.JoinStringErrs(templ.CSSClasses(templ_7745c5c3_Var2).String())
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/organisms/schemaform.templ`, Line: 1, Col: 0}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var4))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "\" x-data=\"")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		var templ_7745c5c3_Var5 string
		templ_7745c5c3_Var5, templ_7745c5c3_Err = templ.JoinStringErrs(getSchemaFormAlpineData(props))
		if templ_7745c5c3_Err != nil {
			return templ.Error{Err: templ_7745c5c3_Err, FileName: `views/components/organisms/schemaform.templ`, Line: 145, Col: 41}
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString(templ.EscapeString(templ_7745c5c3_Var5))
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 6, "\" x-init=\"initForm()\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = Form(FormProps{
			Layout:       props.Schema.Layout,
			Size:         FormSizeMD,
			Title:        props.Schema.Title,
			Description:  props.Schema.Description,
			Method:       getSchemaFormMethod(props.Schema.Method),
			Action:       props.Schema.Action,
			Sections:     convertSchemaToFormSections(props.Schema.Sections, props),
			Fields:       convertSchemaToFormFields(props.Schema.Fields, props),
			Actions:      getSchemaFormActions(props),
			GridCols:     getSchemaFormGridCols(props.Schema.GridCols),
			HXPost:       props.Schema.SubmitURL,
			HXTarget:     getSchemaFormTarget(props.HXTarget),
			HXSwap:       getSchemaFormSwap(props.HXSwap),
			HXValidate:   props.Schema.Validation.ClientSide,
			AlpineSubmit: "submitForm()",
			OnSubmit:     props.OnSubmit,
			OnValidate:   props.OnValidate,
		}).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 7, "<div id=\"form-result\" class=\"mt-4\"></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		if props.Debug {
			templ_7745c5c3_Err = schemaFormDebug(props).Render(ctx, templ_7745c5c3_Buffer)
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 8, "</div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// convertSchemaToFormSections converts schema sections to form sections
func convertSchemaToFormSections(schemaSections []SchemaFormSection, props SchemaFormProps) []FormSection {
	sections := make([]FormSection, len(schemaSections))
	for i, section := range schemaSections {
		sections[i] = FormSection{
			Title:       getLocalizedText(section.Title, props.Locale),
			Description: getLocalizedText(section.Description, props.Locale),
			Fields:      convertSchemaToFormFields(section.Fields, props),
			Collapsible: section.Collapsible,
			Collapsed:   section.Collapsed,
		}
	}
	return sections
}

// convertSchemaToFormFields converts schema fields to form fields
func convertSchemaToFormFields(schemaFields []SchemaField, props SchemaFormProps) []molecules.FormFieldProps {
	fields := make([]molecules.FormFieldProps, 0)

	for _, field := range schemaFields {
		if field.Hidden {
			continue
		}

		formField := molecules.FormFieldProps{
			Type:        mapSchemaTypeToFormType(field.Type, field.Widget),
			ID:          field.Name,
			Name:        field.Name,
			Label:       getFieldLabel(field, props.Locale),
			Placeholder: getFieldPlaceholder(field, props.Locale),
			HelpText:    getFieldDescription(field, props.Locale),
			Required:    field.Required,
			Disabled:    props.ReadOnly,
			Readonly:    field.ReadOnly,
			Value:       getFieldValue(field.Name, props.Data),
			ErrorText:   getFieldError(field.Name, props.Errors),
			// Validation
			MinLength: field.MinLength,
			MaxLength: field.MaxLength,
			Min:       convertToString(field.Min),
			Max:       convertToString(field.Max),
			Pattern:   field.Pattern,
			// Options for select fields
			Options:  convertSchemaOptionsToFormOptions(field.Options),
			Multiple: field.Multiple,
			// HTMX for dynamic fields
			HXPost:    getFieldValidationURL(field.Reference, field.Name),
			HXTarget:  "#field-" + field.Name + "-feedback",
			HXTrigger: getFieldTrigger(props.Schema.Validation.RealTime),
			// Alpine.js
			AlpineModel:  "formData." + field.Name,
			AlpineChange: "validateField('" + field.Name + "')",
			AlpineBlur:   getFieldBlurValidation(props.Schema.Validation.OnBlur, field.Name),
		}

		// Handle special field types
		switch field.Type {
		case "array":
			if len(field.Options) > 0 {
				formField.Type = molecules.FormFieldTags
				formField.TagsEditable = false
			} else {
				formField.Type = molecules.FormFieldTags
				formField.TagsEditable = true
			}
		case "object":
			// Handle nested objects - could be expanded to support nested forms
			formField.Type = molecules.FormFieldTextarea
		}

		fields = append(fields, formField)
	}

	return fields
}

// mapSchemaTypeToFormType maps schema field types to form field types
func mapSchemaTypeToFormType(schemaType string, widget string) molecules.FormFieldType {
	// Widget override
	if widget != "" {
		switch widget {
		case "textarea":
			return molecules.FormFieldTextarea
		case "password":
			return molecules.FormFieldPassword
		case "email":
			return molecules.FormFieldEmail
		case "search":
			return molecules.FormFieldSearch
		case "select":
			return molecules.FormFieldSelect
		case "tags":
			return molecules.FormFieldTags
		}
	}

	// Default mapping
	switch schemaType {
	case "string":
		return molecules.FormFieldText
	case "number", "integer":
		return molecules.FormFieldNumber
	case "boolean":
		return molecules.FormFieldSelect
	case "date":
		return molecules.FormFieldText // Could be enhanced with date picker
	case "email":
		return molecules.FormFieldEmail
	case "password":
		return molecules.FormFieldPassword
	case "text", "longtext":
		return molecules.FormFieldTextarea
	case "array":
		return molecules.FormFieldTags
	case "reference":
		return molecules.FormFieldSelect
	default:
		return molecules.FormFieldText
	}
}

// getSchemaFormActions generates form actions
func getSchemaFormActions(props SchemaFormProps) []FormAction {
	actions := []FormAction{
		{
			Text:        "Cancel",
			Type:        "button",
			Variant:     atoms.ButtonOutline,
			AlpineClick: "cancelForm()",
		},
		{
			Text:    "Save",
			Type:    "submit",
			Variant: atoms.ButtonPrimary,
			Loading: false, // Will be bound to Alpine.js state
		},
	}

	if props.Schema.AutoSave {
		actions = append(actions, FormAction{
			Text:        "Auto-save",
			Type:        "button",
			Variant:     atoms.ButtonGhost,
			Icon:        "save",
			AlpineClick: "autoSave()",
		})
	}

	return actions
}

// convertSchemaOptionsToFormOptions converts schema options to form options
func convertSchemaOptionsToFormOptions(options []SchemaFieldOption) []molecules.SelectOption {
	formOptions := make([]molecules.SelectOption, len(options))
	for i, option := range options {
		formOptions[i] = molecules.SelectOption{
			Value:    option.Value,
			Label:    option.Label,
			Disabled: option.Disabled,
		}
	}
	return formOptions
}

// getSchemaFormAlpineData generates Alpine.js data for schema forms
func getSchemaFormAlpineData(props SchemaFormProps) string {
	// Convert data to JSON for Alpine.js
	dataJson, _ := json.Marshal(props.Data)
	errorsJson, _ := json.Marshal(props.Errors)

	return `{
		formData: ` + string(dataJson) + `,
		errors: ` + string(errorsJson) + `,
		loading: false,
		saving: false,
		autoSaving: false,
		dirty: false,
		valid: true,
		
		initForm() {
			// Initialize form
			this.validateAllFields();
			this.setupAutoSave();
			this.setupConditionalLogic();
		},
		
		validateField(fieldName) {
			// Client-side validation
			const field = this.getFieldSchema(fieldName);
			const value = this.formData[fieldName];
			const errors = [];
			
			// Required validation
			if (field.required && (!value || value.toString().trim() === '')) {
				errors.push('This field is required');
			}
			
			// Length validation
			if (value && field.minLength && value.length < field.minLength) {
				errors.push('Minimum length is ' + field.minLength);
			}
			if (value && field.maxLength && value.length > field.maxLength) {
				errors.push('Maximum length is ' + field.maxLength);
			}
			
			// Pattern validation
			if (value && field.pattern) {
				const regex = new RegExp(field.pattern);
				if (!regex.test(value)) {
					errors.push('Invalid format');
				}
			}
			
			// Update errors
			if (errors.length > 0) {
				this.errors[fieldName] = errors[0];
			} else {
				delete this.errors[fieldName];
			}
			
			this.dirty = true;
			this.valid = Object.keys(this.errors).length === 0;
			
			` + props.OnFieldChange + `
		},
		
		validateAllFields() {
			// Validate all fields
			Object.keys(this.formData).forEach(fieldName => {
				this.validateField(fieldName);
			});
		},
		
		submitForm() {
			this.loading = true;
			this.saving = true;
			
			// Final validation
			this.validateAllFields();
			
			if (!this.valid) {
				this.loading = false;
				this.saving = false;
				return false;
			}
			
			` + props.OnSubmit + `
			
			// Form will be submitted via HTMX
			return true;
		},
		
		cancelForm() {
			// Reset form or navigate away
			this.formData = ` + string(dataJson) + `;
			this.errors = {};
			this.dirty = false;
		},
		
		autoSave() {
			if (!this.dirty || !this.valid) return;
			
			this.autoSaving = true;
			
			// Send auto-save request
			htmx.ajax('POST', '` + props.Schema.Action + `/auto-save', {
				values: this.formData,
				target: '#auto-save-status'
			}).then(() => {
				this.autoSaving = false;
				this.dirty = false;
			});
		},
		
		setupAutoSave() {
			if (!` + strconv.FormatBool(props.Schema.AutoSave) + `) return;
			
			// Auto-save every 30 seconds if dirty
			setInterval(() => {
				if (this.dirty && this.valid) {
					this.autoSave();
				}
			}, 30000);
		},
		
		setupConditionalLogic() {
			// Watch for field changes to handle conditional logic
			this.$watch('formData', (newData, oldData) => {
				this.evaluateConditions(newData, oldData);
			}, { deep: true });
		},
		
		evaluateConditions(newData, oldData) {
			// Evaluate conditional field logic
			// This would be expanded based on the schema conditions
		},
		
		getFieldSchema(fieldName) {
			// Helper to get field schema
			const schema = ` + getSchemaFieldsJSON(props.Schema) + `;
			return schema.find(f => f.name === fieldName) || {};
		},
		
		reset() {
			this.formData = ` + string(dataJson) + `;
			this.errors = {};
			this.dirty = false;
			this.valid = true;
		}
	}`
}

// schemaFormDebug renders debug information
func schemaFormDebug(props SchemaFormProps) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var6 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var6 == nil {
			templ_7745c5c3_Var6 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 9, "<div class=\"mt-8 p-4 bg-muted rounded-lg\" x-data=\"{ showDebug: false }\"><button class=\"flex items-center gap-2 text-sm font-medium\" x-on:click=\"showDebug = !showDebug\">")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = atoms.Icon(atoms.IconProps{Name: "settings", Size: atoms.IconSizeSM}).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 10, "Debug Information")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = atoms.Icon(atoms.IconProps{
			Name:  "chevron-down",
			Size:  atoms.IconSizeXS,
			Class: "transition-transform x-bind:class=\"{'rotate-180': showDebug}\"",
		}).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 11, "</button><div x-show=\"showDebug\" x-transition class=\"mt-4 space-y-4\"><div><h4 class=\"font-medium mb-2\">Form Data:</h4><pre class=\"bg-background p-3 rounded text-xs overflow-auto\" x-text=\"JSON.stringify(formData, null, 2)\"></pre></div><div><h4 class=\"font-medium mb-2\">Validation Errors:</h4><pre class=\"bg-background p-3 rounded text-xs overflow-auto\" x-text=\"JSON.stringify(errors, null, 2)\"></pre></div><div><h4 class=\"font-medium mb-2\">Form State:</h4><div class=\"grid grid-cols-2 gap-2 text-sm\"><div>Valid: <span x-text=\"valid\" class=\"font-mono\"></span></div><div>Dirty: <span x-text=\"dirty\" class=\"font-mono\"></span></div><div>Loading: <span x-text=\"loading\" class=\"font-mono\"></span></div><div>Saving: <span x-text=\"saving\" class=\"font-mono\"></span></div></div></div></div></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// Helper functions for ternary operators
func getSchemaFormMethod(method string) string {
	if method != "" {
		return method
	}
	return "POST"
}

func getSchemaFormGridCols(gridCols int) int {
	if gridCols > 0 {
		return gridCols
	}
	return 2
}

func getSchemaFormTarget(target string) string {
	if target != "" {
		return target
	}
	return "#form-result"
}

func getSchemaFormSwap(swap string) string {
	if swap != "" {
		return swap
	}
	return "innerHTML"
}

func getFieldValidationURL(reference string, fieldName string) string {
	if reference != "" {
		return "/api/fields/" + fieldName + "/validate"
	}
	return ""
}

func getFieldTrigger(realTime bool) string {
	if realTime {
		return "change, keyup delay:300ms"
	}
	return "change"
}

func getFieldBlurValidation(onBlur bool, fieldName string) string {
	if onBlur {
		return "validateField('" + fieldName + "')"
	}
	return ""
}

func getSchemaFormData(data map[string]any) map[string]any {
	if data != nil {
		return data
	}
	return make(map[string]any)
}

// Helper functions

func getLocalizedText(text, locale string) string {
	// This would integrate with the i18n system
	// For now, return the original text
	return text
}

func getFieldLabel(field SchemaField, locale string) string {
	if i18n, exists := field.I18n[locale]; exists && i18n.Label != "" {
		return i18n.Label
	}
	if field.Label != "" {
		return field.Label
	}
	return strings.Title(field.Name)
}

func getFieldPlaceholder(field SchemaField, locale string) string {
	if i18n, exists := field.I18n[locale]; exists && i18n.Placeholder != "" {
		return i18n.Placeholder
	}
	return field.Placeholder
}

func getFieldDescription(field SchemaField, locale string) string {
	if i18n, exists := field.I18n[locale]; exists && i18n.Description != "" {
		return i18n.Description
	}
	return field.Description
}

func getFieldValue(fieldName string, data map[string]any) string {
	if value, exists := data[fieldName]; exists && value != nil {
		return convertToString(value)
	}
	return ""
}

func getFieldError(fieldName string, errors map[string]string) string {
	if error, exists := errors[fieldName]; exists {
		return error
	}
	return ""
}

func convertToString(value any) string {
	if value == nil {
		return ""
	}
	switch v := value.(type) {
	case string:
		return v
	case int:
		return strconv.Itoa(v)
	case int64:
		return strconv.FormatInt(v, 10)
	case float64:
		return strconv.FormatFloat(v, 'f', -1, 64)
	case bool:
		return strconv.FormatBool(v)
	default:
		return ""
	}
}

func getSchemaFieldsJSON(schema SchemaFormDefinition) string {
	allFields := append(schema.Fields, extractFieldsFromSections(schema.Sections)...)
	fieldsJson, _ := json.Marshal(allFields)
	return string(fieldsJson)
}

func extractFieldsFromSections(sections []SchemaFormSection) []SchemaField {
	var fields []SchemaField
	for _, section := range sections {
		fields = append(fields, section.Fields...)
	}
	return fields
}

// Convenience components

// SimpleSchemaForm renders a basic schema form
func SimpleSchemaForm(schema SchemaFormDefinition, data map[string]any) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var7 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var7 == nil {
			templ_7745c5c3_Var7 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = SchemaForm(SchemaFormProps{
			Schema: schema,
			Data:   getSchemaFormData(data),
			Locale: "en",
		}).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// ReadOnlySchemaForm renders a read-only schema form
func ReadOnlySchemaForm(schema SchemaFormDefinition, data map[string]any) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var8 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var8 == nil {
			templ_7745c5c3_Var8 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = SchemaForm(SchemaFormProps{
			Schema:   schema,
			Data:     getSchemaFormData(data),
			Locale:   "en",
			ReadOnly: true,
		}).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

// DebugSchemaForm renders a schema form with debug information
func DebugSchemaForm(schema SchemaFormDefinition, data map[string]any) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var9 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var9 == nil {
			templ_7745c5c3_Var9 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = SchemaForm(SchemaFormProps{
			Schema: schema,
			Data:   getSchemaFormData(data),
			Locale: "en",
			Debug:  true,
		}).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
