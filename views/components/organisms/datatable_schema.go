package organisms

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/niiniyare/ruun/pkg/schema"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
)

// DataTableSchemaBuilder provides schema-driven DataTable configuration
type DataTableSchemaBuilder struct {
	schema       *schema.Schema
	config       *DataTableConfig
	fieldMappings map[string]ColumnMapping
	filters      []SchemaFilter
	actions      []SchemaAction
}

// DataTableConfig holds configuration for schema-driven tables
type DataTableConfig struct {
	// Display options
	Title             string                `json:"title,omitempty"`
	Description       string                `json:"description,omitempty"`
	ShowTitle         bool                  `json:"showTitle"`
	ShowDescription   bool                  `json:"showDescription"`
	
	// Table features
	EnableSelection   bool                  `json:"enableSelection"`
	EnableMultiSelect bool                  `json:"enableMultiSelect"`
	EnableSorting     bool                  `json:"enableSorting"`
	EnableFiltering   bool                  `json:"enableFiltering"`
	EnableSearch      bool                  `json:"enableSearch"`
	EnableExport      bool                  `json:"enableExport"`
	EnablePagination  bool                  `json:"enablePagination"`
	
	// Pagination settings
	DefaultPageSize   int                   `json:"defaultPageSize"`
	PageSizeOptions   []int                 `json:"pageSizeOptions"`
	
	// Search settings
	SearchPlaceholder string                `json:"searchPlaceholder,omitempty"`
	SearchFields      []string              `json:"searchFields,omitempty"`
	
	// Export settings
	ExportFormats     []ExportFormat        `json:"exportFormats"`
	ExportFilename    string                `json:"exportFilename,omitempty"`
	
	// Styling
	Variant           DataTableVariant      `json:"variant"`
	Size              DataTableSize         `json:"size"`
	Density           DataTableDensity      `json:"density"`
	
	// Column configuration
	ColumnDefaults    ColumnDefaults        `json:"columnDefaults"`
	ColumnOverrides   map[string]ColumnOverride `json:"columnOverrides,omitempty"`
	
	// Action configuration
	EnableDefaultActions bool               `json:"enableDefaultActions"`
	ActionPosition       string             `json:"actionPosition"` // left, right, both
	
	// Advanced features
	EnableGrouping       bool               `json:"enableGrouping"`
	EnableAggregation    bool               `json:"enableAggregation"`
	EnableColumnResize   bool               `json:"enableColumnResize"`
	EnableColumnReorder  bool               `json:"enableColumnReorder"`
	
	// Performance
	VirtualScrolling     bool               `json:"virtualScrolling"`
	LazyLoading         bool               `json:"lazyLoading"`
	CacheData           bool               `json:"cacheData"`
	
	// Accessibility
	AriaLabels          map[string]string   `json:"ariaLabels,omitempty"`
	
	// Custom templates
	CustomTemplates     map[string]string   `json:"customTemplates,omitempty"`
	
	// Conditional display
	ShowConditions      []ShowCondition     `json:"showConditions,omitempty"`
}\n\n// ColumnDefaults provides default settings for all columns\ntype ColumnDefaults struct {\n\tVisible      bool   `json:\"visible\"`\n\tSortable     bool   `json:\"sortable\"`\n\tFilterable   bool   `json:\"filterable\"`\n\tSearchable   bool   `json:\"searchable\"`\n\tResizable    bool   `json:\"resizable\"`\n\tAlign        string `json:\"align\"`\n\tWidth        string `json:\"width,omitempty\"`\n\tMinWidth     string `json:\"minWidth,omitempty\"`\n\tMaxWidth     string `json:\"maxWidth,omitempty\"`\n}\n\n// ColumnMapping defines how a schema field maps to a table column\ntype ColumnMapping struct {\n\t// Basic mapping\n\tFieldName    string           `json:\"fieldName\"`\n\tColumnType   ColumnType       `json:\"columnType\"`\n\tDisplayName  string           `json:\"displayName,omitempty\"`\n\t\n\t// Rendering options\n\tRenderer     string           `json:\"renderer,omitempty\"` // custom, badge, link, etc.\n\tTemplate     string           `json:\"template,omitempty\"` // custom template\n\tFormat       string           `json:\"format,omitempty\"`   // date/number format\n\t\n\t// Column properties\n\tVisible      *bool            `json:\"visible,omitempty\"`\n\tSortable     *bool            `json:\"sortable,omitempty\"`\n\tFilterable   *bool            `json:\"filterable,omitempty\"`\n\tSearchable   *bool            `json:\"searchable,omitempty\"`\n\tResizable    *bool            `json:\"resizable,omitempty\"`\n\tClickable    *bool            `json:\"clickable,omitempty\"`\n\t\n\t// Layout\n\tAlign        string           `json:\"align,omitempty\"`\n\tVerticalAlign string          `json:\"verticalAlign,omitempty\"`\n\tWidth        string           `json:\"width,omitempty\"`\n\tMinWidth     string           `json:\"minWidth,omitempty\"`\n\tMaxWidth     string           `json:\"maxWidth,omitempty\"`\n\tFixed        bool             `json:\"fixed\"`\n\t\n\t// Special rendering\n\tBadgeConfig  *BadgeConfig     `json:\"badgeConfig,omitempty\"`\n\tLinkConfig   *LinkConfig      `json:\"linkConfig,omitempty\"`\n\tImageConfig  *ImageConfig     `json:\"imageConfig,omitempty\"`\n\tProgressConfig *ProgressConfig `json:\"progressConfig,omitempty\"`\n\t\n\t// Filtering\n\tFilterType   string           `json:\"filterType,omitempty\"` // text, select, date, number\n\tFilterOptions []FilterOption  `json:\"filterOptions,omitempty\"`\n\t\n\t// Actions\n\tColumnActions []ActionConfig  `json:\"columnActions,omitempty\"`\n\t\n\t// Conditional display\n\tShowCondition string          `json:\"showCondition,omitempty\"`\n\tHideCondition string          `json:\"hideCondition,omitempty\"`\n}\n\n// ColumnOverride provides specific overrides for individual columns\ntype ColumnOverride struct {\n\tMapping      ColumnMapping    `json:\"mapping\"`\n\tOrder        int              `json:\"order\"`      // Display order\n\tGroup        string           `json:\"group,omitempty\"` // Column group\n}\n\n// BadgeConfig configures badge rendering\ntype BadgeConfig struct {\n\tVariantMap   map[string]string `json:\"variantMap\"`   // value -> variant\n\tColorMap     map[string]string `json:\"colorMap,omitempty\"`     // value -> color\n\tIconMap      map[string]string `json:\"iconMap,omitempty\"`      // value -> icon\n\tDefaultVariant string          `json:\"defaultVariant,omitempty\"`\n}\n\n// LinkConfig configures link rendering\ntype LinkConfig struct {\n\tURLField     string           `json:\"urlField\"`     // Field containing URL\n\tTarget       string           `json:\"target\"`       // _blank, _self, etc.\n\tShowIcon     bool             `json:\"showIcon\"`     // Show external link icon\n\tTemplate     string           `json:\"template,omitempty\"` // URL template\n}\n\n// ImageConfig configures image rendering\ntype ImageConfig struct {\n\tAltField     string           `json:\"altField,omitempty\"`     // Field containing alt text\n\tSize         string           `json:\"size\"`         // sm, md, lg\n\tShape        string           `json:\"shape\"`        // square, circle, rounded\n\tLazy         bool             `json:\"lazy\"`         // Lazy loading\n\tPlaceholder  string           `json:\"placeholder,omitempty\"`  // Placeholder image\n}\n\n// ProgressConfig configures progress bar rendering\ntype ProgressConfig struct {\n\tMin          float64          `json:\"min\"`          // Minimum value\n\tMax          float64          `json:\"max\"`          // Maximum value\n\tShowValue    bool             `json:\"showValue\"`    // Show percentage\n\tColorThresholds []ColorThreshold `json:\"colorThresholds,omitempty\"`\n}\n\n// ColorThreshold defines color changes at specific values\ntype ColorThreshold struct {\n\tThreshold    float64          `json:\"threshold\"`\n\tColor        string           `json:\"color\"`\n\tVariant      string           `json:\"variant,omitempty\"`\n}\n\n// FilterOption represents an option in a filter dropdown\ntype FilterOption struct {\n\tLabel        string           `json:\"label\"`\n\tValue        string           `json:\"value\"`\n\tIcon         string           `json:\"icon,omitempty\"`\n\tColor        string           `json:\"color,omitempty\"`\n}\n\n// ActionConfig configures column/row actions\ntype ActionConfig struct {\n\tID           string           `json:\"id\"`\n\tLabel        string           `json:\"label\"`\n\tIcon         string           `json:\"icon,omitempty\"`\n\tVariant      string           `json:\"variant,omitempty\"`\n\tAction       string           `json:\"action\"` // htmx, alpine, javascript\n\tURL          string           `json:\"url,omitempty\"`\n\tConfirm      bool             `json:\"confirm\"`\n\tMessage      string           `json:\"message,omitempty\"`\n\tCondition    string           `json:\"condition,omitempty\"`\n\tPermission   string           `json:\"permission,omitempty\"`\n}\n\n// SchemaFilter represents a filter derived from schema\ntype SchemaFilter struct {\n\tField        schema.Field     `json:\"field\"`\n\tType         FilterType       `json:\"type\"`\n\tOperators    []FilterOperator `json:\"operators\"`\n\tOptions      []FilterOption   `json:\"options,omitempty\"`\n\tDefaultValue any              `json:\"defaultValue,omitempty\"`\n\tQuickFilter  bool             `json:\"quickFilter\"`\n}\n\n// FilterType represents different filter UI types\ntype FilterType string\n\nconst (\n\tFilterTypeText     FilterType = \"text\"\n\tFilterTypeSelect   FilterType = \"select\"\n\tFilterTypeMultiSelect FilterType = \"multiselect\"\n\tFilterTypeDate     FilterType = \"date\"\n\tFilterTypeDateRange FilterType = \"daterange\"\n\tFilterTypeNumber   FilterType = \"number\"\n\tFilterTypeNumberRange FilterType = \"numberrange\"\n\tFilterTypeBoolean  FilterType = \"boolean\"\n)\n\n// SchemaAction represents an action derived from schema\ntype SchemaAction struct {\n\tID           string           `json:\"id\"`\n\tLabel        string           `json:\"label\"`\n\tIcon         string           `json:\"icon,omitempty\"`\n\tType         ActionType       `json:\"type\"` // table, bulk, row\n\tAction       schema.Action    `json:\"action\"`\n\tCondition    string           `json:\"condition,omitempty\"`\n\tPermission   string           `json:\"permission,omitempty\"`\n\tConfirm      bool             `json:\"confirm\"`\n\tDestructive  bool             `json:\"destructive\"`\n}\n\n// ActionType represents different action scopes\ntype ActionType string\n\nconst (\n\tActionTypeTable ActionType = \"table\"\n\tActionTypeBulk  ActionType = \"bulk\"\n\tActionTypeRow   ActionType = \"row\"\n)\n\n// ShowCondition represents a condition for showing/hiding elements\ntype ShowCondition struct {\n\tCondition    string           `json:\"condition\"`    // JavaScript expression\n\tTarget       string           `json:\"target\"`       // element to show/hide\n\tAction       string           `json:\"action\"`       // show, hide, enable, disable\n}\n\n// NewDataTableSchemaBuilder creates a new schema-driven table builder\nfunc NewDataTableSchemaBuilder(tableSchema *schema.Schema) *DataTableSchemaBuilder {\n\treturn &DataTableSchemaBuilder{\n\t\tschema:        tableSchema,\n\t\tconfig:        getDefaultDataTableConfig(),\n\t\tfieldMappings: make(map[string]ColumnMapping),\n\t\tfilters:      []SchemaFilter{},\n\t\tactions:       []SchemaAction{},\n\t}\n}\n\n// getDefaultDataTableConfig returns default configuration\nfunc getDefaultDataTableConfig() *DataTableConfig {\n\treturn &DataTableConfig{\n\t\tShowTitle:         true,\n\t\tShowDescription:   true,\n\t\tEnableSelection:   true,\n\t\tEnableMultiSelect: true,\n\t\tEnableSorting:     true,\n\t\tEnableFiltering:   true,\n\t\tEnableSearch:      true,\n\t\tEnableExport:      true,\n\t\tEnablePagination:  true,\n\t\tDefaultPageSize:   25,\n\t\tPageSizeOptions:   []int{10, 25, 50, 100},\n\t\tSearchPlaceholder: \"Search...\",\n\t\tExportFormats:     []ExportFormat{ExportCSV, ExportExcel, ExportPDF},\n\t\tVariant:           DataTableDefault,\n\t\tSize:              DataTableSizeMD,\n\t\tDensity:           DataTableDensityComfortable,\n\t\tColumnDefaults: ColumnDefaults{\n\t\t\tVisible:    true,\n\t\t\tSortable:   true,\n\t\t\tFilterable: true,\n\t\t\tSearchable: true,\n\t\t\tResizable:  true,\n\t\t\tAlign:      \"left\",\n\t\t},\n\t\tEnableDefaultActions: true,\n\t\tActionPosition:      \"right\",\n\t\tEnableColumnResize:  true,\n\t\tEnableColumnReorder: true,\n\t\tVirtualScrolling:    false,\n\t\tLazyLoading:         false,\n\t\tCacheData:           true,\n\t\tAriaLabels: map[string]string{\n\t\t\t\"table\": \"Data table\",\n\t\t\t\"search\": \"Search table\",\n\t\t\t\"filter\": \"Filter table\",\n\t\t\t\"sort\": \"Sort column\",\n\t\t\t\"select\": \"Select row\",\n\t\t\t\"selectAll\": \"Select all rows\",\n\t\t},\n\t}\n}\n\n// WithConfig applies custom configuration\nfunc (b *DataTableSchemaBuilder) WithConfig(config *DataTableConfig) *DataTableSchemaBuilder {\n\tif config != nil {\n\t\tb.config = config\n\t}\n\treturn b\n}\n\n// WithFieldMapping adds a field mapping\nfunc (b *DataTableSchemaBuilder) WithFieldMapping(fieldName string, mapping ColumnMapping) *DataTableSchemaBuilder {\n\tmapping.FieldName = fieldName\n\tb.fieldMappings[fieldName] = mapping\n\treturn b\n}\n\n// WithColumnOverride adds a column override\nfunc (b *DataTableSchemaBuilder) WithColumnOverride(fieldName string, override ColumnOverride) *DataTableSchemaBuilder {\n\tif b.config.ColumnOverrides == nil {\n\t\tb.config.ColumnOverrides = make(map[string]ColumnOverride)\n\t}\n\tb.config.ColumnOverrides[fieldName] = override\n\treturn b\n}\n\n// WithFilter adds a custom filter\nfunc (b *DataTableSchemaBuilder) WithFilter(filter SchemaFilter) *DataTableSchemaBuilder {\n\tb.filters = append(b.filters, filter)\n\treturn b\n}\n\n// WithAction adds a custom action\nfunc (b *DataTableSchemaBuilder) WithAction(action SchemaAction) *DataTableSchemaBuilder {\n\tb.actions = append(b.actions, action)\n\treturn b\n}\n\n// Build generates the DataTableProps from schema and configuration\nfunc (b *DataTableSchemaBuilder) Build(ctx context.Context) (*DataTableProps, error) {\n\tif b.schema == nil {\n\t\treturn nil, fmt.Errorf(\"schema is required\")\n\t}\n\n\tprops := &DataTableProps{\n\t\tID:          b.schema.ID,\n\t\tVariant:     b.config.Variant,\n\t\tSize:        b.config.Size,\n\t\tDensity:     b.config.Density,\n\t\tSelectable:  b.config.EnableSelection,\n\t\tMultiSelect: b.config.EnableMultiSelect,\n\t\tSortable:    b.config.EnableSorting,\n\t\tFilterable:  b.config.EnableFiltering,\n\t\tResizable:   b.config.EnableColumnResize,\n\t\tReorderable: b.config.EnableColumnReorder,\n\t\tVirtualized: b.config.VirtualScrolling,\n\t\tLazyLoad:    b.config.LazyLoading,\n\t\tCacheData:   b.config.CacheData,\n\t}\n\n\t// Set title and description\n\tif b.config.ShowTitle {\n\t\tprops.Title = getConfigValue(b.config.Title, b.schema.Title)\n\t}\n\tif b.config.ShowDescription {\n\t\tprops.Description = getConfigValue(b.config.Description, b.schema.Description)\n\t}\n\n\t// Build columns from schema fields\n\tcolumns, err := b.buildColumns(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build columns: %w\", err)\n\t}\n\tprops.Columns = columns\n\n\t// Configure search\n\tif b.config.EnableSearch {\n\t\tprops.Search = DataTableSearch{\n\t\t\tEnabled:     true,\n\t\t\tPlaceholder: b.config.SearchPlaceholder,\n\t\t\tColumns:     b.config.SearchFields,\n\t\t\tMinLength:   2,\n\t\t\tDelay:       300,\n\t\t\tHighlight:   true,\n\t\t}\n\t}\n\n\t// Configure pagination\n\tif b.config.EnablePagination {\n\t\tprops.Pagination = DataTablePagination{\n\t\t\tEnabled:         true,\n\t\t\tCurrentPage:     1,\n\t\t\tPageSize:        b.config.DefaultPageSize,\n\t\t\tPageSizeOptions: b.config.PageSizeOptions,\n\t\t\tShowTotal:       true,\n\t\t\tShowPageSize:    true,\n\t\t\tShowQuickJump:   true,\n\t\t}\n\t}\n\n\t// Configure export\n\tif b.config.EnableExport {\n\t\tprops.Export = DataTableExport{\n\t\t\tEnabled:  true,\n\t\t\tFormats:  b.config.ExportFormats,\n\t\t\tFilename: getConfigValue(b.config.ExportFilename, b.schema.ID+\"_export\"),\n\t\t\tAllData:  true,\n\t\t}\n\t}\n\n\t// Build filters\n\tfilters, err := b.buildFilters(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build filters: %w\", err)\n\t}\n\tprops.Filters = filters\n\n\t// Build actions\n\ttableActions, bulkActions, rowActions, err := b.buildActions(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to build actions: %w\", err)\n\t}\n\tprops.Actions = tableActions\n\tprops.BulkActions = bulkActions\n\tprops.RowActions = rowActions\n\n\t// Set ARIA labels\n\tprops.AriaLabel = b.config.AriaLabels[\"table\"]\n\n\treturn props, nil\n}\n\n// buildColumns creates columns from schema fields\nfunc (b *DataTableSchemaBuilder) buildColumns(ctx context.Context) ([]DataTableColumn, error) {\n\tvar columns []DataTableColumn\n\n\t// Get visible fields from schema\n\tvisibleFields := b.schema.GetVisibleFields(ctx, map[string]any{})\n\n\tfor _, field := range visibleFields {\n\t\tcolumn, err := b.buildColumnFromField(field)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to build column for field %s: %w\", field.Name, err)\n\t\t}\n\t\tcolumns = append(columns, column)\n\t}\n\n\t// Apply column overrides and ordering\n\tcolumns = b.applyColumnOverrides(columns)\n\n\treturn columns, nil\n}\n\n// buildColumnFromField creates a column from a schema field\nfunc (b *DataTableSchemaBuilder) buildColumnFromField(field schema.Field) (DataTableColumn, error) {\n\tcolumn := DataTableColumn{\n\t\tKey:         field.Name,\n\t\tTitle:       getFieldDisplayTitle(field),\n\t\tVisible:     !field.Hidden,\n\t\tSortable:    b.getFieldProperty(field.Name, \"sortable\", field.Sortable, b.config.ColumnDefaults.Sortable),\n\t\tSearchable:  b.getFieldProperty(field.Name, \"searchable\", field.Searchable, b.config.ColumnDefaults.Searchable),\n\t\tFilterable:  b.getFieldProperty(field.Name, \"filterable\", true, b.config.ColumnDefaults.Filterable),\n\t\tResizable:   b.getFieldProperty(field.Name, \"resizable\", false, b.config.ColumnDefaults.Resizable),\n\t\tAlign:       b.getFieldAlign(field),\n\t\tSchemaField: &field,\n\t}\n\n\t// Apply field mapping if exists\n\tif mapping, exists := b.fieldMappings[field.Name]; exists {\n\t\tb.applyFieldMapping(&column, mapping)\n\t}\n\n\t// Set column type and configuration based on field type\n\tif err := b.configureColumnByFieldType(&column, field); err != nil {\n\t\treturn column, fmt.Errorf(\"failed to configure column type: %w\", err)\n\t}\n\n\treturn column, nil\n}\n\n// applyFieldMapping applies a field mapping to a column\nfunc (b *DataTableSchemaBuilder) applyFieldMapping(column *DataTableColumn, mapping ColumnMapping) {\n\tif mapping.ColumnType != \"\" {\n\t\tcolumn.Type = mapping.ColumnType\n\t}\n\tif mapping.DisplayName != \"\" {\n\t\tcolumn.Title = mapping.DisplayName\n\t}\n\tif mapping.Visible != nil {\n\t\tcolumn.Visible = *mapping.Visible\n\t}\n\tif mapping.Sortable != nil {\n\t\tcolumn.Sortable = *mapping.Sortable\n\t}\n\tif mapping.Filterable != nil {\n\t\tcolumn.Filterable = *mapping.Filterable\n\t}\n\tif mapping.Searchable != nil {\n\t\tcolumn.Searchable = *mapping.Searchable\n\t}\n\tif mapping.Resizable != nil {\n\t\tcolumn.Resizable = *mapping.Resizable\n\t}\n\tif mapping.Clickable != nil {\n\t\tcolumn.Clickable = *mapping.Clickable\n\t}\n\tif mapping.Align != \"\" {\n\t\tcolumn.Align = mapping.Align\n\t}\n\tif mapping.VerticalAlign != \"\" {\n\t\tcolumn.VerticalAlign = mapping.VerticalAlign\n\t}\n\tif mapping.Width != \"\" {\n\t\tcolumn.Width = mapping.Width\n\t}\n\tif mapping.MinWidth != \"\" {\n\t\tcolumn.MinWidth = mapping.MinWidth\n\t}\n\tif mapping.MaxWidth != \"\" {\n\t\tcolumn.MaxWidth = mapping.MaxWidth\n\t}\n\tif mapping.Fixed {\n\t\tcolumn.Fixed = mapping.Fixed\n\t}\n\tif mapping.Format != \"\" {\n\t\tcolumn.Format = mapping.Format\n\t}\n\n\t// Apply special configurations\n\tif mapping.BadgeConfig != nil {\n\t\tcolumn.BadgeMap = buildBadgeMapFromConfig(*mapping.BadgeConfig)\n\t}\n}\n\n// configureColumnByFieldType sets column type and properties based on schema field type\nfunc (b *DataTableSchemaBuilder) configureColumnByFieldType(column *DataTableColumn, field schema.Field) error {\n\tswitch field.Type {\n\tcase schema.FieldText, schema.FieldTextarea:\n\t\tcolumn.Type = ColumnTypeText\n\t\tcolumn.Align = \"left\"\n\n\tcase schema.FieldNumber:\n\t\tcolumn.Type = ColumnTypeNumber\n\t\tcolumn.Align = \"right\"\n\t\tcolumn.Precision = 2 // Default precision\n\n\tcase schema.FieldEmail:\n\t\tcolumn.Type = ColumnTypeLink\n\t\tcolumn.Align = \"left\"\n\n\tcase schema.FieldURL:\n\t\tcolumn.Type = ColumnTypeLink\n\t\tcolumn.Align = \"left\"\n\n\tcase schema.FieldDate:\n\t\tcolumn.Type = ColumnTypeDate\n\t\tcolumn.Align = \"center\"\n\t\tcolumn.DateFormat = \"2006-01-02\"\n\n\tcase schema.FieldDatetime:\n\t\tcolumn.Type = ColumnTypeDateTime\n\t\tcolumn.Align = \"center\"\n\t\tcolumn.DateFormat = \"2006-01-02 15:04\"\n\n\tcase schema.FieldSelect, schema.FieldRadio:\n\t\tcolumn.Type = ColumnTypeBadge\n\t\tcolumn.Align = \"center\"\n\t\tif len(field.Options) > 0 {\n\t\t\tcolumn.BadgeMap = buildBadgeMapFromSchemaOptions(field.Options)\n\t\t}\n\n\tcase schema.FieldCheckbox:\n\t\tcolumn.Type = ColumnTypeCheckbox\n\t\tcolumn.Align = \"center\"\n\n\tcase schema.FieldFile:\n\t\tif b.isImageField(field) {\n\t\t\tcolumn.Type = ColumnTypeImage\n\t\t\tcolumn.Align = \"center\"\n\t\t} else {\n\t\t\tcolumn.Type = ColumnTypeLink\n\t\t\tcolumn.Align = \"left\"\n\t\t}\n\n\tcase schema.FieldMultiSelect:\n\t\tcolumn.Type = ColumnTypeTags\n\t\tcolumn.Align = \"left\"\n\n\tdefault:\n\t\tcolumn.Type = ColumnTypeText\n\t\tcolumn.Align = \"left\"\n\t}\n\n\treturn nil\n}\n\n// buildFilters creates filters from schema fields\nfunc (b *DataTableSchemaBuilder) buildFilters(ctx context.Context) ([]DataTableFilter, error) {\n\tvar filters []DataTableFilter\n\n\t// Add custom filters\n\tfor _, customFilter := range b.filters {\n\t\tfilter := DataTableFilter{\n\t\t\tKey:    customFilter.Field.Name,\n\t\t\tLabel:  getFieldDisplayTitle(customFilter.Field),\n\t\t\tType:   string(customFilter.Type),\n\t\t\tActive: false,\n\t\t}\n\n\t\tif len(customFilter.Options) > 0 {\n\t\t\tfor _, opt := range customFilter.Options {\n\t\t\t\tfilter.Options = append(filter.Options, molecules.SelectOption{\n\t\t\t\t\tValue: opt.Value,\n\t\t\t\t\tLabel: opt.Label,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\tfilters = append(filters, filter)\n\t}\n\n\t// Auto-generate filters for filterable fields\n\tfor _, field := range b.schema.Fields {\n\t\tif !field.Hidden && b.shouldCreateFilterForField(field) {\n\t\t\tfilter := b.createFilterFromField(field)\n\t\t\tfilters = append(filters, filter)\n\t\t}\n\t}\n\n\treturn filters, nil\n}\n\n// buildActions creates actions from schema actions\nfunc (b *DataTableSchemaBuilder) buildActions(ctx context.Context) ([]DataTableAction, []DataTableBulkAction, []DataTableAction, error) {\n\tvar tableActions []DataTableAction\n\tvar bulkActions []DataTableBulkAction\n\tvar rowActions []DataTableAction\n\n\t// Add default actions if enabled\n\tif b.config.EnableDefaultActions {\n\t\ttableActions = append(tableActions, buildDefaultActions()...)\n\t\tbulkActions = append(bulkActions, buildDefaultBulkActions()...)\n\t\trowActions = append(rowActions, buildDefaultRowActions()...)\n\t}\n\n\t// Add schema-based actions\n\tfor _, action := range b.schema.Actions {\n\t\tswitch b.getActionScope(action) {\n\t\tcase ActionTypeTable:\n\t\t\ttableAction := b.convertToTableAction(action)\n\t\t\ttableActions = append(tableActions, tableAction)\n\n\t\tcase ActionTypeBulk:\n\t\t\tbulkAction := b.convertToBulkAction(action)\n\t\t\tbulkActions = append(bulkActions, bulkAction)\n\n\t\tcase ActionTypeRow:\n\t\t\trowAction := b.convertToRowAction(action)\n\t\t\trowActions = append(rowActions, rowAction)\n\t\t}\n\t}\n\n\treturn tableActions, bulkActions, rowActions, nil\n}\n\n// Helper functions\n\nfunc getConfigValue(configValue, schemaValue string) string {\n\tif configValue != \"\" {\n\t\treturn configValue\n\t}\n\treturn schemaValue\n}\n\nfunc getFieldDisplayTitle(field schema.Field) string {\n\tif field.Label != \"\" {\n\t\treturn field.Label\n\t}\n\treturn strings.Title(strings.ReplaceAll(field.Name, \"_\", \" \"))\n}\n\nfunc (b *DataTableSchemaBuilder) getFieldProperty(fieldName, property string, fieldValue, defaultValue bool) bool {\n\t// Check for field mapping override\n\tif mapping, exists := b.fieldMappings[fieldName]; exists {\n\t\tswitch property {\n\t\tcase \"sortable\":\n\t\t\tif mapping.Sortable != nil {\n\t\t\t\treturn *mapping.Sortable\n\t\t\t}\n\t\tcase \"searchable\":\n\t\t\tif mapping.Searchable != nil {\n\t\t\t\treturn *mapping.Searchable\n\t\t\t}\n\t\tcase \"filterable\":\n\t\t\tif mapping.Filterable != nil {\n\t\t\t\treturn *mapping.Filterable\n\t\t\t}\n\t\tcase \"resizable\":\n\t\t\tif mapping.Resizable != nil {\n\t\t\t\treturn *mapping.Resizable\n\t\t\t}\n\t\t}\n\t}\n\n\t// Use field value if set, otherwise default\n\treturn fieldValue || defaultValue\n}\n\nfunc (b *DataTableSchemaBuilder) getFieldAlign(field schema.Field) string {\n\t// Check for mapping override\n\tif mapping, exists := b.fieldMappings[field.Name]; exists && mapping.Align != \"\" {\n\t\treturn mapping.Align\n\t}\n\n\t// Default alignment based on field type\n\tswitch field.Type {\n\tcase schema.FieldNumber:\n\t\treturn \"right\"\n\tcase schema.FieldDate, schema.FieldDatetime, schema.FieldCheckbox:\n\t\treturn \"center\"\n\tdefault:\n\t\treturn \"left\"\n\t}\n}\n\nfunc (b *DataTableSchemaBuilder) isImageField(field schema.Field) bool {\n\t// Check field name patterns\n\tfieldName := strings.ToLower(field.Name)\n\treturn strings.Contains(fieldName, \"image\") ||\n\t\t   strings.Contains(fieldName, \"photo\") ||\n\t\t   strings.Contains(fieldName, \"avatar\") ||\n\t\t   strings.Contains(fieldName, \"picture\")\n}\n\nfunc (b *DataTableSchemaBuilder) shouldCreateFilterForField(field schema.Field) bool {\n\t// Don't create filters for certain field types\n\tswitch field.Type {\n\tcase schema.FieldPassword, schema.FieldHidden:\n\t\treturn false\n\tcase schema.FieldFile:\n\t\treturn false\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc (b *DataTableSchemaBuilder) createFilterFromField(field schema.Field) DataTableFilter {\n\tfilter := DataTableFilter{\n\t\tKey:    field.Name,\n\t\tLabel:  getFieldDisplayTitle(field),\n\t\tActive: false,\n\t}\n\n\tswitch field.Type {\n\tcase schema.FieldSelect, schema.FieldRadio:\n\t\tfilter.Type = \"select\"\n\t\tfor _, option := range field.Options {\n\t\t\tfilter.Options = append(filter.Options, molecules.SelectOption{\n\t\t\t\tValue: option.Value,\n\t\t\t\tLabel: option.Label,\n\t\t\t})\n\t\t}\n\n\tcase schema.FieldMultiSelect:\n\t\tfilter.Type = \"multiselect\"\n\t\tfor _, option := range field.Options {\n\t\t\tfilter.Options = append(filter.Options, molecules.SelectOption{\n\t\t\t\tValue: option.Value,\n\t\t\t\tLabel: option.Label,\n\t\t\t})\n\t\t}\n\n\tcase schema.FieldDate:\n\t\tfilter.Type = \"date\"\n\n\tcase schema.FieldDatetime:\n\t\tfilter.Type = \"daterange\"\n\n\tcase schema.FieldNumber:\n\t\tfilter.Type = \"numberrange\"\n\n\tcase schema.FieldCheckbox:\n\t\tfilter.Type = \"boolean\"\n\t\tfilter.Options = []molecules.SelectOption{\n\t\t\t{Value: \"true\", Label: \"Yes\"},\n\t\t\t{Value: \"false\", Label: \"No\"},\n\t\t}\n\n\tdefault:\n\t\tfilter.Type = \"text\"\n\t}\n\n\treturn filter\n}\n\nfunc (b *DataTableSchemaBuilder) getActionScope(action schema.Action) ActionType {\n\t// Determine action scope based on action ID or metadata\n\tactionID := strings.ToLower(action.ID)\n\t\n\tif strings.Contains(actionID, \"bulk\") || strings.Contains(actionID, \"delete_selected\") {\n\t\treturn ActionTypeBulk\n\t}\n\t\n\tif strings.Contains(actionID, \"edit\") || strings.Contains(actionID, \"delete\") || strings.Contains(actionID, \"view\") {\n\t\treturn ActionTypeRow\n\t}\n\t\n\treturn ActionTypeTable\n}\n\nfunc (b *DataTableSchemaBuilder) convertToTableAction(action schema.Action) DataTableAction {\n\treturn DataTableAction{\n\t\tID:      action.ID,\n\t\tText:    action.Text,\n\t\tIcon:    action.Icon,\n\t\tVariant: convertActionVariant(action.Style),\n\t\tType:    \"button\",\n\t}\n}\n\nfunc (b *DataTableSchemaBuilder) convertToBulkAction(action schema.Action) DataTableBulkAction {\n\treturn DataTableBulkAction{\n\t\tID:          action.ID,\n\t\tText:        action.Text,\n\t\tIcon:        action.Icon,\n\t\tVariant:     convertActionVariant(action.Style),\n\t\tDestructive: isDestructiveAction(action),\n\t\tConfirm:     action.Confirm,\n\t\tMessage:     action.ConfirmMessage,\n\t}\n}\n\nfunc (b *DataTableSchemaBuilder) convertToRowAction(action schema.Action) DataTableAction {\n\treturn DataTableAction{\n\t\tID:   action.ID,\n\t\tText: action.Text,\n\t\tIcon: action.Icon,\n\t}\n}\n\nfunc convertActionVariant(style string) atoms.ButtonVariant {\n\tswitch strings.ToLower(style) {\n\tcase \"primary\":\n\t\treturn atoms.ButtonPrimary\n\tcase \"secondary\":\n\t\treturn atoms.ButtonSecondary\n\tcase \"destructive\", \"danger\":\n\t\treturn atoms.ButtonDestructive\n\tcase \"outline\":\n\t\treturn atoms.ButtonOutline\n\tcase \"ghost\":\n\t\treturn atoms.ButtonGhost\n\tdefault:\n\t\treturn atoms.ButtonSecondary\n\t}\n}\n\nfunc isDestructiveAction(action schema.Action) bool {\n\tactionID := strings.ToLower(action.ID)\n\treturn strings.Contains(actionID, \"delete\") || strings.Contains(actionID, \"remove\")\n}\n\nfunc buildBadgeMapFromConfig(config BadgeConfig) map[string]atoms.BadgeVariant {\n\tbadgeMap := make(map[string]atoms.BadgeVariant)\n\t\n\tfor value, variant := range config.VariantMap {\n\t\tswitch strings.ToLower(variant) {\n\t\tcase \"primary\":\n\t\t\tbadgeMap[value] = atoms.BadgePrimary\n\t\tcase \"secondary\":\n\t\t\tbadgeMap[value] = atoms.BadgeSecondary\n\t\tcase \"success\":\n\t\t\tbadgeMap[value] = atoms.BadgeSuccess\n\t\tcase \"warning\":\n\t\t\tbadgeMap[value] = atoms.BadgeWarning\n\t\tcase \"destructive\", \"danger\":\n\t\t\tbadgeMap[value] = atoms.BadgeDestructive\n\t\tdefault:\n\t\t\tbadgeMap[value] = atoms.BadgeDefault\n\t\t}\n\t}\n\t\n\treturn badgeMap\n}\n\nfunc buildBadgeMapFromSchemaOptions(options []schema.FieldOption) map[string]atoms.BadgeVariant {\n\tbadgeMap := make(map[string]atoms.BadgeVariant)\n\t\n\tfor i, option := range options {\n\t\tvar variant atoms.BadgeVariant\n\t\t\n\t\t// Assign variants in a cycle\n\t\tswitch i % 5 {\n\t\tcase 0:\n\t\t\tvariant = atoms.BadgePrimary\n\t\tcase 1:\n\t\t\tvariant = atoms.BadgeSecondary\n\t\tcase 2:\n\t\t\tvariant = atoms.BadgeSuccess\n\t\tcase 3:\n\t\t\tvariant = atoms.BadgeWarning\n\t\tcase 4:\n\t\t\tvariant = atoms.BadgeDestructive\n\t\t}\n\t\t\n\t\tbadgeMap[option.Value] = variant\n\t}\n\t\n\treturn badgeMap\n}\n\nfunc (b *DataTableSchemaBuilder) applyColumnOverrides(columns []DataTableColumn) []DataTableColumn {\n\tif b.config.ColumnOverrides == nil {\n\t\treturn columns\n\t}\n\n\t// Apply overrides and reorder\n\ttype columnWithOrder struct {\n\t\tcolumn DataTableColumn\n\t\torder  int\n\t}\n\n\tvar orderedColumns []columnWithOrder\n\n\tfor _, column := range columns {\n\t\torder := 0\n\t\tif override, exists := b.config.ColumnOverrides[column.Key]; exists {\n\t\t\t// Apply mapping from override\n\t\t\tb.applyFieldMapping(&column, override.Mapping)\n\t\t\torder = override.Order\n\t\t}\n\t\torderedColumns = append(orderedColumns, columnWithOrder{column, order})\n\t}\n\n\t// Sort by order\n\tvar result []DataTableColumn\n\tfor _, col := range orderedColumns {\n\t\tresult = append(result, col.column)\n\t}\n\n\treturn result\n}\n\n// JSON serialization helpers\n\n// ToJSON serializes the configuration to JSON\nfunc (config *DataTableConfig) ToJSON() ([]byte, error) {\n\treturn json.MarshalIndent(config, \"\", \"  \")\n}\n\n// FromJSON deserializes configuration from JSON\nfunc (config *DataTableConfig) FromJSON(data []byte) error {\n\treturn json.Unmarshal(data, config)\n}\n\n// ToJSON serializes a column mapping to JSON\nfunc (mapping *ColumnMapping) ToJSON() ([]byte, error) {\n\treturn json.MarshalIndent(mapping, \"\", \"  \")\n}\n\n// FromJSON deserializes a column mapping from JSON\nfunc (mapping *ColumnMapping) FromJSON(data []byte) error {\n\treturn json.Unmarshal(data, mapping)\n}\n"