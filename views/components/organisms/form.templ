package organisms

import (
	"fmt"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
)

// ============================================================================
// PROGRESSIVE ENHANCEMENT - Simple to Enterprise
// ============================================================================

// FormProps - Works for both simple and enterprise forms
// Simple usage: Just ID + Fields
// Enterprise usage: Add Advanced config
type FormProps struct {
	// CORE - Required for all forms
	ID     string  `json:"id"`
	Fields []Field `json:"fields"`

	// BASIC - Optional enhancements
	Title       string     `json:"title,omitempty"`
	Description string     `json:"description,omitempty"`
	Layout      FormLayout `json:"layout,omitempty"`        // Default: vertical
	Size        FormSize   `json:"size,omitempty"`          // Default: md
	ReadOnly    bool       `json:"readOnly,omitempty"`

	// SECTIONING - Group related fields
	Sections []Section `json:"sections,omitempty"`

	// SUBMISSION - Basic form handling
	SubmitURL string `json:"submitURL,omitempty"`
	OnSubmit  string `json:"onSubmit,omitempty"`

	// ACTIONS - Custom buttons (uses atoms.Button)
	Actions []Action `json:"actions,omitempty"`

	// PROGRESSIVE ENHANCEMENT - Nil = disabled
	Advanced    *AdvancedConfig    `json:"advanced,omitempty"`
	Validation  *ValidationConfig  `json:"validation,omitempty"`
	AutoSave    *AutoSaveConfig    `json:"autoSave,omitempty"`
	Storage     *FormStorageConfig     `json:"storage,omitempty"`
	Progress    *FormProgressConfig    `json:"progress,omitempty"`
	Dependencies *DependencyConfig `json:"dependencies,omitempty"`
	Debug       *DebugConfig       `json:"debug,omitempty"`

	// HTMX - Optional server integration
	HTMX *HTMXConfig `json:"htmx,omitempty"`

	// THEMING - Optional customization
	Theme *FormThemeConfig `json:"theme,omitempty"`
}

// Field - Enhanced to support both simple and complex scenarios
type Field struct {
	molecules.FormFieldProps        // Reuse existing molecule

	// PROGRESSIVE ENHANCEMENT
	Conditional  string       `json:"conditional,omitempty"`  // Alpine.js visibility
	Dependencies []Dependency `json:"dependencies,omitempty"` // Field relationships

	// FIELD-LEVEL OVERRIDES
	AutoSave   *FieldAutoSave   `json:"autoSave,omitempty"`
	Validation *FieldValidation `json:"validation,omitempty"`
	Storage    *FieldStorage    `json:"storage,omitempty"`
}

// Section - Reuse existing pattern
type Section struct {
	ID          string     `json:"id,omitempty"`
	Title       string     `json:"title,omitempty"`
	Description string     `json:"description,omitempty"`
	Icon        string     `json:"icon,omitempty"`
	Collapsible bool       `json:"collapsible,omitempty"`
	Collapsed   bool       `json:"collapsed,omitempty"`
	Required    bool       `json:"required,omitempty"`
	Layout      FormLayout `json:"layout,omitempty"`
	Conditional string     `json:"conditional,omitempty"`
	Fields      []Field    `json:"fields"`
}

// Action - Uses atoms.Button for consistency
type Action struct {
	ID       string `json:"id,omitempty"`
	Type     string `json:"type,omitempty"`     // "submit" | "button" | "reset"
	Label    string `json:"label"`
	Position string `json:"position,omitempty"` // "left" | "center" | "right"

	// ATOMS INTEGRATION
	ButtonProps atoms.ButtonProps `json:"buttonProps,omitempty"`

	// BEHAVIOR
	OnClick     string `json:"onClick,omitempty"`
	Conditional string `json:"conditional,omitempty"`

	// HTMX
	HTMX *ActionHTMX `json:"htmx,omitempty"`
}

// ============================================================================
// CONFIGURATION OBJECTS - Optional complexity
// ============================================================================

// AdvancedConfig - Enterprise features
type AdvancedConfig struct {
	EnableSSE          bool `json:"enableSSE,omitempty"`
	EnableCrossTabSync bool `json:"enableCrossTabSync,omitempty"`
	EnableOfflineMode  bool `json:"enableOfflineMode,omitempty"`
	EnableTelemetry    bool `json:"enableTelemetry,omitempty"`
}

// ValidationConfig - Validation options
type ValidationConfig struct {
	Strategy ValidationStrategy `json:"strategy,omitempty"` // Default: onblur
	URL      string             `json:"url,omitempty"`
	SSE      *SSEConfig         `json:"sse,omitempty"`
	Debounce int                `json:"debounce,omitempty"` // ms, default: 300
}

// AutoSaveConfig - Auto-save options
type AutoSaveConfig struct {
	Enabled  bool              `json:"enabled"`
	Strategy AutoSaveStrategy  `json:"strategy,omitempty"` // Default: debounced
	Interval int               `json:"interval,omitempty"` // seconds, default: 30
	URL      string            `json:"url,omitempty"`
	ShowState bool             `json:"showState,omitempty"`
}

// StorageConfig - Client-side persistence
type FormStorageConfig struct {
	Strategy      StorageStrategy `json:"strategy,omitempty"`      // Default: none
	Key           string          `json:"key,omitempty"`
	TTL           int             `json:"ttl,omitempty"`           // seconds
	SyncAcrossTabs bool           `json:"syncAcrossTabs,omitempty"`
	RestoreOnLoad  bool           `json:"restoreOnLoad,omitempty"`
}

// ProgressConfig - Multi-step forms
type FormProgressConfig struct {
	ShowProgress bool `json:"showProgress"`
	CurrentStep  int  `json:"currentStep,omitempty"`
	TotalSteps   int  `json:"totalSteps"`
}

// DependencyConfig - Field relationships
type DependencyConfig struct {
	Graph        map[string][]Dependency `json:"graph,omitempty"`
	DetectCycles bool                    `json:"detectCycles,omitempty"` // Default: true
}

// DebugConfig - Development tools
type DebugConfig struct {
	Enabled     bool `json:"enabled"`
	ShowPanel   bool `json:"showPanel,omitempty"`
	LogToConsole bool `json:"logToConsole,omitempty"`
}

// HTMXConfig - Server integration
type HTMXConfig struct {
	Target    string `json:"target,omitempty"`
	Swap      string `json:"swap,omitempty"`
	Trigger   string `json:"trigger,omitempty"`
	Indicator string `json:"indicator,omitempty"`
}

// ThemeConfig - Styling overrides
type FormThemeConfig struct {
	ID             string            `json:"id,omitempty"`
	DarkMode       bool              `json:"darkMode,omitempty"`
	TokenOverrides map[string]string `json:"tokenOverrides,omitempty"`
}

// ============================================================================
// NESTED TYPES
// ============================================================================

// Dependency - Field relationship definition
type Dependency struct {
	TargetField     string         `json:"targetField"`
	Type            DependencyType `json:"type"`
	Condition       string         `json:"condition,omitempty"`
	OptionsURL      string         `json:"optionsURL,omitempty"`
	ValueExpression string         `json:"valueExpression,omitempty"`
	ValidationRules string         `json:"validationRules,omitempty"`
	ClearOnChange   bool           `json:"clearOnChange,omitempty"`
	Debounce        int            `json:"debounce,omitempty"`
	UseSSE          bool           `json:"useSSE,omitempty"`
}

// Field-level configurations
type FieldAutoSave struct {
	Strategy AutoSaveStrategy `json:"strategy,omitempty"`
	Interval int              `json:"interval,omitempty"`
}

type FieldValidation struct {
	Debounce int    `json:"debounce,omitempty"`
	UseSSE   bool   `json:"useSSE,omitempty"`
	Rules    string `json:"rules,omitempty"`
}

type FieldStorage struct {
	Exclude bool `json:"exclude,omitempty"`
}

type ActionHTMX struct {
	Post    string `json:"post,omitempty"`
	Get     string `json:"get,omitempty"`
	Put     string `json:"put,omitempty"`
	Delete  string `json:"delete,omitempty"`
	Target  string `json:"target,omitempty"`
	Swap    string `json:"swap,omitempty"`
	Confirm string `json:"confirm,omitempty"`
}

type SSEConfig struct {
	URL     string `json:"url,omitempty"`
	Timeout int    `json:"timeout,omitempty"` // seconds
}

// ============================================================================
// ENUMS - Reuse existing + new ones
// ============================================================================

type FormLayout string
const (
	FormLayoutVertical   FormLayout = "vertical"   // Default
	FormLayoutHorizontal FormLayout = "horizontal"
	FormLayoutInline     FormLayout = "inline"
	FormLayoutGrid       FormLayout = "grid"
)

type FormSize string
const (
	FormSizeSM FormSize = "sm"
	FormSizeMD FormSize = "md" // Default
	FormSizeLG FormSize = "lg"
)

type ValidationStrategy string
const (
	ValidationRealtime ValidationStrategy = "realtime"
	ValidationOnBlur   ValidationStrategy = "onblur"   // Default
	ValidationOnChange ValidationStrategy = "onchange"
	ValidationOnSubmit ValidationStrategy = "onsubmit"
)

type AutoSaveStrategy string
const (
	AutoSaveDebounced AutoSaveStrategy = "debounced" // Default
	AutoSaveImmediate AutoSaveStrategy = "immediate"
	AutoSaveInterval  AutoSaveStrategy = "interval"
	AutoSaveManual    AutoSaveStrategy = "manual"
)

type StorageStrategy string
const (
	StorageNone      StorageStrategy = "none"      // Default
	StorageLocal     StorageStrategy = "local"
	StorageSession   StorageStrategy = "session"
	StorageIndexedDB StorageStrategy = "indexeddb"
)

type DependencyType string
const (
	DependencyVisibility DependencyType = "visibility"
	DependencyOptions    DependencyType = "options"
	DependencyValue      DependencyType = "value"
	DependencyRequired   DependencyType = "required"
	DependencyValidation DependencyType = "validation"
)

// ============================================================================
// MAIN COMPONENT - Progressive enhancement
// ============================================================================

// Form - Unified form organism that scales from simple to enterprise
//
// Simple usage:
//   @organisms.Form(organisms.FormProps{
//       ID: "contact",
//       Fields: []organisms.Field{
//           {FormFieldProps: molecules.FormFieldProps{Name: "email", Type: "email"}},
//       },
//   })
//
// Enterprise usage:
//   @organisms.Form(organisms.FormProps{
//       ID: "user-profile",
//       Title: "User Profile",
//       Fields: [...],
//       Advanced: &organisms.AdvancedConfig{EnableSSE: true},
//       Storage: &organisms.StorageConfig{Strategy: organisms.StorageLocal},
//       Dependencies: &organisms.DependencyConfig{...},
//   })
templ Form(props FormProps) {
	@formRender(buildFormState(props))
}

// ============================================================================
// INTERNAL RENDERING
// ============================================================================

templ formRender(state formState) {
	// Initialize Alpine.js store
	@formAlpineStore(mustMarshalJSON(state.config))
	
	<form { buildFormAttributes(state)... }>
		// Header - only if provided
		if state.hasHeader {
			@formHeader(state.props)
		}
		
		// Progress - only if enabled
		if state.hasProgress {
			@formProgress(state.props.Progress)
		}
		
		// Storage indicator - only if storage enabled and restored
		if state.hasStorageRestore {
			@storageRestoreIndicator()
		}
		
		// Content
		<div class="form-content">
			if HasElements(state.props.Sections) {
				for _, section := range state.props.Sections {
					@formSection(section, state)
				}
			} else {
				@formFields(state.props.Fields, state)
			}
		</div>
		
		// Actions - always present (default submit if none provided)
		@formActions(state)
		
		// Auto-save state - only if enabled
		if state.hasAutoSave && state.props.AutoSave.ShowState {
			@autoSaveIndicator()
		}
		
		// Debug panel - only if enabled
		if state.hasDebug {
			@debugPanel(state.props.Debug)
		}
	</form>
}

// Header component using atoms
templ formHeader(props FormProps) {
	<header class="form-header">
		if props.Title != "" {
			<h2 class="form-title">{ props.Title }</h2>
		}
		if props.Description != "" {
			<p class="form-description">{ props.Description }</p>
		}
	</header>
}

// Progress component using atoms
templ formProgress(config *FormProgressConfig) {
	<div class="form-progress" role="region" aria-label="Form progress">
		<div 
			class="form-progress-bar" 
			role="progressbar"
			aria-valuenow={ fmt.Sprintf("%d", config.CurrentStep) }
			aria-valuemin="1"
			aria-valuemax={ fmt.Sprintf("%d", config.TotalSteps) }
		>
			<div 
				class="form-progress-fill" 
				x-bind:style="`width: ${progressPercentage}%`"
			></div>
		</div>
		<small class="form-progress-text">{ fmt.Sprintf("Step %d of %d", config.CurrentStep, config.TotalSteps) }</small>
	</div>
}

// Storage indicator using atoms
templ storageRestoreIndicator() {
	<div class="form-storage-indicator" x-show="restoredFromStorage" x-transition>
		@atoms.Icon(atoms.IconProps{
			Name: "info",
			Size: atoms.IconSizeXS,
			ClassName: "form-storage-icon",
		})
		<small>Form data restored from previous session</small>
		@atoms.Button(atoms.ButtonProps{
			Variant: atoms.ButtonVariantGhost,
			Size:    atoms.ButtonSizeSM,
			Text:    "Clear",
			OnClick: "clearStorage(); restoredFromStorage = false",
		})
	</div>
}

// Section component using atoms for icons
templ formSection(section Section, state formState) {
	<fieldset { buildSectionAttributes(section)... }>
		if section.Title != "" || section.Description != "" {
			<legend class="form-section-header">
				if section.Collapsible {
					@atoms.Button(atoms.ButtonProps{
						Type:      "button",
						Variant:   atoms.ButtonVariantGhost,
						Size:      atoms.ButtonSizeSM,
						ClassName: "form-section-toggle",
						OnClick:   "collapsed = !collapsed",
						AriaLabel: fmt.Sprintf("Toggle %s section", section.Title),
					}) {
						if section.Icon != "" {
							@atoms.Icon(atoms.IconProps{
								Name: section.Icon,
								Size: atoms.IconSizeSM,
								ClassName: "form-section-icon",
							})
						}
						<h3 class="form-section-title">{ section.Title }</h3>
						@atoms.Icon(atoms.IconProps{
							Name: "chevron-down",
							Size: atoms.IconSizeXS,
							ClassName: "form-section-chevron",
						})
					}
				} else {
					<div class="form-section-title-container">
						if section.Icon != "" {
							@atoms.Icon(atoms.IconProps{
								Name: section.Icon,
								Size: atoms.IconSizeSM,
								ClassName: "form-section-icon",
							})
						}
						<h3 class="form-section-title">{ section.Title }</h3>
					</div>
				}
				if section.Description != "" {
					<p class="form-section-description">{ section.Description }</p>
				}
			</legend>
		}
		
		<div 
			class="form-section-content"
			if section.Collapsible {
				x-show="!collapsed"
				x-transition
			}
		>
			@formFields(section.Fields, state)
		</div>
	</fieldset>
}

// Fields container
templ formFields(fields []Field, state formState) {
	<div class={ buildFieldsContainerClasses(state.props) }>
		for _, field := range fields {
			@formField(field, state)
		}
	</div>
}

// Enhanced field with dependency support
templ formField(field Field, state formState) {
	<div { buildFieldContainerAttributes(field, state)... }>
		@molecules.FormField(enhanceFieldProps(field, state))
		
		// Validation feedback using atoms
		<div 
			id={ fmt.Sprintf("%s-%s-feedback", state.id, field.Name) }
			class="form-field-feedback"
			role="alert"
			aria-live="polite"
			x-show={ fmt.Sprintf("errors.%s", field.Name) }
			x-transition
		>
			@atoms.Icon(atoms.IconProps{
				Name: "alert-circle",
				Size: atoms.IconSizeXS,
				ClassName: "form-field-error-icon",
			})
			<small class="form-field-error-message" x-text={ fmt.Sprintf("errors.%s", field.Name) }></small>
		</div>
		
		// Validation loading indicator
		<div class="form-field-validating" x-show={ fmt.Sprintf("validating.%s", field.Name) } x-transition>
			@atoms.Icon(atoms.IconProps{
				Name: "loader",
				Size: atoms.IconSizeXS,
				ClassName: "animate-spin",
			})
		</div>
	</div>
}

// Actions using atoms.Button consistently
templ formActions(state formState) {
	<div class="form-actions-container">
		if HasElements(state.props.Actions) {
			// Custom actions grouped by position
			for _, pos := range []string{"left", "center", "right"} {
				if actions, exists := state.actionGroups[pos]; exists && HasElements(actions) {
					<div class={ buildActionsClasses(pos) }>
						for _, action := range actions {
							@formAction(action, state)
						}
					</div>
				}
			}
		} else {
			// Default submit button using atoms.Button
			<div class={ buildActionsClasses("right") }>
				@atoms.Button(atoms.ButtonProps{
					Type:    "submit",
					Text:    "Submit",
					Variant: atoms.ButtonVariantPrimary,
					Size:    atoms.ButtonSizeMD,
				})
			</div>
		}
	</div>
}

// Individual action using atoms.Button
templ formAction(action Action, state formState) {
	<div 
		class="form-action"
		if action.Conditional != "" {
			x-show={ action.Conditional }
		}
	>
		@atoms.Button(mergeButtonProps(action.ButtonProps, atoms.ButtonProps{
			ID:      action.ID,
			Type:    Coalesce(action.Type, "button"),
			Text:    action.Label,
			Variant: Default(action.ButtonProps.Variant, atoms.ButtonVariantSecondary),
			Size:    Default(action.ButtonProps.Size, atoms.ButtonSizeMD),
			OnClick: action.OnClick,
		}))
	</div>
}

// Auto-save indicator using atoms
templ autoSaveIndicator() {
	<div class="form-save-state" x-show="saving || isDirty || lastSaved" x-transition>
		<div x-show="saving" class="form-save-indicator" x-transition>
			@atoms.Icon(atoms.IconProps{
				Name: "loader",
				Size: atoms.IconSizeXS,
				ClassName: "form-save-spinner animate-spin",
			})
			<small>Saving...</small>
		</div>
		<div x-show="!saving && isDirty" class="form-unsaved-indicator" x-transition>
			@atoms.Icon(atoms.IconProps{
				Name: "alert-circle",
				Size: atoms.IconSizeXS,
				ClassName: "form-unsaved-icon",
			})
			<small>Unsaved changes</small>
		</div>
		<div x-show="!saving && !isDirty && lastSaved" class="form-saved-indicator" x-transition>
			@atoms.Icon(atoms.IconProps{
				Name: "check-circle",
				Size: atoms.IconSizeXS,
				ClassName: "form-saved-icon",
			})
			<small>
				<span x-text="`Saved ${formatLastSaved()}`">Saved</span>
			</small>
		</div>
	</div>
}

// Debug panel using atoms
templ debugPanel(config *DebugConfig) {
	<div class="form-debug-panel" x-show="showDebug" x-transition>
		<div class="form-debug-header">
			<h3>Form Debug</h3>
			@atoms.Button(atoms.ButtonProps{
				Variant: atoms.ButtonVariantGhost,
				Size:    atoms.ButtonSizeSM,
				OnClick: "showDebug = false",
				AriaLabel: "Close debug panel",
			}) {
				@atoms.Icon(atoms.IconProps{
					Name: "x",
					Size: atoms.IconSizeXS,
				})
			}
		</div>
		<div class="form-debug-content">
			<pre x-text="JSON.stringify(dumpState(), null, 2)"></pre>
		</div>
	</div>
}

// ============================================================================
// ALPINE.JS STORE - Scales from simple to complex
// ============================================================================

script formAlpineStore(configJSON string) {
	const cfg = JSON.parse(configJSON);
	
	// Create store function for this form
	window[`formStore_${cfg.formId}`] = function() {
		return {
			// CORE STATE - Always present
			formData: cfg.initialData || {},
			initialData: JSON.parse(JSON.stringify(cfg.initialData || {})),
			errors: {},
			touched: {},
			dirty: {},
			
			// BASIC STATE
			loading: false,
			submitting: false,
			
			// PROGRESSIVE ENHANCEMENT - Only if enabled
			...(cfg.hasValidation && {
				validating: {},
			}),
			
			...(cfg.hasAutoSave && {
				saving: false,
				lastSaved: null,
				autoSaveTimeout: null,
			}),
			
			...(cfg.hasStorage && {
				restoredFromStorage: false,
			}),
			
			...(cfg.hasProgress && {
				currentStep: cfg.currentStep || 1,
				totalSteps: cfg.totalSteps || 1,
			}),
			
			...(cfg.hasDependencies && {
				dependencyTimeouts: {},
				dependencyCache: {},
			}),
			
			...(cfg.hasSSE && {
				sseConnections: {},
				sseStatus: {},
			}),
			
			...(cfg.hasDebug && {
				showDebug: cfg.debug,
				debugTab: 'state',
			}),
			
			// COMPUTED PROPERTIES
			get isDirty() {
				return Object.keys(this.dirty).length > 0;
			},
			
			get hasErrors() {
				return Object.keys(this.errors).length > 0;
			},
			
			get canSubmit() {
				return !this.hasErrors && !this.submitting;
			},
			
			...(cfg.hasProgress && {
				get progressPercentage() {
					return Math.round((this.currentStep / this.totalSteps) * 100);
				},
			}),
			
			// METHODS - Progressive enhancement
			init() {
				// Basic initialization
				if (cfg.hasStorage && cfg.restoreFromStorage) {
					this.restoreFromStorage();
				}
				
				// Advanced features
				if (cfg.hasAdvanced?.enableCrossTabSync) {
					this.setupCrossTabSync();
				}
			},
			
			updateField(name, value) {
				this.formData[name] = value;
				this.touched[name] = true;
				
				const initialValue = this.initialData[name];
				this.dirty[name] = JSON.stringify(value) !== JSON.stringify(initialValue);
				
				if (this.errors[name]) delete this.errors[name];
				
				// Progressive features
				if (cfg.hasValidation && cfg.validationStrategy === 'realtime') {
					this.validateField(name);
				}
				
				if (cfg.hasDependencies) {
					this.handleDependencies(name);
				}
				
				if (cfg.hasAutoSave) {
					this.scheduleAutoSave();
				}
				
				if (cfg.hasStorage) {
					this.saveToStorage();
				}
			},
			
			async submitForm(event) {
				if (event) event.preventDefault();
				if (this.submitting) return;
				
				this.submitting = true;
				
				try {
					// Validate if enabled
					if (cfg.hasValidation) {
						const isValid = await this.validateAllFields();
						if (!isValid) {
							this.$dispatch('form-validation-failed', { errors: this.errors });
							return;
						}
					}
					
					// Submit
					if (cfg.submitURL) {
						const response = await fetch(cfg.submitURL, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify(this.formData),
						});
						
						const result = await response.json();
						
						if (response.ok && result.success) {
							this.resetForm();
							if (cfg.hasStorage) this.clearStorage();
							this.$dispatch('form-submitted', { result });
						} else {
							if (result.errors) this.errors = result.errors;
							this.$dispatch('form-error', { result });
						}
					}
				} catch (error) {
					this.$dispatch('form-error', { error: error.message });
				} finally {
					this.submitting = false;
				}
			},
			
			resetForm() {
				this.formData = JSON.parse(JSON.stringify(this.initialData));
				this.errors = {};
				this.touched = {};
				this.dirty = {};
				
				// Clean up advanced features
				if (cfg.hasValidation) this.validating = {};
				if (cfg.hasSSE) {
					Object.values(this.sseConnections || {}).forEach(es => es.close());
					this.sseConnections = {};
				}
				
				this.$dispatch('form-reset');
			},
			
			// CONDITIONAL METHODS - Only included if features are enabled
			...(cfg.hasValidation && {
				async validateField(name) {
					if (this.validating[name] || !cfg.validationURL) return true;
					
					this.validating[name] = true;
					
					try {
						const response = await fetch(cfg.validationURL, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({
								field: name,
								value: this.formData[name],
								formData: this.formData,
							}),
						});
						
						const result = await response.json();
						
						if (result.valid) {
							delete this.errors[name];
						} else {
							this.errors[name] = result.message || 'Validation failed';
						}
						
						return result.valid;
					} catch (error) {
						this.errors[name] = 'Validation request failed';
						return false;
					} finally {
						this.validating[name] = false;
					}
				},
				
				async validateAllFields() {
					const results = await Promise.all(
						Object.keys(this.formData).map(name => this.validateField(name))
					);
					return results.every(valid => valid === true);
				},
			}),
			
			...(cfg.hasAutoSave && {
				scheduleAutoSave() {
					if (!cfg.autoSave || !this.isDirty) return;
					
					clearTimeout(this.autoSaveTimeout);
					this.autoSaveTimeout = setTimeout(() => {
						this.autoSave();
					}, (cfg.autoSaveInterval || 30) * 1000);
				},
				
				async autoSave() {
					if (!this.isDirty || this.submitting || this.saving) return;
					
					this.saving = true;
					
					try {
						const changes = {};
						Object.keys(this.dirty).forEach(name => {
							if (this.dirty[name]) {
								changes[name] = this.formData[name];
							}
						});
						
						const response = await fetch(cfg.autoSaveURL, {
							method: 'POST',
							headers: { 'Content-Type': 'application/json' },
							body: JSON.stringify({ formId: cfg.formId, changes }),
						});
						
						if (response.ok) {
							this.lastSaved = new Date();
							this.dirty = {};
							this.$dispatch('form-autosaved', { changes });
						}
					} catch (error) {
						console.error('Auto-save error:', error);
					} finally {
						this.saving = false;
					}
				},
				
				formatLastSaved() {
					if (!this.lastSaved) return '';
					const seconds = Math.floor((new Date() - this.lastSaved) / 1000);
					if (seconds < 60) return 'just now';
					if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
					return `${Math.floor(seconds / 3600)}h ago`;
				},
			}),
			
			...(cfg.hasStorage && {
				async saveToStorage() {
					if (cfg.storageStrategy === 'none') return;
					
					const storageData = {
						formData: this.formData,
						dirty: this.dirty,
						touched: this.touched,
						timestamp: Date.now(),
					};
					
					try {
						if (cfg.storageStrategy === 'indexeddb') {
							await this.saveToIndexedDB(storageData);
						} else {
							const storage = cfg.storageStrategy === 'local' ? localStorage : sessionStorage;
							storage.setItem(cfg.storageKey, JSON.stringify(storageData));
						}
					} catch (e) {
						console.error('Storage save error:', e);
					}
				},
				
				async restoreFromStorage() {
					if (cfg.storageStrategy === 'none') return;
					
					try {
						let storageData;
						
						if (cfg.storageStrategy === 'indexeddb') {
							storageData = await this.restoreFromIndexedDB();
						} else {
							const storage = cfg.storageStrategy === 'local' ? localStorage : sessionStorage;
							const saved = storage.getItem(cfg.storageKey);
							if (saved) storageData = JSON.parse(saved);
						}
						
						if (!storageData) return;
						
						// Check TTL
						const age = (Date.now() - storageData.timestamp) / 1000;
						if (age > (cfg.storageTTL || 86400)) {
							this.clearStorage();
							return;
						}
						
						// Restore
						this.formData = { ...this.initialData, ...storageData.formData };
						this.dirty = storageData.dirty || {};
						this.touched = storageData.touched || {};
						this.restoredFromStorage = true;
					} catch (e) {
						console.error('Storage restore error:', e);
					}
				},
				
				async clearStorage() {
					if (cfg.storageStrategy === 'none') return;
					
					try {
						if (cfg.storageStrategy === 'indexeddb') {
							await this.clearIndexedDB();
						} else {
							const storage = cfg.storageStrategy === 'local' ? localStorage : sessionStorage;
							storage.removeItem(cfg.storageKey);
						}
						this.restoredFromStorage = false;
					} catch (e) {
						console.error('Storage clear error:', e);
					}
				},
			}),
			
			...(cfg.hasDependencies && {
				async handleDependencies(sourceName) {
					const dependencies = cfg.dependencyGraph[sourceName] || [];
					
					for (const dep of dependencies) {
						// Check condition if specified
						if (dep.condition) {
							try {
								if (!eval(dep.condition)) continue;
							} catch (e) {
								console.error('Dependency condition error:', e);
								continue;
							}
						}
						
						// Execute dependency
						await this.executeDependency(dep, sourceName);
					}
				},
				
				async executeDependency(dep, sourceName) {
					switch (dep.type) {
						case 'options':
							await this.updateFieldOptions(dep, this.formData[sourceName]);
							break;
						case 'value':
							this.updateFieldValue(dep);
							break;
						case 'required':
							this.updateFieldRequired(dep);
							break;
						case 'validation':
							this.updateFieldValidation(dep);
							break;
					}
				},
				
				async updateFieldOptions(dep, sourceValue) {
					const url = dep.optionsURL.replace('{value}', encodeURIComponent(sourceValue));
					
					try {
						const response = await fetch(url);
						const options = await response.json();
						this.dependencyCache[dep.targetField] = options;
						this.$dispatch('field-options-updated', { field: dep.targetField, options });
					} catch (error) {
						console.error('Error updating field options:', error);
					}
				},
				
				updateFieldValue(dep) {
					try {
						this.formData[dep.targetField] = eval(dep.valueExpression);
					} catch (e) {
						console.error('Value expression error:', e);
					}
				},
				
				updateFieldRequired(dep) {
					// Implementation depends on form field system
				},
				
				updateFieldValidation(dep) {
					try {
						const rules = JSON.parse(dep.validationRules);
						// Apply rules - implementation depends on validation system
					} catch (e) {
						console.error('Validation rules error:', e);
					}
				},
			}),
			
			...(cfg.hasProgress && {
				nextStep() {
					if (this.currentStep < this.totalSteps) {
						this.currentStep++;
						this.$dispatch('step-changed', { step: this.currentStep });
					}
				},
				
				prevStep() {
					if (this.currentStep > 1) {
						this.currentStep--;
						this.$dispatch('step-changed', { step: this.currentStep });
					}
				},
				
				goToStep(step) {
					if (step >= 1 && step <= this.totalSteps) {
						this.currentStep = step;
						this.$dispatch('step-changed', { step });
					}
				},
			}),
			
			...(cfg.hasDebug && {
				toggleDebug() {
					this.showDebug = !this.showDebug;
				},
				
				dumpState() {
					return {
						formData: this.formData,
						initialData: this.initialData,
						errors: this.errors,
						touched: this.touched,
						dirty: this.dirty,
						isDirty: this.isDirty,
						hasErrors: this.hasErrors,
						canSubmit: this.canSubmit,
					};
				},
			}),
		};
	};
}