package organisms

import (
	"strings"
	"strconv"
	"encoding/json"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/views/components/molecules"
)

// SchemaField represents a field from the ERP schema system
type SchemaField struct {
	Name         string                 `json:"name"`
	Type         string                 `json:"type"`
	Label        string                 `json:"label"`
	Description  string                 `json:"description"`
	Placeholder  string                 `json:"placeholder"`
	Required     bool                   `json:"required"`
	ReadOnly     bool                   `json:"readOnly"`
	Hidden       bool                   `json:"hidden"`
	Default      any            `json:"default"`
	// Validation
	MinLength    int                    `json:"minLength"`
	MaxLength    int                    `json:"maxLength"`
	Min          any            `json:"min"`
	Max          any            `json:"max"`
	Pattern      string                 `json:"pattern"`
	// Options for select/radio fields
	Options      []SchemaFieldOption    `json:"options"`
	// Relationships
	Reference    string                 `json:"reference"` // For foreign key fields
	Multiple     bool                   `json:"multiple"`  // For multi-select fields
	// UI hints
	Widget       string                 `json:"widget"`    // UI widget to use
	Group        string                 `json:"group"`     // Form section/group
	Order        int                    `json:"order"`     // Field order
	ColumnSpan   int                    `json:"columnSpan"` // Grid column span
	// i18n
	I18n         map[string]SchemaFieldI18n `json:"i18n"`
	// Conditional logic
	Conditions   []SchemaFieldCondition `json:"conditions"`
	// Custom attributes
	Attributes   map[string]any `json:"attributes"`
}

// SchemaFieldOption represents an option for select fields
type SchemaFieldOption struct {
	Value       string `json:"value"`
	Label       string `json:"label"`
	Description string `json:"description"`
	Icon        string `json:"icon"`
	Disabled    bool   `json:"disabled"`
	Group       string `json:"group"`
}

// SchemaFieldI18n represents internationalization for a field
type SchemaFieldI18n struct {
	Label       string   `json:"label"`
	Description string   `json:"description"`
	Placeholder string   `json:"placeholder"`
	Options     []string `json:"options"`
}

// SchemaFieldCondition represents conditional field logic
type SchemaFieldCondition struct {
	Field    string      `json:"field"`    // Field name to watch
	Operator string      `json:"operator"` // eq, ne, gt, lt, in, etc.
	Value    any `json:"value"`    // Value to compare
	Action   string      `json:"action"`   // show, hide, require, disable
}

// SchemaFormSection represents a form section
type SchemaFormSection struct {
	Name        string        `json:"name"`
	Title       string        `json:"title"`
	Description string        `json:"description"`
	Fields      []SchemaField `json:"fields"`
	Collapsible bool          `json:"collapsible"`
	Collapsed   bool          `json:"collapsed"`
	Order       int           `json:"order"`
}

// SchemaFormDefinition represents the complete form schema
type SchemaFormDefinition struct {
	Name        string               `json:"name"`
	Title       string               `json:"title"`
	Description string               `json:"description"`
	Method      string               `json:"method"`
	Action      string               `json:"action"`
	Sections    []SchemaFormSection  `json:"sections"`
	Fields      []SchemaField        `json:"fields"` // Fields not in sections
	Layout      FormLayout           `json:"layout"`
	GridCols    int                  `json:"gridCols"`
	// Validation
	Validation  SchemaFormValidation `json:"validation"`
	// Behavior
	AutoSave    bool                 `json:"autoSave"`
	ResetOnSubmit bool               `json:"resetOnSubmit"`
	// i18n
	Locale      string               `json:"locale"`
	// API endpoints
	SubmitURL   string               `json:"submitURL"`
	ValidateURL string               `json:"validateURL"`
	LoadURL     string               `json:"loadURL"`
	// Custom attributes
	Attributes  map[string]any `json:"attributes"`
}

// SchemaFormValidation represents form validation configuration
type SchemaFormValidation struct {
	ClientSide   bool     `json:"clientSide"`
	ServerSide   bool     `json:"serverSide"`
	RealTime     bool     `json:"realTime"`
	OnSubmit     bool     `json:"onSubmit"`
	OnBlur       bool     `json:"onBlur"`
	CustomRules  []string `json:"customRules"`
}

// SchemaFormProps defines properties for schema-driven forms
type SchemaFormProps struct {
	Schema      SchemaFormDefinition   `json:"schema"`
	Data        map[string]any `json:"data"`        // Pre-filled data
	Errors      map[string]string      `json:"errors"`      // Validation errors
	Locale      string                 `json:"locale"`      // Current locale
	ReadOnly    bool                   `json:"readOnly"`    // Read-only mode
	Debug       bool                   `json:"debug"`       // Debug mode
	Class       string                 `json:"class"`
	ID          string                 `json:"id"`
	// HTMX configuration
	HXTarget    string                 `json:"hxTarget"`
	HXSwap      string                 `json:"hxSwap"`
	// Events
	OnSubmit    string                 `json:"onSubmit"`
	OnValidate  string                 `json:"onValidate"`
	OnFieldChange string               `json:"onFieldChange"`
}

// SchemaForm renders a complete form from schema definition
templ SchemaForm(props SchemaFormProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ "schema-form " + props.Class }
		x-data={ getSchemaFormAlpineData(props) }
		x-init="initForm()"
	>
		@Form(FormProps{
			Layout:      props.Schema.Layout,
			Size:        FormSizeMD,
			Title:       props.Schema.Title,
			Description: props.Schema.Description,
			Method:      getSchemaFormMethod(props.Schema.Method),
			Action:      props.Schema.Action,
			Sections:    convertSchemaToFormSections(props.Schema.Sections, props),
			Fields:      convertSchemaToFormFields(props.Schema.Fields, props),
			Actions:     getSchemaFormActions(props),
			GridCols:    getSchemaFormGridCols(props.Schema.GridCols),
			HXPost:      props.Schema.SubmitURL,
			HXTarget:    getSchemaFormTarget(props.HXTarget),
			HXSwap:      getSchemaFormSwap(props.HXSwap),
			HXValidate:  props.Schema.Validation.ClientSide,
			AlpineSubmit: "submitForm()",
			OnSubmit:    props.OnSubmit,
			OnValidate:  props.OnValidate,
		})

		// Form result container
		<div id="form-result" class="mt-4"></div>

		// Debug panel
		if props.Debug {
			@schemaFormDebug(props)
		}
	</div>
}

// convertSchemaToFormSections converts schema sections to form sections
func convertSchemaToFormSections(schemaSections []SchemaFormSection, props SchemaFormProps) []FormSection {
	sections := make([]FormSection, len(schemaSections))
	for i, section := range schemaSections {
		sections[i] = FormSection{
			Title:       getLocalizedText(section.Title, props.Locale),
			Description: getLocalizedText(section.Description, props.Locale),
			Fields:      convertSchemaToFormFields(section.Fields, props),
			Collapsible: section.Collapsible,
			Collapsed:   section.Collapsed,
		}
	}
	return sections
}

// convertSchemaToFormFields converts schema fields to form fields
func convertSchemaToFormFields(schemaFields []SchemaField, props SchemaFormProps) []molecules.FormFieldProps {
	fields := make([]molecules.FormFieldProps, 0)
	
	for _, field := range schemaFields {
		if field.Hidden {
			continue
		}
		
		formField := molecules.FormFieldProps{
			Type:        mapSchemaTypeToFormType(field.Type, field.Widget),
			ID:          field.Name,
			Name:        field.Name,
			Label:       getFieldLabel(field, props.Locale),
			Placeholder: getFieldPlaceholder(field, props.Locale),
			HelpText:    getFieldDescription(field, props.Locale),
			Required:    field.Required,
			Disabled:    props.ReadOnly,
			Readonly:    field.ReadOnly,
			Value:       getFieldValue(field.Name, props.Data),
			ErrorText:   getFieldError(field.Name, props.Errors),
			// Validation
			MinLength:   field.MinLength,
			MaxLength:   field.MaxLength,
			Min:         convertToString(field.Min),
			Max:         convertToString(field.Max),
			Pattern:     field.Pattern,
			// Options for select fields
			Options:     convertBasicSchemaOptionsToFormOptions(field.Options),
			Multiple:    field.Multiple,
			// HTMX for dynamic fields
			HXPost:      getFieldValidationURL(field.Reference, field.Name),
			HXTarget:    "#field-" + field.Name + "-feedback",
			HXTrigger:   getFieldTrigger(props.Schema.Validation.RealTime),
			// Alpine.js
			AlpineModel: "formData." + field.Name,
			AlpineChange: "validateField('" + field.Name + "')",
			AlpineBlur:  getFieldBlurValidation(props.Schema.Validation.OnBlur, field.Name),
		}
		
		// Handle special field types
		switch field.Type {
		case "array":
			if len(field.Options) > 0 {
				formField.Type = molecules.FormFieldTags
				formField.TagsEditable = false
			} else {
				formField.Type = molecules.FormFieldTags
				formField.TagsEditable = true
			}
		case "object":
			// Handle nested objects - could be expanded to support nested forms
			formField.Type = molecules.FormFieldTextarea
		}
		
		fields = append(fields, formField)
	}
	
	return fields
}

// mapSchemaTypeToFormType maps schema field types to form field types
func mapSchemaTypeToFormType(schemaType string, widget string) molecules.FormFieldType {
	// Widget override
	if widget != "" {
		switch widget {
		case "textarea":
			return molecules.FormFieldTextarea
		case "password":
			return molecules.FormFieldPassword
		case "email":
			return molecules.FormFieldEmail
		case "search":
			return molecules.FormFieldSearch
		case "select":
			return molecules.FormFieldSelect
		case "tags":
			return molecules.FormFieldTags
		}
	}
	
	// Default mapping
	switch schemaType {
	case "string":
		return molecules.FormFieldText
	case "number", "integer":
		return molecules.FormFieldNumber
	case "boolean":
		return molecules.FormFieldSelect
	case "date":
		return molecules.FormFieldText // Could be enhanced with date picker
	case "email":
		return molecules.FormFieldEmail
	case "password":
		return molecules.FormFieldPassword
	case "text", "longtext":
		return molecules.FormFieldTextarea
	case "array":
		return molecules.FormFieldTags
	case "reference":
		return molecules.FormFieldSelect
	default:
		return molecules.FormFieldText
	}
}

// getSchemaFormActions generates form actions
func getSchemaFormActions(props SchemaFormProps) []FormAction {
	actions := []FormAction{
		{
			Text:    "Cancel",
			Type:    "button",
			Variant: atoms.ButtonOutline,
			AlpineClick: "cancelForm()",
		},
		{
			Text:    "Save",
			Type:    "submit",
			Variant: atoms.ButtonPrimary,
			Loading: false, // Will be bound to Alpine.js state
		},
	}
	
	if props.Schema.AutoSave {
		actions = append(actions, FormAction{
			Text:    "Auto-save",
			Type:    "button",
			Variant: atoms.ButtonGhost,
			Icon:    "save",
			AlpineClick: "autoSave()",
		})
	}
	
	return actions
}

// convertBasicSchemaOptionsToFormOptions converts schema options to form options  
func convertBasicSchemaOptionsToFormOptions(options []SchemaFieldOption) []molecules.SelectOption {
	formOptions := make([]molecules.SelectOption, len(options))
	for i, option := range options {
		formOptions[i] = molecules.SelectOption{
			Value:    option.Value,
			Label:    option.Label,
			Disabled: option.Disabled,
		}
	}
	return formOptions
}

// getSchemaFormAlpineData generates Alpine.js data for schema forms
func getSchemaFormAlpineData(props SchemaFormProps) string {
	// Convert data to JSON for Alpine.js
	dataJson, _ := json.Marshal(props.Data)
	errorsJson, _ := json.Marshal(props.Errors)
	
	return `{
		formData: ` + string(dataJson) + `,
		errors: ` + string(errorsJson) + `,
		loading: false,
		saving: false,
		autoSaving: false,
		dirty: false,
		valid: true,
		
		initForm() {
			// Initialize form
			this.validateAllFields();
			this.setupAutoSave();
			this.setupConditionalLogic();
		},
		
		validateField(fieldName) {
			// Client-side validation
			const field = this.getFieldSchema(fieldName);
			const value = this.formData[fieldName];
			const errors = [];
			
			// Required validation
			if (field.required && (!value || value.toString().trim() === '')) {
				errors.push('This field is required');
			}
			
			// Length validation
			if (value && field.minLength && value.length < field.minLength) {
				errors.push('Minimum length is ' + field.minLength);
			}
			if (value && field.maxLength && value.length > field.maxLength) {
				errors.push('Maximum length is ' + field.maxLength);
			}
			
			// Pattern validation
			if (value && field.pattern) {
				const regex = new RegExp(field.pattern);
				if (!regex.test(value)) {
					errors.push('Invalid format');
				}
			}
			
			// Update errors
			if (errors.length > 0) {
				this.errors[fieldName] = errors[0];
			} else {
				delete this.errors[fieldName];
			}
			
			this.dirty = true;
			this.valid = Object.keys(this.errors).length === 0;
			
			` + props.OnFieldChange + `
		},
		
		validateAllFields() {
			// Validate all fields
			Object.keys(this.formData).forEach(fieldName => {
				this.validateField(fieldName);
			});
		},
		
		submitForm() {
			this.loading = true;
			this.saving = true;
			
			// Final validation
			this.validateAllFields();
			
			if (!this.valid) {
				this.loading = false;
				this.saving = false;
				return false;
			}
			
			` + props.OnSubmit + `
			
			// Form will be submitted via HTMX
			return true;
		},
		
		cancelForm() {
			// Reset form or navigate away
			this.formData = ` + string(dataJson) + `;
			this.errors = {};
			this.dirty = false;
		},
		
		autoSave() {
			if (!this.dirty || !this.valid) return;
			
			this.autoSaving = true;
			
			// Send auto-save request
			htmx.ajax('POST', '` + props.Schema.Action + `/auto-save', {
				values: this.formData,
				target: '#auto-save-status'
			}).then(() => {
				this.autoSaving = false;
				this.dirty = false;
			});
		},
		
		setupAutoSave() {
			if (!` + strconv.FormatBool(props.Schema.AutoSave) + `) return;
			
			// Auto-save every 30 seconds if dirty
			setInterval(() => {
				if (this.dirty && this.valid) {
					this.autoSave();
				}
			}, 30000);
		},
		
		setupConditionalLogic() {
			// Watch for field changes to handle conditional logic
			this.$watch('formData', (newData, oldData) => {
				this.evaluateConditions(newData, oldData);
			}, { deep: true });
		},
		
		evaluateConditions(newData, oldData) {
			// Evaluate conditional field logic
			// This would be expanded based on the schema conditions
		},
		
		getFieldSchema(fieldName) {
			// Helper to get field schema
			const schema = ` + getSchemaFieldsJSON(props.Schema) + `;
			return schema.find(f => f.name === fieldName) || {};
		},
		
		reset() {
			this.formData = ` + string(dataJson) + `;
			this.errors = {};
			this.dirty = false;
			this.valid = true;
		}
	}`
}

// schemaFormDebug renders debug information
templ schemaFormDebug(props SchemaFormProps) {
	<div class="mt-8 p-4 bg-muted rounded-lg" x-data="{ showDebug: false }">
		<button
			class="flex items-center gap-2 text-sm font-medium"
			x-on:click="showDebug = !showDebug"
		>
			@atoms.Icon(atoms.IconProps{Name: "settings", Size: atoms.IconSizeSM})
			Debug Information
			@atoms.Icon(atoms.IconProps{
				Name:  "chevron-down",
				Size:  atoms.IconSizeXS,
				Class: "transition-transform x-bind:class=\"{'rotate-180': showDebug}\"",
			})
		</button>
		
		<div x-show="showDebug" x-transition class="mt-4 space-y-4">
			// Form data
			<div>
				<h4 class="font-medium mb-2">Form Data:</h4>
				<pre 
					class="bg-background p-3 rounded text-xs overflow-auto"
					x-text="JSON.stringify(formData, null, 2)"
				></pre>
			</div>
			
			// Validation errors
			<div>
				<h4 class="font-medium mb-2">Validation Errors:</h4>
				<pre 
					class="bg-background p-3 rounded text-xs overflow-auto"
					x-text="JSON.stringify(errors, null, 2)"
				></pre>
			</div>
			
			// Form state
			<div>
				<h4 class="font-medium mb-2">Form State:</h4>
				<div class="grid grid-cols-2 gap-2 text-sm">
					<div>Valid: <span x-text="valid" class="font-mono"></span></div>
					<div>Dirty: <span x-text="dirty" class="font-mono"></span></div>
					<div>Loading: <span x-text="loading" class="font-mono"></span></div>
					<div>Saving: <span x-text="saving" class="font-mono"></span></div>
				</div>
			</div>
		</div>
	</div>
}

// Helper functions for ternary operators
func getSchemaFormMethod(method string) string {
	if method != "" {
		return method
	}
	return "POST"
}

func getSchemaFormGridCols(gridCols int) int {
	if gridCols > 0 {
		return gridCols
	}
	return 2
}

func getSchemaFormTarget(target string) string {
	if target != "" {
		return target
	}
	return "#form-result"
}

func getSchemaFormSwap(swap string) string {
	if swap != "" {
		return swap
	}
	return "innerHTML"
}

func getFieldValidationURL(reference string, fieldName string) string {
	if reference != "" {
		return "/api/fields/" + fieldName + "/validate"
	}
	return ""
}

func getFieldTrigger(realTime bool) string {
	if realTime {
		return "change, keyup delay:300ms"
	}
	return "change"
}

func getFieldBlurValidation(onBlur bool, fieldName string) string {
	if onBlur {
		return "validateField('" + fieldName + "')"
	}
	return ""
}

func getSchemaFormData(data map[string]any) map[string]any {
	if data != nil {
		return data
	}
	return make(map[string]any)
}

// Helper functions

func getLocalizedText(text, locale string) string {
	// This would integrate with the i18n system
	// For now, return the original text
	return text
}

func getFieldLabel(field SchemaField, locale string) string {
	if i18n, exists := field.I18n[locale]; exists && i18n.Label != "" {
		return i18n.Label
	}
	if field.Label != "" {
		return field.Label
	}
	return strings.Title(field.Name)
}

func getFieldPlaceholder(field SchemaField, locale string) string {
	if i18n, exists := field.I18n[locale]; exists && i18n.Placeholder != "" {
		return i18n.Placeholder
	}
	return field.Placeholder
}

func getFieldDescription(field SchemaField, locale string) string {
	if i18n, exists := field.I18n[locale]; exists && i18n.Description != "" {
		return i18n.Description
	}
	return field.Description
}

func getFieldValue(fieldName string, data map[string]any) string {
	if value, exists := data[fieldName]; exists && value != nil {
		return convertToString(value)
	}
	return ""
}

func getFieldError(fieldName string, errors map[string]string) string {
	if error, exists := errors[fieldName]; exists {
		return error
	}
	return ""
}

func convertToString(value any) string {
	if value == nil {
		return ""
	}
	switch v := value.(type) {
	case string:
		return v
	case int:
		return strconv.Itoa(v)
	case int64:
		return strconv.FormatInt(v, 10)
	case float64:
		return strconv.FormatFloat(v, 'f', -1, 64)
	case bool:
		return strconv.FormatBool(v)
	default:
		return ""
	}
}

func getSchemaFieldsJSON(schema SchemaFormDefinition) string {
	allFields := append(schema.Fields, extractFieldsFromSections(schema.Sections)...)
	fieldsJson, _ := json.Marshal(allFields)
	return string(fieldsJson)
}

func extractFieldsFromSections(sections []SchemaFormSection) []SchemaField {
	var fields []SchemaField
	for _, section := range sections {
		fields = append(fields, section.Fields...)
	}
	return fields
}

// Convenience components

// SimpleSchemaForm renders a basic schema form
templ SimpleSchemaForm(schema SchemaFormDefinition, data map[string]any) {
	@SchemaForm(SchemaFormProps{
		Schema: schema,
		Data:   getSchemaFormData(data),
		Locale: "en",
	})
}

// ReadOnlySchemaForm renders a read-only schema form
templ ReadOnlySchemaForm(schema SchemaFormDefinition, data map[string]any) {
	@SchemaForm(SchemaFormProps{
		Schema:   schema,
		Data:     getSchemaFormData(data),
		Locale:   "en",
		ReadOnly: true,
	})
}

// DebugSchemaForm renders a schema form with debug information
templ DebugSchemaForm(schema SchemaFormDefinition, data map[string]any) {
	@SchemaForm(SchemaFormProps{
		Schema: schema,
		Data:   getSchemaFormData(data),
		Locale: "en",
		Debug:  true,
	})
}