package molecules

import (
	"fmt"
	"strconv"
	"strings"
	"github.com/niiniyare/ruun/views/components/atoms"
)

// SearchBoxSize defines the size variants for the search box
type SearchBoxSize string

const (
	SearchBoxSizeSM SearchBoxSize = "sm"
	SearchBoxSizeMD SearchBoxSize = "md"
	SearchBoxSizeLG SearchBoxSize = "lg"
)

// SearchSuggestion represents a suggestion item
type SearchSuggestion struct {
	Value       string
	Label       string
	Description string
	Icon        string
	Category    string
	URL         string // For navigation suggestions
}

// SearchBoxProps defines the properties for the SearchBox component
type SearchBoxProps struct {
	Size            SearchBoxSize
	ID              string
	Name            string
	Value           string
	Placeholder     string
	Suggestions     []SearchSuggestion
	ShowSuggestions bool
	Loading         bool
	Disabled        bool
	Class           string
	// Search behavior
	MinChars        int    // Minimum characters before showing suggestions
	Debounce        int    // Debounce delay in milliseconds
	ClearOnSelect   bool   // Clear input after selection
	// HTMX attributes
	HXPost          string // URL for search API
	HXGet           string // URL for search API
	HXTarget        string // Target for search results
	HXSwap          string // Swap strategy
	HXTrigger       string // Custom trigger
	// Alpine.js attributes
	AlpineData      string // Custom x-data
	AlpineModel     string // x-model for input
	AlpineSearch    string // Custom search method
	AlpineSelect    string // Method called when suggestion is selected
	AlpineClear     string // Method called when clear button is clicked
	// Events
	OnSearch        string // JavaScript function for search
	OnSelect        string // JavaScript function for selection
	OnClear         string // JavaScript function for clear
}

// searchBoxClasses generates container classes
func searchBoxClasses(props SearchBoxProps) string {
	var classes []string

	// Base classes
	classes = append(classes, "relative", "w-full")

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return strings.Join(classes, " ")
}

// suggestionsClasses generates classes for the suggestions dropdown
func suggestionsClasses(props SearchBoxProps) string {
	var classes []string

	// Base classes
	classes = append(classes,
		"absolute",
		"top-full",
		"left-0",
		"right-0",
		"z-50",
		"mt-1",
		"max-h-60",
		"overflow-auto",
		"rounded-md",
		"border",
		"border-input",
		"bg-popover",
		"text-popover-foreground",
		"shadow-md",
	)

	return strings.Join(classes, " ")
}

// suggestionItemClasses generates classes for individual suggestion items
func suggestionItemClasses() string {
	return strings.Join([]string{
		"flex",
		"cursor-pointer",
		"select-none",
		"items-center",
		"gap-2",
		"px-3",
		"py-2",
		"text-sm",
		"hover:bg-accent",
		"hover:text-accent-foreground",
		"focus:bg-accent",
		"focus:text-accent-foreground",
		"focus:outline-none",
	}, " ")
}

// SearchBox renders a search input with suggestions dropdown
templ SearchBox(props SearchBoxProps) {
	<div
		class={ searchBoxClasses(props) }
		if props.AlpineData != "" {
			x-data={ props.AlpineData }
		} else {
			x-data={ getDefaultAlpineData(props) }
		}
		x-on:click.away="showSuggestions = false"
	>
		// Search input with icon
		<div class="relative">
			<div class="absolute inset-y-0 left-0 flex items-center pl-3">
				if props.Loading {
					@atoms.LoadingIcon()
				} else {
					@atoms.Icon(atoms.IconProps{Name: "search", Size: atoms.IconSizeSM, Class: "text-muted-foreground"})
				}
			</div>
			
			@atoms.Input(atoms.InputProps{
				Type:        atoms.InputTypeSearch,
				Size:        atoms.InputSize(props.Size),
				ID:          props.ID,
				Name:        props.Name,
				Value:       props.Value,
				Placeholder: getPlaceholderValue(props.Placeholder),
				Disabled:    props.Disabled,
				Class:       "pl-9 pr-8",
				HXPost:      props.HXPost,
				HXGet:       props.HXGet,
				HXTarget:    props.HXTarget,
				HXSwap:      props.HXSwap,
				HXTrigger:   getHXTriggerValue(props.HXTrigger),
				AlpineModel: getAlpineModelValue(props.AlpineModel),
				AlpineChange: "handleSearch()",
				AlpineFocus: "showSuggestions = true",
			})
			
			// Clear button
			<button
				type="button"
				class="absolute inset-y-0 right-0 flex items-center pr-3"
				x-show="searchQuery.length > 0"
				x-on:click="clearSearch()"
				aria-label="Clear search"
			>
				@atoms.Icon(atoms.IconProps{Name: "x", Size: atoms.IconSizeSM, Class: "text-muted-foreground hover:text-foreground"})
			</button>
		</div>

		// Suggestions dropdown
		<div
			class={ suggestionsClasses(props) }
			x-show="showSuggestions && suggestions.length > 0"
			x-transition:enter="transition ease-out duration-100"
			x-transition:enter-start="transform opacity-0 scale-95"
			x-transition:enter-end="transform opacity-100 scale-100"
			x-transition:leave="transition ease-in duration-75"
			x-transition:leave-start="transform opacity-100 scale-100"
			x-transition:leave-end="transform opacity-0 scale-95"
		>
			// Static suggestions (from props)
			for _, suggestion := range props.Suggestions {
				@suggestionItem(suggestion, props)
			}
			
			// Dynamic suggestions (from Alpine.js)
			<template x-for="(suggestion, index) in suggestions" x-key="index">
				<div
					class={ suggestionItemClasses() }
					x-on:click="selectSuggestion(suggestion)"
					x-bind:class="{ 'bg-accent text-accent-foreground': index === selectedIndex }"
				>
					<span x-show="suggestion.icon" class="shrink-0">
						@atoms.Icon(atoms.IconProps{Name: "", Size: atoms.IconSizeSM, Class: "text-muted-foreground"})
					</span>
					<div class="flex-1 min-w-0">
						<div class="font-medium" x-text="suggestion.label"></div>
						<div x-show="suggestion.description" class="text-xs text-muted-foreground" x-text="suggestion.description"></div>
					</div>
					<div x-show="suggestion.category" class="text-xs text-muted-foreground" x-text="suggestion.category"></div>
				</div>
			</template>
			
			// No results message
			<div
				class="px-3 py-2 text-sm text-muted-foreground"
				x-show="searchQuery.length >= minChars && suggestions.length === 0 && !loading"
			>
				No results found
			</div>
		</div>
	</div>
}

// suggestionItem renders a static suggestion item
templ suggestionItem(suggestion SearchSuggestion, props SearchBoxProps) {
	<div
		class={ suggestionItemClasses() }
		if suggestion.URL != "" {
			hx-get={ suggestion.URL }
			hx-target={ props.HXTarget }
			hx-swap={ getHXSwapValue(props.HXSwap) }
		}
		x-on:click={ generateSelectSuggestionHandler(suggestion) }
	>
		if suggestion.Icon != "" {
			<span class="shrink-0">
				@atoms.Icon(atoms.IconProps{Name: suggestion.Icon, Size: atoms.IconSizeSM, Class: "text-muted-foreground"})
			</span>
		}
		<div class="flex-1 min-w-0">
			<div class="font-medium">{ suggestion.Label }</div>
			if suggestion.Description != "" {
				<div class="text-xs text-muted-foreground">{ suggestion.Description }</div>
			}
		</div>
		if suggestion.Category != "" {
			<div class="text-xs text-muted-foreground">{ suggestion.Category }</div>
		}
	</div>
}

// Helper function to generate default Alpine.js data
func getDefaultAlpineData(props SearchBoxProps) string {
	minChars := props.MinChars
	if minChars == 0 {
		minChars = 1
	}
	
	debounce := props.Debounce
	if debounce == 0 {
		debounce = 300
	}

	return `{
		searchQuery: '` + props.Value + `',
		suggestions: [],
		showSuggestions: false,
		selectedIndex: -1,
		loading: false,
		minChars: ` + strconv.Itoa(minChars) + `,
		debounceTimer: null,
		
		handleSearch() {
			if (this.debounceTimer) {
				clearTimeout(this.debounceTimer);
			}
			
			this.debounceTimer = setTimeout(() => {
				if (this.searchQuery.length >= this.minChars) {
					this.search();
				} else {
					this.suggestions = [];
					this.showSuggestions = false;
				}
			}, ` + strconv.Itoa(debounce) + `);
		},
		
		search() {
			this.loading = true;
			// Custom search logic here
			` + props.OnSearch + `
			// Default HTMX search is handled by the input element
		},
		
		selectSuggestion(suggestion) {
			` + getClearOnSelectJS(props.ClearOnSelect) + `
			this.showSuggestions = false;
			this.selectedIndex = -1;
			` + props.OnSelect + `
			
			// Navigate if URL is provided
			if (suggestion.url) {
				htmx.ajax('GET', suggestion.url, { target: '` + props.HXTarget + `', swap: '` + props.HXSwap + `' });
			}
		},
		
		clearSearch() {
			this.searchQuery = '';
			this.suggestions = [];
			this.showSuggestions = false;
			this.selectedIndex = -1;
			` + props.OnClear + `
		},
		
		// Keyboard navigation
		handleKeydown(event) {
			if (!this.showSuggestions) return;
			
			switch (event.key) {
				case 'ArrowDown':
					event.preventDefault();
					this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1);
					break;
				case 'ArrowUp':
					event.preventDefault();
					this.selectedIndex = Math.max(this.selectedIndex - 1, -1);
					break;
				case 'Enter':
					event.preventDefault();
					if (this.selectedIndex >= 0) {
						this.selectSuggestion(this.suggestions[this.selectedIndex]);
					}
					break;
				case 'Escape':
					this.showSuggestions = false;
					this.selectedIndex = -1;
					break;
			}
		}
	}`
}

// Helper function to convert SearchSuggestion to JavaScript object string
func suggestionToJS(suggestion SearchSuggestion) string {
	return `{
		value: '` + suggestion.Value + `',
		label: '` + suggestion.Label + `',
		description: '` + suggestion.Description + `',
		icon: '` + suggestion.Icon + `',
		category: '` + suggestion.Category + `',
		url: '` + suggestion.URL + `'
	}`
}

// getHXSwapValue returns the HX swap value, defaulting to "innerHTML" if empty
func getHXSwapValue(swap string) string {
	if swap != "" {
		return swap
	}
	return "innerHTML"
}

// generateSelectSuggestionHandler creates the x-on:click handler for selecting a suggestion
func generateSelectSuggestionHandler(suggestion SearchSuggestion) string {
	return fmt.Sprintf("selectSuggestion(%s)", suggestionToJS(suggestion))
}

// getClearOnSelectJS returns the JavaScript for clearing on select
func getClearOnSelectJS(clearOnSelect bool) string {
	if clearOnSelect {
		return "this.searchQuery = '';"
	}
	return "this.searchQuery = suggestion.label;"
}

// getPlaceholderValue returns the placeholder value, defaulting to "Search..." if empty
func getPlaceholderValue(placeholder string) string {
	if placeholder != "" {
		return placeholder
	}
	return "Search..."
}

// getHXTriggerValue returns the HX trigger value, defaulting to "keyup changed delay:300ms" if empty
func getHXTriggerValue(trigger string) string {
	if trigger != "" {
		return trigger
	}
	return "keyup changed delay:300ms"
}

// getAlpineModelValue returns the Alpine model value, defaulting to "searchQuery" if empty
func getAlpineModelValue(model string) string {
	if model != "" {
		return model
	}
	return "searchQuery"
}

// getSearchSizeValue returns the search size value with default
func getSearchSizeValue(size SearchBoxSize) SearchBoxSize {
	if size != "" {
		return size
	}
	return SearchBoxSizeMD
}

// getGlobalSearchID returns the global search ID with default
func getGlobalSearchID(id string) string {
	if id != "" {
		return id
	}
	return "global-search"
}

// getGlobalSearchName returns the global search name with default
func getGlobalSearchName(name string) string {
	if name != "" {
		return name
	}
	return "q"
}

// getGlobalSearchPlaceholder returns the global search placeholder with default
func getGlobalSearchPlaceholder(placeholder string) string {
	if placeholder != "" {
		return placeholder
	}
	return "Search everything..."
}

// getGlobalSearchHXGet returns the global search HX get value with default
func getGlobalSearchHXGet(hxGet string) string {
	if hxGet != "" {
		return hxGet
	}
	return "/search"
}

// getGlobalSearchHXTarget returns the global search HX target value with default
func getGlobalSearchHXTarget(hxTarget string) string {
	if hxTarget != "" {
		return hxTarget
	}
	return "#search-results"
}

// getQuickSearchPlaceholder returns the placeholder for quick search
func getQuickSearchPlaceholder(placeholder string) string {
	if placeholder != "" {
		return placeholder
	}
	return "Quick search..."
}

// getMinCharsValue returns the minimum characters value, defaulting to 2 if 0 or less
func getMinCharsValue(minChars int) int {
	if minChars > 0 {
		return minChars
	}
	return 2
}

// getDebounceValue returns the debounce value, defaulting to 200 if 0 or less
func getDebounceValue(debounce int) int {
	if debounce > 0 {
		return debounce
	}
	return 200
}

// QuickSearchBox renders a simplified search box for quick searches
templ QuickSearchBox(props SearchBoxProps) {
	@SearchBox(SearchBoxProps{
		Size:        props.Size,
		ID:          props.ID,
		Name:        props.Name,
		Value:       props.Value,
		Placeholder: getQuickSearchPlaceholder(props.Placeholder),
		Class:       props.Class,
		MinChars:    getMinCharsValue(props.MinChars),
		Debounce:    getDebounceValue(props.Debounce),
		HXGet:       props.HXGet,
		HXTarget:    props.HXTarget,
		HXSwap:     props.HXSwap,
	})
}

// GlobalSearchBox renders a search box for global/site-wide search
templ GlobalSearchBox(props SearchBoxProps) {
	@SearchBox(SearchBoxProps{
		Size:        getSearchSizeValue(props.Size),
		ID:          getGlobalSearchID(props.ID),
		Name:        getGlobalSearchName(props.Name),
		Value:       props.Value,
		Placeholder: getGlobalSearchPlaceholder(props.Placeholder),
		Class:       props.Class,
		MinChars:    getMinCharsValue(props.MinChars),
		Debounce:    getDebounceValue(props.Debounce),
		HXGet:       getGlobalSearchHXGet(props.HXGet),
		HXTarget:    getGlobalSearchHXTarget(props.HXTarget),
		HXSwap:     getHXSwapValue(props.HXSwap),
		OnSearch:    props.OnSearch,
		OnSelect:    props.OnSelect,
		OnClear:     props.OnClear,
	})
}