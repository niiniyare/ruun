package molecules

import (
	"strings"
	"strconv"
	"github.com/niiniyare/erp/views/components/atoms"
)

// ErrorType defines different types of errors
type ErrorType string

const (
	ErrorValidation ErrorType = "validation"
	ErrorNetwork    ErrorType = "network"
	ErrorServer     ErrorType = "server"
	ErrorAuth       ErrorType = "auth"
	ErrorNotFound   ErrorType = "notfound"
	ErrorPermission ErrorType = "permission"
	ErrorGeneral    ErrorType = "general"
)

// ErrorSeverity defines the severity level of errors
type ErrorSeverity string

const (
	SeverityLow      ErrorSeverity = "low"
	SeverityMedium   ErrorSeverity = "medium"
	SeverityHigh     ErrorSeverity = "high"
	SeverityCritical ErrorSeverity = "critical"
)

// ErrorDetail represents detailed error information
type ErrorDetail struct {
	Code        string                 `json:"code"`
	Message     string                 `json:"message"`
	Field       string                 `json:"field"`
	Type        ErrorType              `json:"type"`
	Severity    ErrorSeverity          `json:"severity"`
	Timestamp   string                 `json:"timestamp"`
	Context     map[string]interface{} `json:"context"`
	Suggestions []string               `json:"suggestions"`
	HelpURL     string                 `json:"helpUrl"`
	Retryable   bool                   `json:"retryable"`
}

// ErrorBoundaryProps defines properties for error boundaries
type ErrorBoundaryProps struct {
	Errors       []ErrorDetail `json:"errors"`
	Title        string        `json:"title"`
	Description  string        `json:"description"`
	ShowDetails  bool          `json:"showDetails"`
	ShowStack    bool          `json:"showStack"`
	Recoverable  bool          `json:"recoverable"`
	AutoRetry    bool          `json:"autoRetry"`
	RetryCount   int           `json:"retryCount"`
	MaxRetries   int           `json:"maxRetries"`
	RetryDelay   int           `json:"retryDelay"` // milliseconds
	Dismissible  bool          `json:"dismissible"`
	Persistent   bool          `json:"persistent"` // Don't auto-dismiss
	Class        string        `json:"class"`
	ID           string        `json:"id"`
	// Actions
	Actions      []ErrorAction `json:"actions"`
	// Events
	OnRetry      string        `json:"onRetry"`
	OnDismiss    string        `json:"onDismiss"`
	OnReport     string        `json:"onReport"`
	// HTMX
	HXRetry      string        `json:"hxRetry"`
	HXReport     string        `json:"hxReport"`
}

// ErrorAction represents an action button for error handling
type ErrorAction struct {
	Text        string             `json:"text"`
	Icon        string             `json:"icon"`
	Variant     atoms.ButtonVariant `json:"variant"`
	Action      string             `json:"action"` // "retry", "dismiss", "report", "custom"
	URL         string             `json:"url"`
	AlpineClick string             `json:"alpineClick"`
	HXPost      string             `json:"hxPost"`
	HXGet       string             `json:"hxGet"`
}

// NotificationProps defines properties for notification toasts
type NotificationProps struct {
	Type         ErrorType     `json:"type"`
	Title        string        `json:"title"`
	Message      string        `json:"message"`
	Duration     int           `json:"duration"`     // Auto-dismiss time in ms (0 = no auto-dismiss)
	Position     string        `json:"position"`     // "top-right", "top-left", "bottom-right", "bottom-left", "top-center", "bottom-center"
	Dismissible  bool          `json:"dismissible"`
	Icon         string        `json:"icon"`
	Actions      []ErrorAction `json:"actions"`
	Class        string        `json:"class"`
	ID           string        `json:"id"`
	// Events
	OnShow       string        `json:"onShow"`
	OnHide       string        `json:"onHide"`
	OnAction     string        `json:"onAction"`
}

// errorBoundaryClasses generates classes for error boundaries
func errorBoundaryClasses(props ErrorBoundaryProps) string {
	var classes []string

	// Base classes
	classes = append(classes, "rounded-lg", "border", "p-6", "space-y-4")

	// Severity-based styling
	if len(props.Errors) > 0 {
		severity := getHighestSeverity(props.Errors)
		switch severity {
		case SeverityCritical:
			classes = append(classes, "bg-destructive/10", "border-destructive", "text-destructive-foreground")
		case SeverityHigh:
			classes = append(classes, "bg-destructive/5", "border-destructive/50", "text-destructive-foreground")
		case SeverityMedium:
			classes = append(classes, "bg-warning/10", "border-warning", "text-warning-foreground")
		case SeverityLow:
			classes = append(classes, "bg-muted", "border-border", "text-muted-foreground")
		}
	} else {
		classes = append(classes, "bg-destructive/10", "border-destructive")
	}

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return strings.Join(classes, " ")
}

// ErrorBoundary renders a comprehensive error boundary component
templ ErrorBoundary(props ErrorBoundaryProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ errorBoundaryClasses(props) }
		x-data={ getErrorBoundaryAlpineData(props) }
		x-init="initErrorBoundary()"
		x-show="isVisible"
		x-transition:enter="transition ease-out duration-300"
		x-transition:enter-start="opacity-0 transform scale-95"
		x-transition:enter-end="opacity-100 transform scale-100"
		x-transition:leave="transition ease-in duration-200"
		x-transition:leave-start="opacity-100 transform scale-100"
		x-transition:leave-end="opacity-0 transform scale-95"
	>
		// Header
		<div class="flex items-start justify-between">
			<div class="flex items-start gap-3">
				// Error icon
				<div class="shrink-0 mt-0.5">
					@atoms.Icon(atoms.IconProps{
						Name:  getErrorIcon(props.Errors),
						Size:  atoms.IconSizeLG,
						Class: getErrorIconColor(props.Errors),
					})
				</div>
				
				// Error content
				<div class="space-y-1">
					<h3 class="text-lg font-semibold">
						if props.Title != "" {
							{ props.Title }
						} else {
							{ getDefaultErrorTitle(props.Errors) }
						}
					</h3>
					if props.Description != "" {
						<p class="text-sm opacity-90">{ props.Description }</p>
					} else if len(props.Errors) > 0 {
						<p class="text-sm opacity-90">{ props.Errors[0].Message }</p>
					}
				</div>
			</div>

			// Dismiss button
			if props.Dismissible {
				<button
					class="shrink-0 p-1 rounded-sm opacity-70 hover:opacity-100 transition-opacity"
					x-on:click="dismiss()"
				>
					@atoms.Icon(atoms.IconProps{
						Name:  "x",
						Size:  atoms.IconSizeSM,
					})
				</button>
			}
		</div>

		// Error details
		if props.ShowDetails && len(props.Errors) > 1 {
			<div class="space-y-2">
				<button
					class="flex items-center gap-2 text-sm font-medium hover:underline"
					x-on:click="showDetails = !showDetails"
				>
					<span x-text="showDetails ? 'Hide Details' : 'Show Details (' + errors.length + ' errors)'"></span>
					@atoms.Icon(atoms.IconProps{
						Name:  "chevron-down",
						Size:  atoms.IconSizeXS,
						Class: "transition-transform x-bind:class=\"{'rotate-180': showDetails}\"",
					})
				</button>
				
				<div x-show="showDetails" x-transition class="space-y-2">
					for _, error := range props.Errors {
						@errorDetailItem(error)
					}
				</div>
			</div>
		}

		// Suggestions
		if len(props.Errors) > 0 && len(props.Errors[0].Suggestions) > 0 {
			<div class="space-y-2">
				<h4 class="text-sm font-medium">Suggestions:</h4>
				<ul class="text-sm space-y-1 ml-4">
					for _, suggestion := range props.Errors[0].Suggestions {
						<li class="list-disc">{ suggestion }</li>
					}
				</ul>
			</div>
		}

		// Auto-retry indicator
		if props.AutoRetry && props.RetryCount < props.MaxRetries {
			<div class="flex items-center gap-2 text-sm">
				@atoms.LoadingIcon()
				<span x-text="`Retrying... (${retryCount}/${maxRetries})`"></span>
				<span x-text="`Next attempt in ${retryCountdown}s`"></span>
			</div>
		}

		// Actions
		if len(props.Actions) > 0 || props.Recoverable {
			<div class="flex items-center gap-2 pt-2">
				// Default recovery actions
				if props.Recoverable {
					@atoms.Button(atoms.ButtonProps{
						Variant:     atoms.ButtonPrimary,
						Size:        atoms.ButtonSizeSM,
						Icon:        "refresh-cw",
						Loading:     false,
						AlpineClick: "retry()",
					}) {
						if props.RetryCount > 0 {
							Retry Again
						} else {
							Retry
						}
					}
				}

				// Custom actions
				for _, action := range props.Actions {
					@errorActionButton(action)
				}

				// Report error action
				if len(props.Errors) > 0 && props.Errors[0].HelpURL != "" {
					@atoms.Button(atoms.ButtonProps{
						Variant: atoms.ButtonOutline,
						Size:    atoms.ButtonSizeSM,
						Icon:    "external-link",
						AlpineClick: "window.open('" + props.Errors[0].HelpURL + "', '_blank')",
					}) {
						Get Help
					}
				}
			</div>
		}
	</div>
}

// errorDetailItem renders a single error detail
templ errorDetailItem(errorDetail ErrorDetail) {
	<div class="flex items-start gap-2 p-3 bg-background/50 rounded border text-sm">
		@atoms.Icon(atoms.IconProps{
			Name:  getErrorTypeIcon(errorDetail.Type),
			Size:  atoms.IconSizeXS,
			Class: "mt-0.5 text-muted-foreground",
		})
		<div class="space-y-1">
			<div class="font-medium">{ errorDetail.Message }</div>
			if errorDetail.Code != "" {
				<div class="text-xs text-muted-foreground">Code: { errorDetail.Code }</div>
			}
			if errorDetail.Field != "" {
				<div class="text-xs text-muted-foreground">Field: { errorDetail.Field }</div>
			}
		</div>
	</div>
}

// errorActionButton renders an error action button
templ errorActionButton(action ErrorAction) {
	@atoms.Button(atoms.ButtonProps{
		Variant:     action.Variant,
		Size:        atoms.ButtonSizeSM,
		Icon:        action.Icon,
		AlpineClick: getActionAlpineClick(action),
		HXPost:      action.HXPost,
		HXGet:       action.HXGet,
	}) {
		{ action.Text }
	}
}

// Notification renders toast-style notifications
templ Notification(props NotificationProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ getNotificationClasses(props) }
		x-data={ getNotificationAlpineData(props) }
		x-init="initNotification()"
		x-show="isVisible"
		x-transition:enter="transition ease-out duration-300"
		x-transition:enter-start="opacity-0 transform translate-x-full"
		x-transition:enter-end="opacity-100 transform translate-x-0"
		x-transition:leave="transition ease-in duration-200"
		x-transition:leave-start="opacity-100 transform translate-x-0"
		x-transition:leave-end="opacity-0 transform translate-x-full"
		role="alert"
	>
		<div class="flex items-start gap-3">
			// Notification icon
			if props.Icon != "" || props.Type != "" {
				<div class="shrink-0 mt-0.5">
					@atoms.Icon(atoms.IconProps{
						Name:  getNotificationIcon(props.Icon, props.Type),
						Size:  atoms.IconSizeSM,
						Class: getNotificationIconColor(props.Type),
					})
				</div>
			}

			// Notification content
			<div class="flex-1 min-w-0">
				if props.Title != "" {
					<h4 class="text-sm font-medium">{ props.Title }</h4>
				}
				if props.Message != "" {
					<p class={ getMessageClasses(props.Title != "") }>
						{ props.Message }
					</p>
				}

				// Actions
				if len(props.Actions) > 0 {
					<div class="flex items-center gap-2 mt-3">
						for _, action := range props.Actions {
							@atoms.Button(atoms.ButtonProps{
								Variant:     action.Variant,
								Size:        atoms.ButtonSizeXS,
								AlpineClick: getActionAlpineClick(action),
								HXPost:      action.HXPost,
								HXGet:       action.HXGet,
							}) {
								{ action.Text }
							}
						}
					</div>
				}
			</div>

			// Dismiss button
			if props.Dismissible {
				<button
					class="shrink-0 p-1 rounded-sm opacity-70 hover:opacity-100 transition-opacity"
					x-on:click="dismiss()"
				>
					@atoms.Icon(atoms.IconProps{
						Name:  "x",
						Size:  atoms.IconSizeXS,
					})
				</button>
			}
		</div>

		// Progress bar for timed notifications
		if props.Duration > 0 {
			<div class="absolute bottom-0 left-0 right-0 h-1 bg-background/20 rounded-b">
				<div 
					class="h-full bg-current rounded-b transition-all linear"
					x-bind:style="`width: ${progress}%; transition-duration: 100ms;`"
				></div>
			</div>
		}
	</div>
}

// NotificationContainer renders a container for notifications
templ NotificationContainer(position string) {
	<div
		id={ "notifications-" + position }
		class={ getNotificationContainerClasses(position) }
		x-data="notificationContainer"
		x-init="initContainer()"
	>
		<template x-for="notification in notifications" x-key="notification.id">
			<div x-html="notification.html"></div>
		</template>
	</div>
}

// GlobalErrorHandler renders a global error handler
templ GlobalErrorHandler() {
	<div
		id="global-error-handler"
		x-data="globalErrorHandler"
		x-init="initGlobalHandler()"
		class="fixed inset-0 z-[100] pointer-events-none"
	>
		// Critical error overlay
		<div
			x-show="hasCriticalError"
			x-transition:enter="transition ease-out duration-300"
			x-transition:enter-start="opacity-0"
			x-transition:enter-end="opacity-100"
			class="absolute inset-0 bg-black/80 pointer-events-auto flex items-center justify-center p-6"
		>
			<div class="bg-background rounded-lg border max-w-md w-full p-6 space-y-4">
				<div class="flex items-center gap-3">
					@atoms.Icon(atoms.IconProps{
						Name:  "alert-triangle",
						Size:  atoms.IconSizeLG,
						Class: "text-destructive",
					})
					<div>
						<h2 class="text-lg font-semibold text-destructive">Critical Error</h2>
						<p class="text-sm text-muted-foreground">The application has encountered a serious error.</p>
					</div>
				</div>
				
				<div class="text-sm" x-text="criticalError.message"></div>
				
				<div class="flex items-center gap-2">
					@atoms.Button(atoms.ButtonProps{
						Variant:     atoms.ButtonPrimary,
						AlpineClick: "window.location.reload()",
					}) {
						Reload Page
					}
					@atoms.Button(atoms.ButtonProps{
						Variant:     atoms.ButtonOutline,
						AlpineClick: "reportError(criticalError)",
					}) {
						Report Error
					}
				</div>
			</div>
		</div>
	</div>
}

// Helper functions

func getHighestSeverity(errors []ErrorDetail) ErrorSeverity {
	if len(errors) == 0 {
		return SeverityMedium
	}
	
	highest := SeverityLow
	for _, error := range errors {
		if error.Severity == SeverityCritical {
			return SeverityCritical
		}
		if error.Severity == SeverityHigh && highest != SeverityCritical {
			highest = SeverityHigh
		}
		if error.Severity == SeverityMedium && highest == SeverityLow {
			highest = SeverityMedium
		}
	}
	return highest
}

func getErrorIcon(errors []ErrorDetail) string {
	if len(errors) == 0 {
		return "alert-circle"
	}
	
	severity := getHighestSeverity(errors)
	switch severity {
	case SeverityCritical:
		return "x-circle"
	case SeverityHigh:
		return "alert-triangle"
	case SeverityMedium:
		return "alert-circle"
	case SeverityLow:
		return "info"
	default:
		return "alert-circle"
	}
}

func getErrorIconColor(errors []ErrorDetail) string {
	severity := getHighestSeverity(errors)
	switch severity {
	case SeverityCritical, SeverityHigh:
		return "text-destructive"
	case SeverityMedium:
		return "text-warning"
	case SeverityLow:
		return "text-muted-foreground"
	default:
		return "text-destructive"
	}
}

func getDefaultErrorTitle(errors []ErrorDetail) string {
	if len(errors) == 0 {
		return "An error occurred"
	}
	
	switch errors[0].Type {
	case ErrorValidation:
		return "Validation Error"
	case ErrorNetwork:
		return "Connection Error"
	case ErrorServer:
		return "Server Error"
	case ErrorAuth:
		return "Authentication Error"
	case ErrorNotFound:
		return "Not Found"
	case ErrorPermission:
		return "Permission Error"
	default:
		return "An error occurred"
	}
}

func getErrorTypeIcon(errorType ErrorType) string {
	switch errorType {
	case ErrorValidation:
		return "alert-circle"
	case ErrorNetwork:
		return "wifi-off"
	case ErrorServer:
		return "server"
	case ErrorAuth:
		return "lock"
	case ErrorNotFound:
		return "search"
	case ErrorPermission:
		return "shield"
	default:
		return "alert-circle"
	}
}

func getNotificationTypeIcon(notificationType ErrorType) string {
	switch notificationType {
	case ErrorValidation:
		return "alert-triangle"
	case ErrorNetwork:
		return "wifi-off"
	case ErrorServer:
		return "server"
	case ErrorAuth:
		return "lock"
	default:
		return "info"
	}
}

func getNotificationIconColor(notificationType ErrorType) string {
	switch notificationType {
	case ErrorValidation:
		return "text-warning"
	case ErrorNetwork:
		return "text-destructive"
	case ErrorServer:
		return "text-destructive"
	case ErrorAuth:
		return "text-destructive"
	default:
		return "text-muted-foreground"
	}
}

func getNotificationClasses(props NotificationProps) string {
	classes := []string{
		"relative", "max-w-sm", "w-full", "bg-background", "border", "rounded-lg", "shadow-lg", "p-4",
	}
	
	switch props.Type {
	case ErrorValidation:
		classes = append(classes, "border-warning/50")
	case ErrorNetwork, ErrorServer, ErrorAuth:
		classes = append(classes, "border-destructive/50")
	default:
		classes = append(classes, "border-border")
	}
	
	if props.Class != "" {
		classes = append(classes, props.Class)
	}
	
	return strings.Join(classes, " ")
}

func getNotificationContainerClasses(position string) string {
	classes := []string{"fixed", "z-50", "flex", "flex-col", "gap-2", "p-4", "pointer-events-none"}
	
	switch position {
	case "top-right":
		classes = append(classes, "top-0", "right-0")
	case "top-left":
		classes = append(classes, "top-0", "left-0")
	case "bottom-right":
		classes = append(classes, "bottom-0", "right-0")
	case "bottom-left":
		classes = append(classes, "bottom-0", "left-0")
	case "top-center":
		classes = append(classes, "top-0", "left-1/2", "transform", "-translate-x-1/2")
	case "bottom-center":
		classes = append(classes, "bottom-0", "left-1/2", "transform", "-translate-x-1/2")
	default:
		classes = append(classes, "top-0", "right-0")
	}
	
	return strings.Join(classes, " ")
}

func getActionAlpineClick(action ErrorAction) string {
	switch action.Action {
	case "retry":
		return "retry()"
	case "dismiss":
		return "dismiss()"
	case "report":
		return "reportError()"
	default:
		return action.AlpineClick
	}
}

// getMessageClasses returns the classes for message paragraph based on whether title exists
func getMessageClasses(hasTitle bool) string {
	if hasTitle {
		return "text-sm mt-1 text-muted-foreground"
	}
	return "text-sm"
}

// getActionVariant returns the button variant for an action
func getActionVariant(variant string) string {
	if variant != "" {
		return variant
	}
	return string(atoms.ButtonOutline)
}

// getNotificationIcon returns the notification icon, preferring custom icon over type-based icon
func getNotificationIcon(customIcon string, notificationType ErrorType) string {
	if customIcon != "" {
		return customIcon
	}
	return getNotificationTypeIcon(notificationType)
}

func getErrorBoundaryAlpineData(props ErrorBoundaryProps) string {
	return `{
		errors: ` + getErrorsJSON(props.Errors) + `,
		isVisible: true,
		showDetails: false,
		retryCount: ` + strconv.Itoa(props.RetryCount) + `,
		maxRetries: ` + strconv.Itoa(props.MaxRetries) + `,
		retryDelay: ` + strconv.Itoa(props.RetryDelay) + `,
		retryCountdown: 0,
		autoRetryTimer: null,
		
		initErrorBoundary() {
			if (` + strings.ToLower(strconv.FormatBool(props.AutoRetry)) + ` && this.retryCount < this.maxRetries) {
				this.startAutoRetry();
			}
		},
		
		async retry() {
			this.retryCount++;
			` + props.OnRetry + `
			
			if (this.retryCount >= this.maxRetries) {
				this.stopAutoRetry();
			}
		},
		
		dismiss() {
			this.isVisible = false;
			` + props.OnDismiss + `
		},
		
		reportError() {
			` + props.OnReport + `
		},
		
		startAutoRetry() {
			this.retryCountdown = this.retryDelay / 1000;
			this.autoRetryTimer = setInterval(() => {
				this.retryCountdown--;
				if (this.retryCountdown <= 0) {
					this.retry();
					if (this.retryCount < this.maxRetries) {
						this.retryCountdown = this.retryDelay / 1000;
					} else {
						this.stopAutoRetry();
					}
				}
			}, 1000);
		},
		
		stopAutoRetry() {
			if (this.autoRetryTimer) {
				clearInterval(this.autoRetryTimer);
				this.autoRetryTimer = null;
			}
		}
	}`
}

func getNotificationAlpineData(props NotificationProps) string {
	return `{
		isVisible: true,
		progress: 100,
		duration: ` + strconv.Itoa(props.Duration) + `,
		timer: null,
		progressTimer: null,
		
		initNotification() {
			` + props.OnShow + `
			
			if (this.duration > 0) {
				this.startDismissTimer();
			}
		},
		
		startDismissTimer() {
			let elapsed = 0;
			const interval = 100; // Update every 100ms
			
			this.progressTimer = setInterval(() => {
				elapsed += interval;
				this.progress = Math.max(0, 100 - (elapsed / this.duration * 100));
				
				if (elapsed >= this.duration) {
					this.dismiss();
				}
			}, interval);
		},
		
		dismiss() {
			if (this.timer) clearTimeout(this.timer);
			if (this.progressTimer) clearInterval(this.progressTimer);
			
			this.isVisible = false;
			` + props.OnHide + `
			
			// Remove from DOM after animation
			setTimeout(() => {
				this.$el.remove();
			}, 200);
		},
		
		pauseTimer() {
			if (this.progressTimer) {
				clearInterval(this.progressTimer);
			}
		},
		
		resumeTimer() {
			if (this.duration > 0 && this.progress > 0) {
				this.startDismissTimer();
			}
		}
	}`
}

func getErrorsJSON(errors []ErrorDetail) string {
	if len(errors) == 0 {
		return "[]"
	}
	// This would properly serialize errors to JSON
	return "[]"
}