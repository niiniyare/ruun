package molecules

import (
	"strings"
	"strconv"
	"github.com/niiniyare/ruun/views/components/atoms"
	"github.com/niiniyare/ruun/pkg/utils"
)

// ErrorType defines different types of errors
type ErrorType string

const (
	ErrorValidation ErrorType = "validation"
	ErrorNetwork    ErrorType = "network"
	ErrorServer     ErrorType = "server"
	ErrorAuth       ErrorType = "auth"
	ErrorNotFound   ErrorType = "notfound"
	ErrorPermission ErrorType = "permission"
	ErrorGeneral    ErrorType = "general"
)

// ErrorSeverity defines the severity level of errors
type ErrorSeverity string

const (
	SeverityLow      ErrorSeverity = "low"
	SeverityMedium   ErrorSeverity = "medium"
	SeverityHigh     ErrorSeverity = "high"
	SeverityCritical ErrorSeverity = "critical"
)

// ErrorDetail represents detailed error information
type ErrorDetail struct {
	Code        string                 `json:"code"`
	Message     string                 `json:"message"`
	Field       string                 `json:"field"`
	Type        ErrorType              `json:"type"`
	Severity    ErrorSeverity          `json:"severity"`
	Timestamp   string                 `json:"timestamp"`
	Context     map[string]any `json:"context"`
	Suggestions []string               `json:"suggestions"`
	HelpURL     string                 `json:"helpUrl"`
	Retryable   bool                   `json:"retryable"`
}

// ErrorBoundaryProps defines properties for error boundaries
type ErrorBoundaryProps struct {
	Errors       []ErrorDetail `json:"errors"`
	Title        string        `json:"title"`
	Description  string        `json:"description"`
	ShowDetails  bool          `json:"showDetails"`
	ShowStack    bool          `json:"showStack"`
	Recoverable  bool          `json:"recoverable"`
	AutoRetry    bool          `json:"autoRetry"`
	RetryCount   int           `json:"retryCount"`
	MaxRetries   int           `json:"maxRetries"`
	RetryDelay   int           `json:"retryDelay"` // milliseconds
	Dismissible  bool          `json:"dismissible"`
	Persistent   bool          `json:"persistent"` // Don't auto-dismiss
	Class        string        `json:"class"`
	ID           string        `json:"id"`
	// Actions
	Actions      []ErrorAction `json:"actions"`
	// Events
	OnRetry      string        `json:"onRetry"`
	OnDismiss    string        `json:"onDismiss"`
	OnReport     string        `json:"onReport"`
	// HTMX
	HXRetry      string        `json:"hxRetry"`
	HXReport     string        `json:"hxReport"`
}

// ErrorAction represents an action button for error handling
type ErrorAction struct {
	Text        string             `json:"text"`
	Icon        string             `json:"icon"`
	Variant     string              `json:"variant"`
	Action      string             `json:"action"` // "retry", "dismiss", "report", "custom"
	URL         string             `json:"url"`
	OnClick     string             `json:"onClick"`
}

// NotificationProps defines properties for notification toasts
type NotificationProps struct {
	Type         ErrorType     `json:"type"`
	Title        string        `json:"title"`
	Message      string        `json:"message"`
	Duration     int           `json:"duration"`     // Auto-dismiss time in ms (0 = no auto-dismiss)
	Position     string        `json:"position"`     // "top-right", "top-left", "bottom-right", "bottom-left", "top-center", "bottom-center"
	Dismissible  bool          `json:"dismissible"`
	Icon         string        `json:"icon"`
	Actions      []ErrorAction `json:"actions"`
	Class        string        `json:"class"`
	ID           string        `json:"id"`
	// Events
	OnShow       string        `json:"onShow"`
	OnHide       string        `json:"onHide"`
	OnAction     string        `json:"onAction"`
}

// errorBoundaryClasses generates classes for error boundaries using Basecoat alert
func errorBoundaryClasses(props ErrorBoundaryProps) string {
	return "alert-destructive"
}

// ErrorBoundary renders a comprehensive error boundary component
templ ErrorBoundary(props ErrorBoundaryProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ errorBoundaryClasses(props) }
		x-data={ getErrorBoundaryAlpineData(props) }
		x-init="initErrorBoundary()"
		x-show="isVisible"
		x-transition:enter="transition ease-out duration-300"
		x-transition:enter-start="opacity-0 transform scale-95"
		x-transition:enter-end="opacity-100 transform scale-100"
		x-transition:leave="transition ease-in duration-200"
		x-transition:leave-start="opacity-100 transform scale-100"
		x-transition:leave-end="opacity-0 transform scale-95"
	>
		// Header
		<div class="flex items-start justify-between">
			<div class="flex items-start gap-3">
				// Error icon
				<div class="shrink-0 mt-0.5">
					@atoms.Icon(atoms.IconProps{
						Name: getErrorIcon(props.Errors),
						Size: "lg",
					})
				</div>
				
				// Error content
				<div class="space-y-1">
					<h3 class="text-lg font-semibold">
						if props.Title != "" {
							{ props.Title }
						} else {
							{ getDefaultErrorTitle(props.Errors) }
						}
					</h3>
					if props.Description != "" {
						<p class="text-sm opacity-90">{ props.Description }</p>
					} else if len(props.Errors) > 0 {
						<p class="text-sm opacity-90">{ props.Errors[0].Message }</p>
					}
				</div>
			</div>

			// Dismiss button
			if props.Dismissible {
				<button
					class="shrink-0 p-1 rounded-sm opacity-70 hover:opacity-100 transition-opacity"
					x-on:click="dismiss()"
				>
					@atoms.Icon(atoms.IconProps{
						Name: "x",
						Size: "sm",
					})
				</button>
			}
		</div>

		// Error details
		if props.ShowDetails && len(props.Errors) > 1 {
			<div class="space-y-2">
				<button
					class="flex items-center gap-2 text-sm font-medium hover:underline"
					x-on:click="showDetails = !showDetails"
				>
					<span x-text="showDetails ? 'Hide Details' : 'Show Details (' + errors.length + ' errors)'"></span>
					@atoms.Icon(atoms.IconProps{
						Name: "chevron-down",
						Size: "sm",
					})
				</button>
				
				<div x-show="showDetails" x-transition class="space-y-2">
					for _, error := range props.Errors {
						@errorDetailItem(error)
					}
				</div>
			</div>
		}

		// Suggestions
		if len(props.Errors) > 0 && len(props.Errors[0].Suggestions) > 0 {
			<div class="space-y-2">
				<h4 class="text-sm font-medium">Suggestions:</h4>
				<ul class="text-sm space-y-1 ml-4">
					for _, suggestion := range props.Errors[0].Suggestions {
						<li class="list-disc">{ suggestion }</li>
					}
				</ul>
			</div>
		}

		// Auto-retry indicator
		if props.AutoRetry && props.RetryCount < props.MaxRetries {
			<div class="flex items-center gap-2 text-sm">
				@atoms.Spinner(atoms.SpinnerProps{Size: "sm"})
				<span x-text="`Retrying... (${retryCount}/${maxRetries})`"></span>
				<span x-text="`Next attempt in ${retryCountdown}s`"></span>
			</div>
		}

		// Actions
		if len(props.Actions) > 0 || props.Recoverable {
			<div class="flex items-center gap-2 pt-2">
				// Default recovery actions
				if props.Recoverable {
					<button
						class="btn-sm-primary"
						x-on:click="retry()"
					>
						@atoms.Icon(atoms.IconProps{Name: "refresh-cw", Size: "sm"})
						if props.RetryCount > 0 {
							Retry Again
						} else {
							Retry
						}
					</button>
				}

				// Custom actions
				for _, action := range props.Actions {
					@errorActionButton(action)
				}

				// Report error action
				if len(props.Errors) > 0 && props.Errors[0].HelpURL != "" {
					<a
						class="btn-sm-secondary"
						href={ props.Errors[0].HelpURL }
						target="_blank"
						rel="noopener noreferrer"
					>
						@atoms.Icon(atoms.IconProps{Name: "external-link", Size: "sm"})
						Get Help
					</a>
				}
			</div>
		}
	</div>
}

// errorDetailItem renders a single error detail
templ errorDetailItem(errorDetail ErrorDetail) {
	<div class="flex items-start gap-2 p-3 bg-background/50 rounded border text-sm">
		@atoms.Icon(atoms.IconProps{
			Name: getErrorTypeIcon(errorDetail.Type),
			Size: "sm",
		})
		<div class="space-y-1">
			<div class="font-medium">{ errorDetail.Message }</div>
			if errorDetail.Code != "" {
				<div class="text-xs text-muted-foreground">Code: { errorDetail.Code }</div>
			}
			if errorDetail.Field != "" {
				<div class="text-xs text-muted-foreground">Field: { errorDetail.Field }</div>
			}
		</div>
	</div>
}

// errorActionButton renders an error action button using Basecoat classes
templ errorActionButton(action ErrorAction) {
	<button
		class={ getActionButtonClass(action.Variant) }
		onclick={ templ.ComponentScript{Call: action.OnClick} }
	>
		if action.Icon != "" {
			@atoms.Icon(atoms.IconProps{Name: action.Icon, Size: "sm"})
		}
		{ action.Text }
	</button>
}

// Notification renders toast-style notifications
templ Notification(props NotificationProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ getNotificationClasses(props) }
		x-data={ getNotificationAlpineData(props) }
		x-init="initNotification()"
		x-show="isVisible"
		x-transition:enter="transition ease-out duration-300"
		x-transition:enter-start="opacity-0 transform translate-x-full"
		x-transition:enter-end="opacity-100 transform translate-x-0"
		x-transition:leave="transition ease-in duration-200"
		x-transition:leave-start="opacity-100 transform translate-x-0"
		x-transition:leave-end="opacity-0 transform translate-x-full"
		role="alert"
	>
		<div class="flex items-start gap-3">
			// Notification icon
			if props.Icon != "" || props.Type != "" {
				<div class="shrink-0 mt-0.5">
					@atoms.Icon(atoms.IconProps{
						Name: getNotificationIcon(props.Icon, props.Type),
						Size: "sm",
					})
				</div>
			}

			// Notification content
			<div class="flex-1 min-w-0">
				if props.Title != "" {
					<h4 class="text-sm font-medium">{ props.Title }</h4>
				}
				if props.Message != "" {
					<p class={ getMessageClasses(props.Title != "") }>
						{ props.Message }
					</p>
				}

				// Actions
				if len(props.Actions) > 0 {
					<div class="flex items-center gap-2 mt-3">
						for _, action := range props.Actions {
							<button
								class={ getActionButtonClass(action.Variant) }
								onclick={ templ.ComponentScript{Call: action.OnClick} }
							>
								{ action.Text }
							</button>
						}
					</div>
				}
			</div>

			// Dismiss button
			if props.Dismissible {
				<button
					class="shrink-0 p-1 rounded-sm opacity-70 hover:opacity-100 transition-opacity"
					x-on:click="dismiss()"
				>
					@atoms.Icon(atoms.IconProps{
						Name: "x",
						Size: "sm",
					})
				</button>
			}
		</div>

		// Progress bar for timed notifications
		if props.Duration > 0 {
			<div class="absolute bottom-0 left-0 right-0 h-1 bg-background/20 rounded-b">
				<div 
					class="h-full bg-current rounded-b transition-all linear"
					x-bind:style="`width: ${progress}%; transition-duration: 100ms;`"
				></div>
			</div>
		}
	</div>
}

// NotificationContainer renders a container for notifications
templ NotificationContainer(position string) {
	<div
		id={ "notifications-" + position }
		class={ getNotificationContainerClasses(position) }
		x-data="notificationContainer"
		x-init="initContainer()"
	>
		<template x-for="notification in notifications" x-key="notification.id">
			<div x-html="notification.html"></div>
		</template>
	</div>
}

// GlobalErrorHandler renders a global error handler
templ GlobalErrorHandler() {
	<div
		id="global-error-handler"
		x-data="globalErrorHandler"
		x-init="initGlobalHandler()"
		class="fixed inset-0 z-[100] pointer-events-none"
	>
		// Critical error overlay
		<div
			x-show="hasCriticalError"
			x-transition:enter="transition ease-out duration-300"
			x-transition:enter-start="opacity-0"
			x-transition:enter-end="opacity-100"
			class="absolute inset-0 bg-black/80 pointer-events-auto flex items-center justify-center p-6"
		>
			<div class="bg-background rounded-lg border max-w-md w-full p-6 space-y-4">
				<div class="flex items-center gap-3">
					@atoms.Icon(atoms.IconProps{
						Name: "alert-triangle",
						Size: "lg",
					})
					<div>
						<h2 class="text-lg font-semibold text-destructive">Critical Error</h2>
						<p class="text-sm text-muted-foreground">The application has encountered a serious error.</p>
					</div>
				</div>
				
				<div class="text-sm" x-text="criticalError.message"></div>
				
				<div class="flex items-center gap-2">
					<button
						class="btn-primary"
						onclick="window.location.reload()"
					>
						Reload Page
					</button>
					<button
						class="btn-outline"
						onclick="reportError(criticalError)"
					>
						Report Error
					</button>
				</div>
			</div>
		</div>
	</div>
}

// Helper functions

func getActionButtonClass(variant string) string {
	switch variant {
	case "primary":
		return "btn-sm-primary"
	case "secondary":
		return "btn-sm-secondary"
	case "destructive":
		return "btn-sm-destructive"
	default:
		return "btn-sm-outline"
	}
}

func getHighestSeverity(errors []ErrorDetail) ErrorSeverity {
	if len(errors) == 0 {
		return SeverityMedium
	}
	
	highest := SeverityLow
	for _, error := range errors {
		if error.Severity == SeverityCritical {
			return SeverityCritical
		}
		if error.Severity == SeverityHigh && highest != SeverityCritical {
			highest = SeverityHigh
		}
		if error.Severity == SeverityMedium && highest == SeverityLow {
			highest = SeverityMedium
		}
	}
	return highest
}

func getErrorIcon(errors []ErrorDetail) string {
	if len(errors) == 0 {
		return "alert-circle"
	}
	
	severity := getHighestSeverity(errors)
	switch severity {
	case SeverityCritical:
		return "x-circle"
	case SeverityHigh:
		return "alert-triangle"
	case SeverityMedium:
		return "alert-circle"
	case SeverityLow:
		return "info"
	default:
		return "alert-circle"
	}
}

func getErrorIconColor(errors []ErrorDetail) string {
	severity := getHighestSeverity(errors)
	switch severity {
	case SeverityCritical, SeverityHigh:
		return "text-destructive"
	case SeverityMedium:
		return "text-warning"
	case SeverityLow:
		return "text-muted-foreground"
	default:
		return "text-destructive"
	}
}

func getDefaultErrorTitle(errors []ErrorDetail) string {
	if len(errors) == 0 {
		return "An error occurred"
	}
	
	switch errors[0].Type {
	case ErrorValidation:
		return "Validation Error"
	case ErrorNetwork:
		return "Connection Error"
	case ErrorServer:
		return "Server Error"
	case ErrorAuth:
		return "Authentication Error"
	case ErrorNotFound:
		return "Not Found"
	case ErrorPermission:
		return "Permission Error"
	default:
		return "An error occurred"
	}
}

func getErrorTypeIcon(errorType ErrorType) string {
	switch errorType {
	case ErrorValidation:
		return "alert-circle"
	case ErrorNetwork:
		return "wifi-off"
	case ErrorServer:
		return "server"
	case ErrorAuth:
		return "lock"
	case ErrorNotFound:
		return "search"
	case ErrorPermission:
		return "shield"
	default:
		return "alert-circle"
	}
}

func getNotificationTypeIcon(notificationType ErrorType) string {
	switch notificationType {
	case ErrorValidation:
		return "alert-triangle"
	case ErrorNetwork:
		return "wifi-off"
	case ErrorServer:
		return "server"
	case ErrorAuth:
		return "lock"
	default:
		return "info"
	}
}

func getNotificationIconColor(notificationType ErrorType) string {
	switch notificationType {
	case ErrorValidation:
		return "text-warning"
	case ErrorNetwork:
		return "text-destructive"
	case ErrorServer:
		return "text-destructive"
	case ErrorAuth:
		return "text-destructive"
	default:
		return "text-muted-foreground"
	}
}

func getNotificationClasses(props NotificationProps) string {
	classes := []string{
		"relative", "max-w-sm", "w-full", "bg-background", "border", "rounded-lg", "shadow-lg", "p-4",
	}
	
	switch props.Type {
	case ErrorValidation:
		classes = append(classes, "border-warning/50")
	case ErrorNetwork, ErrorServer, ErrorAuth:
		classes = append(classes, "border-destructive/50")
	default:
		classes = append(classes, "border-border")
	}
	
	if props.Class != "" {
		classes = append(classes, props.Class)
	}
	
	return strings.Join(classes, " ")
}

func getNotificationContainerClasses(position string) string {
	classes := []string{"fixed", "z-50", "flex", "flex-col", "gap-2", "p-4", "pointer-events-none"}
	
	switch position {
	case "top-right":
		classes = append(classes, "top-0", "right-0")
	case "top-left":
		classes = append(classes, "top-0", "left-0")
	case "bottom-right":
		classes = append(classes, "bottom-0", "right-0")
	case "bottom-left":
		classes = append(classes, "bottom-0", "left-0")
	case "top-center":
		classes = append(classes, "top-0", "left-1/2", "transform", "-translate-x-1/2")
	case "bottom-center":
		classes = append(classes, "bottom-0", "left-1/2", "transform", "-translate-x-1/2")
	default:
		classes = append(classes, "top-0", "right-0")
	}
	
	return strings.Join(classes, " ")
}


// getMessageClasses returns the classes for message paragraph based on whether title exists
func getMessageClasses(hasTitle bool) string {
	if hasTitle {
		return "text-sm mt-1 text-muted-foreground"
	}
	return "text-sm"
}


// getNotificationIcon returns the notification icon, preferring custom icon over type-based icon
func getNotificationIcon(customIcon string, notificationType ErrorType) string {
	if customIcon != "" {
		return customIcon
	}
	return getNotificationTypeIcon(notificationType)
}

func getErrorBoundaryAlpineData(props ErrorBoundaryProps) string {
	return `{
		errors: ` + getErrorsJSON(props.Errors) + `,
		isVisible: true,
		showDetails: false,
		retryCount: ` + strconv.Itoa(props.RetryCount) + `,
		maxRetries: ` + strconv.Itoa(props.MaxRetries) + `,
		retryDelay: ` + strconv.Itoa(props.RetryDelay) + `,
		retryCountdown: 0,
		autoRetryTimer: null,
		
		initErrorBoundary() {
			if (` + strings.ToLower(strconv.FormatBool(props.AutoRetry)) + ` && this.retryCount < this.maxRetries) {
				this.startAutoRetry();
			}
		},
		
		async retry() {
			this.retryCount++;
			` + props.OnRetry + `
			
			if (this.retryCount >= this.maxRetries) {
				this.stopAutoRetry();
			}
		},
		
		dismiss() {
			this.isVisible = false;
			` + props.OnDismiss + `
		},
		
		reportError() {
			` + props.OnReport + `
		},
		
		startAutoRetry() {
			this.retryCountdown = this.retryDelay / 1000;
			this.autoRetryTimer = setInterval(() => {
				this.retryCountdown--;
				if (this.retryCountdown <= 0) {
					this.retry();
					if (this.retryCount < this.maxRetries) {
						this.retryCountdown = this.retryDelay / 1000;
					} else {
						this.stopAutoRetry();
					}
				}
			}, 1000);
		},
		
		stopAutoRetry() {
			if (this.autoRetryTimer) {
				clearInterval(this.autoRetryTimer);
				this.autoRetryTimer = null;
			}
		}
	}`
}

func getNotificationAlpineData(props NotificationProps) string {
	return `{
		isVisible: true,
		progress: 100,
		duration: ` + strconv.Itoa(props.Duration) + `,
		timer: null,
		progressTimer: null,
		
		initNotification() {
			` + props.OnShow + `
			
			if (this.duration > 0) {
				this.startDismissTimer();
			}
		},
		
		startDismissTimer() {
			let elapsed = 0;
			const interval = 100; // Update every 100ms
			
			this.progressTimer = setInterval(() => {
				elapsed += interval;
				this.progress = Math.max(0, 100 - (elapsed / this.duration * 100));
				
				if (elapsed >= this.duration) {
					this.dismiss();
				}
			}, interval);
		},
		
		dismiss() {
			if (this.timer) clearTimeout(this.timer);
			if (this.progressTimer) clearInterval(this.progressTimer);
			
			this.isVisible = false;
			` + props.OnHide + `
			
			// Remove from DOM after animation
			setTimeout(() => {
				this.$el.remove();
			}, 200);
		},
		
		pauseTimer() {
			if (this.progressTimer) {
				clearInterval(this.progressTimer);
			}
		},
		
		resumeTimer() {
			if (this.duration > 0 && this.progress > 0) {
				this.startDismissTimer();
			}
		}
	}`
}

func getErrorsJSON(errors []ErrorDetail) string {
	if len(errors) == 0 {
		return "[]"
	}
	// This would properly serialize errors to JSON
	return "[]"
}