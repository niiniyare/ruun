package molecules

import (
	"fmt"
	"strings"
	"github.com/niiniyare/ruun/pkg/utils"
	"github.com/niiniyare/ruun/views/components/atoms"
)

// FormField renders a comprehensive form field with token-based validation UI
// Supports three-tier theming (Primitives → Semantic → Components) with multi-tenant and dark mode
templ FormField(props FormFieldProps) {
	// Resolve tokens for the field using mapper-supplied resolved tokens
	<div 
		class={ formFieldContainerClasses(props) }
		style={ getFieldContainerStyles(props) }
		if props.Condition != "" {
			x-show={ props.Condition }
		}
		if props.ID != "" {
			data-field-id={ props.ID }
		}
		data-field-type={ string(props.Type) }
		data-validation-state={ props.ValidationState.String() }
		if props.ThemeID != "" {
			data-theme-id={ props.ThemeID }
		}
		if props.DarkMode {
			data-dark-mode="true"
		}
		aria-live="polite"
	>
		// Label section (enhanced with token-based styling)
		if props.Label != "" && props.Type != FormFieldCheckbox {
			@renderFieldLabel(props)
		}

		// Input wrapper for icons, validation status, and field content
		<div 
			class={ inputWrapperClasses(props) } 
			style={ getInputWrapperStyles(props) }
		>
			// Prefix icon or text
			if props.PrefixIcon != "" || props.Prefix != "" {
				@renderPrefix(props)
			}

			// Main input field based on type
			@renderFieldInput(props)

			// Real-time validation status indicator (NEW)
			@renderValidationStatus(props)

			// Suffix icon, copy button, or show password toggle
			if props.SuffixIcon != "" || props.Suffix != "" || props.CopyButton || (props.Type == FormFieldPassword && props.ShowPassword) {
				@renderSuffix(props)
			}

			// Loading indicator (legacy support)
			if props.Loading && props.ValidationState != validation.ValidationStateValidating {
				@renderLoadingIndicator(props)
			}
		</div>

		// Character count
		if props.CharacterCount && (props.Type == FormFieldText || props.Type == FormFieldTextarea) && props.MaxLength > 0 {
			@renderCharacterCount(props)
		}

		// Validation error messages with token-based styling (NEW)
		@renderValidationMessages(props)
		
		// Helper text, success, or warning messages
		@renderMessages(props)

		// Tooltip
		if props.Tooltip != "" {
			@renderTooltip(props)
		}
	</div>
}

// renderFieldLabel renders the field label with token-based styling
templ renderFieldLabel(props FormFieldProps) {
	<label
		if props.ID != "" {
			for={ props.ID }
		}
		class={ labelClasses(props) }
		style={ getLabelStyles(props) }
		if props.Tooltip != "" {
			data-tooltip={ props.Tooltip }
		}
	>
		// Icon before label
		if props.Icon != "" && props.IconPosition == "left" {
			<span class="inline-flex items-center mr-1.5">
				<i class={ "icon-" + props.Icon } aria-hidden="true"></i>
			</span>
		}

		// Label text
		<span>{ props.Label }</span>

		// Required indicator with token-based styling
		if props.Required {
			<span 
				class="field-required" 
				style={ getRequiredIndicatorStyles(props) }
				aria-label="required"
			>*</span>
		}

		// Icon after label
		if props.Icon != "" && props.IconPosition == "right" {
			<span class="inline-flex items-center ml-1.5">
				<i class={ "icon-" + props.Icon } aria-hidden="true"></i>
			</span>
		}

		// Info tooltip icon
		if props.Tooltip != "" {
			<span class="ml-1.5 inline-flex items-center cursor-help" title={ props.Tooltip }>
				<svg class="w-3.5 h-3.5 text-muted-foreground" fill="none" stroke="currentColor" viewBox="0 0 24 24">
					<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
				</svg>
			</span>
		}
	</label>
}

// renderValidationStatus shows real-time validation indicators based on validation state
templ renderValidationStatus(props FormFieldProps) {
	<div 
		class="validation-status" 
		role="status" 
		aria-hidden={ props.ValidationState == validation.ValidationStateIdle }
		style={ getValidationStatusContainerStyles(props) }
	>
		if props.ValidationState == validation.ValidationStateValidating || props.ValidationLoading {
			// LOADING STATE: Animated spinner with message from tokens
			<div 
				class="validation-loading"
				style={ getValidationLoadingStyles(props) }
				aria-label="Validating field"
				data-testid="validation-loading"
			>
				<span class="validation-spinner" aria-hidden="true">
					<svg class="animate-spin h-3 w-3" viewBox="0 0 24 24">
						<circle 
							class="opacity-25" 
							cx="12" 
							cy="12" 
							r="10" 
							stroke="currentColor" 
							stroke-width="4"
							fill="none"
						></circle>
						<path 
							class="opacity-75" 
							fill="currentColor" 
							d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
						></path>
					</svg>
				</span>
				<span class="validation-message">{ resolveValidationMessage(props, TokenValidationLoading) }</span>
			</div>
		} else if props.ValidationState == validation.ValidationStateValid {
			// SUCCESS STATE: Green checkmark with message from tokens
			<div 
				class="validation-success"
				style={ getValidationSuccessStyles(props) }
				aria-label="Field is valid"
				data-testid="validation-success"
			>
				<span class="validation-icon" aria-hidden="true">
					{ resolveValidationIcon(props, TokenValidationSuccess) }
				</span>
				<span class="validation-message">{ resolveValidationMessage(props, TokenValidationSuccess) }</span>
			</div>
		} else if props.ValidationState == validation.ValidationStateInvalid {
			// ERROR STATE: Red X with message from tokens
			<div 
				class="validation-error"
				style={ getValidationErrorStyles(props) }
				aria-label="Field has validation errors"
				data-testid="validation-error"
			>
				<span class="validation-icon" aria-hidden="true">
					{ resolveValidationIcon(props, TokenValidationError) }
				</span>
				<span class="validation-message">{ resolveValidationMessage(props, TokenValidationError) }</span>
			</div>
		} else if props.ValidationState == validation.ValidationStateWarning {
			// WARNING STATE: Amber warning with message from tokens
			<div 
				class="validation-warning"
				style={ getValidationWarningStyles(props) }
				aria-label="Field has warnings"
				data-testid="validation-warning"
			>
				<span class="validation-icon" aria-hidden="true">
					{ resolveValidationIcon(props, TokenValidationWarning) }
				</span>
				<span class="validation-message">{ resolveValidationMessage(props, TokenValidationWarning) }</span>
			</div>
		}
	</div>
}

// renderValidationMessages shows validation error messages with token-based styling
templ renderValidationMessages(props FormFieldProps) {
	if len(props.Errors) > 0 && (props.ValidationState == validation.ValidationStateInvalid || props.ErrorText != "") {
		<div 
			class="field-errors" 
			style={ getFieldErrorsStyles(props) }
			role="alert" 
			aria-live="assertive"
			data-testid="validation-errors"
		>
			for i, errorMsg := range props.Errors {
				<div 
					class="error-message"
					style={ getErrorMessageStyles(props) }
					data-error-index={ strconv.Itoa(i) }
				>
					<span class="error-icon" aria-hidden="true">
						{ resolveValidationIcon(props, TokenValidationError) }
					</span>
					<span class="error-text">{ errorMsg }</span>
				</div>
			}
		</div>
	} else if props.ErrorText != "" {
		// Legacy error text support
		<div 
			class="field-errors" 
			style={ getFieldErrorsStyles(props) }
			role="alert" 
			aria-live="assertive"
		>
			<div class="error-message" style={ getErrorMessageStyles(props) }>
				<span class="error-icon" aria-hidden="true">
					{ resolveValidationIcon(props, TokenValidationError) }
				</span>
				<span class="error-text">{ props.ErrorText }</span>
			</div>
		</div>
	}
}

// renderFieldInput renders the appropriate input based on field type
// Maintains backward compatibility with existing atom components
templ renderFieldInput(props FormFieldProps) {
	switch props.Type {
	case FormFieldText:
		@renderTextInput(props, atoms.InputTypeText)
	case FormFieldEmail:
		@renderTextInput(props, atoms.InputTypeEmail) 
	case FormFieldPassword:
		@renderPasswordInput(props)
	case FormFieldNumber:
		@renderNumberInput(props)
	case FormFieldSearch:
		@renderTextInput(props, atoms.InputTypeSearch)
	case FormFieldURL:
		@renderTextInput(props, atoms.InputTypeURL)
	case FormFieldTel:
		@renderTextInput(props, atoms.InputTypeTel)
	case FormFieldRadio:
		@renderRadioGroup(props)
	case FormFieldCheckbox:
		@renderCheckbox(props)
	case FormFieldCheckboxGroup:
		@renderCheckboxGroup(props)
	case FormFieldSelect:
		@renderSelect(props)
	case FormFieldMultiSelect:
		@renderMultiSelect(props)
	case FormFieldAutoComplete:
		@renderAutoComplete(props)
	case FormFieldDate:
		@renderDatePicker(props)
	case FormFieldTime:
		@renderTimePicker(props)
	case FormFieldDateTime:
		@renderDateTimePicker(props)
	case FormFieldDateRange:
		@renderDateRangePicker(props)
	case FormFieldTextarea:
		@renderTextarea(props)
	case FormFieldTags:
		@renderTags(props)
	case FormFieldFile:
		@renderFileInput(props)
	case FormFieldRange:
		@renderRangeInput(props)
	case FormFieldColor:
		@renderColorInput(props)
	default:
		@renderTextInput(props, atoms.InputTypeText)
	}
}

// renderTextInput renders standard text-based inputs with enhanced styling
templ renderTextInput(props FormFieldProps, inputType atoms.InputType) {
	@atoms.TextInput(atoms.InputProps{
		Type:         inputType,
		Size:         atoms.InputSize(props.Size),
		ID:           props.ID,
		Name:         props.Name,
		Value:        props.Value,
		Placeholder:  props.Placeholder,
		Required:     props.Required,
		Disabled:     props.Disabled,
		Readonly:     props.Readonly,
		Error:        props.ValidationState == validation.ValidationStateInvalid,
		MinLength:    props.MinLength,
		MaxLength:    props.MaxLength,
		Pattern:      props.Pattern,
		Autocomplete: props.Autocomplete,
		HXPost:       props.HXPost,
		HXGet:        props.HXGet,
		HXTarget:     props.HXTarget,
		HXSwap:       props.HXSwap,
		HXTrigger:    props.HXTrigger,
		AlpineModel:  props.AlpineModel,
		AlpineChange: props.AlpineChange,
		AlpineBlur:   props.AlpineBlur,
		AlpineFocus:  props.AlpineFocus,
		Class:        getInputValidationClasses(props),
	})
}

// ═══════════════════════════════════════════════════════════════════════════
// TOKEN-BASED STYLING HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════

// getFieldContainerStyles returns CSS styles for the field container using resolved tokens
func getFieldContainerStyles(props FormFieldProps) string {
	if len(props.Tokens) == 0 {
		return ""
	}
	
	var styles []string
	
	// Background from tokens
	if bgToken := props.Tokens[TokenFieldBackground]; bgToken != "" {
		styles = append(styles, fmt.Sprintf("background-color: %s", bgToken))
	}
	
	// Border radius from tokens
	if radiusToken := props.Tokens[TokenFieldRadius]; radiusToken != "" {
		styles = append(styles, fmt.Sprintf("border-radius: %s", radiusToken))
	}
	
	// Spacing from tokens
	if spacingToken := props.Tokens[TokenFieldSpacing]; spacingToken != "" {
		styles = append(styles, fmt.Sprintf("padding: %s", spacingToken))
	}
	
	// Shadow from tokens
	if shadowToken := props.Tokens[TokenFieldShadow]; shadowToken != "" {
		styles = append(styles, fmt.Sprintf("box-shadow: %s", shadowToken))
	}
	
	if len(styles) == 0 {
		return ""
	}
	
	return strings.Join(styles, "; ")
}

// getInputWrapperStyles returns CSS styles for the input wrapper using resolved tokens
func getInputWrapperStyles(props FormFieldProps) string {
	var styles []string
	
	// Base wrapper styles
	styles = append(styles, "position: relative", "display: flex", "align-items: center")
	
	return strings.Join(styles, "; ")
}

// getLabelStyles returns CSS styles for the label using resolved tokens
func getLabelStyles(props FormFieldProps) string {
	if len(props.Tokens) == 0 {
		return ""
	}
	
	var styles []string
	
	// Label color from tokens
	if colorToken := props.Tokens[TokenFieldLabel+".color"]; colorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", colorToken))
	}
	
	// Label size from tokens
	if sizeToken := props.Tokens[TokenFieldLabel+".size"]; sizeToken != "" {
		styles = append(styles, fmt.Sprintf("font-size: %s", sizeToken))
	}
	
	// Label weight from tokens
	if weightToken := props.Tokens[TokenFieldLabel+".weight"]; weightToken != "" {
		styles = append(styles, fmt.Sprintf("font-weight: %s", weightToken))
	}
	
	// Label spacing from tokens
	if spacingToken := props.Tokens[TokenFieldLabel+".spacing"]; spacingToken != "" {
		styles = append(styles, fmt.Sprintf("margin-bottom: %s", spacingToken))
	}
	
	if len(styles) == 0 {
		return ""
	}
	
	return strings.Join(styles, "; ")
}

// getRequiredIndicatorStyles returns styles for the required indicator
func getRequiredIndicatorStyles(props FormFieldProps) string {
	if len(props.Tokens) == 0 {
		return "color: #dc2626; margin-left: 0.25rem;"
	}
	
	var styles []string
	
	// Required indicator color from tokens  
	if requiredToken := props.Tokens[TokenFieldLabel+".required"]; requiredToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", requiredToken))
	} else {
		styles = append(styles, "color: #dc2626") // fallback
	}
	
	styles = append(styles, "margin-left: 0.25rem")
	
	return strings.Join(styles, "; ")
}

// getValidationStatusContainerStyles returns styles for the validation status container
func getValidationStatusContainerStyles(props FormFieldProps) string {
	var styles []string
	
	styles = append(styles, 
		"position: absolute",
		"right: 0.75rem",
		"top: 50%", 
		"transform: translateY(-50%)",
		"z-index: 10",
		"pointer-events: none",
	)
	
	return strings.Join(styles, "; ")
}

// getValidationLoadingStyles returns styles for validation loading state
func getValidationLoadingStyles(props FormFieldProps) string {
	var styles []string
	
	if colorToken := props.Tokens[TokenValidationLoading+".color"]; colorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", colorToken))
	} else {
		styles = append(styles, "color: #f59e0b") // fallback amber
	}
	
	styles = append(styles,
		"display: flex",
		"align-items: center",
		"gap: 0.25rem",
		"font-size: 0.75rem",
	)
	
	return strings.Join(styles, "; ")
}

// getValidationSuccessStyles returns styles for validation success state
func getValidationSuccessStyles(props FormFieldProps) string {
	var styles []string
	
	if colorToken := props.Tokens[TokenValidationSuccess+".color"]; colorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", colorToken))
	} else {
		styles = append(styles, "color: #16a34a") // fallback green
	}
	
	styles = append(styles,
		"display: flex", 
		"align-items: center",
		"gap: 0.25rem",
		"font-size: 0.75rem",
	)
	
	return strings.Join(styles, "; ")
}

// getValidationErrorStyles returns styles for validation error state
func getValidationErrorStyles(props FormFieldProps) string {
	var styles []string
	
	if colorToken := props.Tokens[TokenValidationError+".color"]; colorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", colorToken))
	} else {
		styles = append(styles, "color: #dc2626") // fallback red
	}
	
	styles = append(styles,
		"display: flex",
		"align-items: center", 
		"gap: 0.25rem",
		"font-size: 0.75rem",
	)
	
	return strings.Join(styles, "; ")
}

// getValidationWarningStyles returns styles for validation warning state
func getValidationWarningStyles(props FormFieldProps) string {
	var styles []string
	
	if colorToken := props.Tokens[TokenValidationWarning+".color"]; colorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", colorToken))
	} else {
		styles = append(styles, "color: #d97706") // fallback amber
	}
	
	styles = append(styles,
		"display: flex",
		"align-items: center",
		"gap: 0.25rem", 
		"font-size: 0.75rem",
	)
	
	return strings.Join(styles, "; ")
}

// getFieldErrorsStyles returns styles for the field errors container
func getFieldErrorsStyles(props FormFieldProps) string {
	var styles []string
	
	// Error container color
	if errorColorToken := props.Tokens[TokenValidationError+".color"]; errorColorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", errorColorToken))
	} else {
		styles = append(styles, "color: #dc2626") // fallback
	}
	
	styles = append(styles,
		"margin-top: 0.375rem",
		"display: flex",
		"flex-direction: column", 
		"gap: 0.25rem",
	)
	
	return strings.Join(styles, "; ")
}

// getErrorMessageStyles returns styles for individual error messages
func getErrorMessageStyles(props FormFieldProps) string {
	var styles []string
	
	styles = append(styles,
		"display: flex",
		"align-items: flex-start",
		"gap: 0.25rem",
		"font-size: 0.75rem",
		"line-height: 1.25",
	)
	
	return strings.Join(styles, "; ")
}

// getInputFieldStyles returns styles for input fields using tokens
func getInputFieldStyles(props FormFieldProps) string {
	if len(props.Tokens) == 0 {
		return ""
	}
	
	var styles []string
	
	// Field background
	if bgToken := props.Tokens[TokenFieldBackground]; bgToken != "" {
		styles = append(styles, fmt.Sprintf("background-color: %s", bgToken))
	}
	
	// Field border with validation state
	borderColor := getValidationStateBorderColor(props)
	if borderColor != "" {
		styles = append(styles, fmt.Sprintf("border-color: %s", borderColor))
	}
	
	// Field text color
	if textToken := props.Tokens[TokenFieldText]; textToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", textToken))
	}
	
	// Field border radius
	if radiusToken := props.Tokens[TokenFieldRadius]; radiusToken != "" {
		styles = append(styles, fmt.Sprintf("border-radius: %s", radiusToken))
	}
	
	if len(styles) == 0 {
		return ""
	}
	
	return strings.Join(styles, "; ")
}

// getValidationStateBorderColor returns border color based on validation state and tokens
func getValidationStateBorderColor(props FormFieldProps) string {
	switch props.ValidationState {
	case validation.ValidationStateValidating:
		if color := props.Tokens[TokenValidationLoading+".color"]; color != "" {
			return color
		}
		return "#f59e0b" // fallback amber
	case validation.ValidationStateValid:
		if color := props.Tokens[TokenValidationSuccess+".color"]; color != "" {
			return color
		}
		return "#16a34a" // fallback green
	case validation.ValidationStateInvalid:
		if color := props.Tokens[TokenValidationError+".color"]; color != "" {
			return color
		}
		return "#dc2626" // fallback red
	case validation.ValidationStateWarning:
		if color := props.Tokens[TokenValidationWarning+".color"]; color != "" {
			return color
		}
		return "#d97706" // fallback amber
	default:
		if borderToken := props.Tokens[TokenFieldBorder+".default"]; borderToken != "" {
			return borderToken
		}
		return "#e5e7eb" // fallback gray
	}
}

// resolveValidationMessage resolves validation message from tokens with fallback
func resolveValidationMessage(props FormFieldProps, tokenKey string) string {
	// Try to resolve message from tokens
	if messageToken := props.Tokens[tokenKey+".message"]; messageToken != "" {
		return messageToken
	}
	
	// Fallback messages based on token type
	switch tokenKey {
	case TokenValidationLoading:
		return "Validating..."
	case TokenValidationSuccess:
		return "Valid"
	case TokenValidationError:
		return "Invalid"
	case TokenValidationWarning:
		return "Warning"
	default:
		return ""
	}
}

// resolveValidationIcon resolves validation icon from tokens with fallback
func resolveValidationIcon(props FormFieldProps, tokenKey string) string {
	// Try to resolve icon from tokens
	if iconToken := props.Tokens[tokenKey+".icon"]; iconToken != "" {
		return iconToken
	}
	
	// Fallback icons based on token type
	switch tokenKey {
	case TokenValidationLoading:
		return "⟳"
	case TokenValidationSuccess:
		return "✓"
	case TokenValidationError:
		return "✗"
	case TokenValidationWarning:
		return "⚠"
	default:
		return ""
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// CSS CLASS GENERATION (LEGACY SUPPORT + VALIDATION CLASSES)
// ═══════════════════════════════════════════════════════════════════════════

// formFieldContainerClasses returns container classes with validation state
func formFieldContainerClasses(props FormFieldProps) string {
	classes := formFieldClasses(props)
	
	// Add validation state classes for CSS fallback
	validationClass := getValidationStateClass(props.ValidationState)
	if validationClass != "" {
		classes += " " + validationClass
	}
	
	return classes
}

// getInputValidationClasses returns input-specific validation classes
func getInputValidationClasses(props FormFieldProps) string {
	var classes []string
	
	// Add validation state class
	switch props.ValidationState {
	case validation.ValidationStateValidating:
		classes = append(classes, "field-validating")
	case validation.ValidationStateValid:
		classes = append(classes, "field-valid") 
	case validation.ValidationStateInvalid:
		classes = append(classes, "field-invalid")
	case validation.ValidationStateWarning:
		classes = append(classes, "field-warning")
	}
	
	// Add existing input class
	if props.InputClass != "" {
		classes = append(classes, props.InputClass)
	}
	
	return strings.Join(classes, " ")
}

// getValidationStateClass returns CSS class for validation state (legacy fallback)
func getValidationStateClass(state validation.ValidationState) string {
	switch state {
	case validation.ValidationStateValidating:
		return "validating"
	case validation.ValidationStateValid:
		return "valid"
	case validation.ValidationStateInvalid:
		return "invalid"
	case validation.ValidationStateWarning:
		return "warning"
	default:
		return "idle"
	}
}

// ═══════════════════════════════════════════════════════════════════════════
// EXISTING RENDER FUNCTIONS (maintained for backward compatibility)
// These functions are referenced but would be implemented elsewhere
// ═══════════════════════════════════════════════════════════════════════════

templ renderPrefix(props FormFieldProps) {
	<span class="field-prefix">
		if props.PrefixIcon != "" {
			<i class={ "icon-" + props.PrefixIcon }></i>
		}
		if props.Prefix != "" {
			<span>{ props.Prefix }</span>
		}
	</span>
}

templ renderSuffix(props FormFieldProps) {
	<span class="field-suffix">
		if props.SuffixIcon != "" {
			<i class={ "icon-" + props.SuffixIcon }></i>
		}
		if props.Suffix != "" {
			<span>{ props.Suffix }</span>
		}
	</span>
}

templ renderLoadingIndicator(props FormFieldProps) {
	<span class="field-loading">
		<span class="spinner" aria-hidden="true"></span>
	</span>
}

templ renderCharacterCount(props FormFieldProps) {
	<div class="character-count">
		<span>{ strconv.Itoa(len(props.Value)) }/{ strconv.Itoa(props.MaxLength) }</span>
	</div>
}

templ renderMessages(props FormFieldProps) {
	if props.HelpText != "" {
		<div class="field-help" style={ getHelpTextStyles(props) }>{ props.HelpText }</div>
	}
	if props.SuccessText != "" {
		<div class="field-success">{ props.SuccessText }</div>
	}
	if props.WarningText != "" {
		<div class="field-warning-text">{ props.WarningText }</div>
	}
}

templ renderTooltip(props FormFieldProps) {
	<div class="field-tooltip" data-tooltip={ props.Tooltip }>
		<span class="tooltip-icon">?</span>
	</div>
}

// getHelpTextStyles returns styles for help text using tokens
func getHelpTextStyles(props FormFieldProps) string {
	if len(props.Tokens) == 0 {
		return "color: #6b7280; font-size: 0.75rem; margin-top: 0.25rem;"
	}
	
	var styles []string
	
	// Help text color from tokens
	if colorToken := props.Tokens[TokenFieldHelp+".color"]; colorToken != "" {
		styles = append(styles, fmt.Sprintf("color: %s", colorToken))
	}
	
	// Help text size from tokens
	if sizeToken := props.Tokens[TokenFieldHelp+".size"]; sizeToken != "" {
		styles = append(styles, fmt.Sprintf("font-size: %s", sizeToken))
	}
	
	// Help text spacing from tokens
	if spacingToken := props.Tokens[TokenFieldHelp+".spacing"]; spacingToken != "" {
		styles = append(styles, fmt.Sprintf("margin-top: %s", spacingToken))
	}
	
	// Fallback styles if no tokens
	if len(styles) == 0 {
		return "color: #6b7280; font-size: 0.75rem; margin-top: 0.25rem;"
	}
	
	return strings.Join(styles, "; ")
}

// Placeholder implementations for missing input types - these would be fully implemented
templ renderPasswordInput(props FormFieldProps) {
	@renderTextInput(props, atoms.InputTypePassword)
}

templ renderNumberInput(props FormFieldProps) {
	@renderTextInput(props, atoms.InputTypeNumber)
}

templ renderRadioGroup(props FormFieldProps) {
	<div>Radio Group - Implementation needed</div>
}

templ renderCheckbox(props FormFieldProps) {
	<div>Checkbox - Implementation needed</div>
}

templ renderCheckboxGroup(props FormFieldProps) {
	<div>Checkbox Group - Implementation needed</div>
}

templ renderSelect(props FormFieldProps) {
	<div>Select - Implementation needed</div>
}

templ renderMultiSelect(props FormFieldProps) {
	<div>Multi Select - Implementation needed</div>
}

templ renderAutoComplete(props FormFieldProps) {
	<div>Auto Complete - Implementation needed</div>
}

templ renderDatePicker(props FormFieldProps) {
	<div>Date Picker - Implementation needed</div>
}

templ renderTimePicker(props FormFieldProps) {
	<div>Time Picker - Implementation needed</div>
}

templ renderDateTimePicker(props FormFieldProps) {
	<div>DateTime Picker - Implementation needed</div>
}

templ renderDateRangePicker(props FormFieldProps) {
	<div>Date Range Picker - Implementation needed</div>
}

templ renderTextarea(props FormFieldProps) {
	<div>Textarea - Implementation needed</div>
}

templ renderTags(props FormFieldProps) {
	<div>Tags - Implementation needed</div>
}

templ renderFileInput(props FormFieldProps) {
	<div>File Input - Implementation needed</div>
}

templ renderRangeInput(props FormFieldProps) {
	<div>Range Input - Implementation needed</div>
}

templ renderColorInput(props FormFieldProps) {
	<div>Color Input - Implementation needed</div>
}