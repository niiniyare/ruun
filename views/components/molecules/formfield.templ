package molecules

import (
	"strings"
	"strconv"
	"github.com/niiniyare/erp/views/components/atoms"
)

// FormFieldType defines the input type for the form field
type FormFieldType string

const (
	FormFieldText     FormFieldType = "text"
	FormFieldEmail    FormFieldType = "email"
	FormFieldPassword FormFieldType = "password"
	FormFieldNumber   FormFieldType = "number"
	FormFieldSearch   FormFieldType = "search"
	FormFieldTextarea FormFieldType = "textarea"
	FormFieldSelect   FormFieldType = "select"
	FormFieldTags     FormFieldType = "tags"
)

// FormFieldSize defines the size variants for form fields
type FormFieldSize string

const (
	FormFieldSizeSM FormFieldSize = "sm"
	FormFieldSizeMD FormFieldSize = "md"
	FormFieldSizeLG FormFieldSize = "lg"
)

// SelectOption represents an option for select fields
type SelectOption struct {
	Value    string
	Label    string
	Disabled bool
	Selected bool
}

// FormFieldProps defines the properties for the FormField component
type FormFieldProps struct {
	Type         FormFieldType
	Size         FormFieldSize
	ID           string
	Name         string
	Label        string
	Value        string
	Placeholder  string
	HelpText     string
	ErrorText    string
	Required     bool
	Disabled     bool
	Readonly     bool
	Class        string
	// Input-specific props
	MinLength    int
	MaxLength    int
	Min          string
	Max          string
	Step         string
	Pattern      string
	Autocomplete string
	// Select-specific props
	Options      []SelectOption
	Multiple     bool
	// Textarea-specific props
	Rows         int
	Cols         int
	// Tags-specific props
	TagsEditable bool
	TagsOptions  []SelectOption
	// HTMX attributes
	HXPost       string
	HXGet        string
	HXTarget     string
	HXSwap       string
	HXTrigger    string
	// Alpine.js attributes
	AlpineModel  string
	AlpineChange string
	AlpineBlur   string
	AlpineFocus  string
}

// formFieldClasses generates container classes for the form field
func formFieldClasses(props FormFieldProps) string {
	var classes []string

	// Base classes
	classes = append(classes, "space-y-2")

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return strings.Join(classes, " ")
}

// labelClasses generates classes for the label
func labelClasses(props FormFieldProps) string {
	var classes []string

	// Base classes
	classes = append(classes, "block", "text-sm", "font-medium", "leading-none")

	// Required indicator
	if props.Required {
		classes = append(classes, "after:content-['*']", "after:ml-0.5", "after:text-destructive")
	}

	// Error state
	if props.ErrorText != "" {
		classes = append(classes, "text-destructive")
	} else {
		classes = append(classes, "text-foreground")
	}

	return strings.Join(classes, " ")
}

// helpTextClasses generates classes for help text
func helpTextClasses(props FormFieldProps) string {
	var classes []string

	// Base classes
	classes = append(classes, "text-xs")

	// Color based on state
	if props.ErrorText != "" {
		classes = append(classes, "text-destructive")
	} else {
		classes = append(classes, "text-muted-foreground")
	}

	return strings.Join(classes, " ")
}

// FormField renders a complete form field with label, input, and help text
templ FormField(props FormFieldProps) {
	<div class={ formFieldClasses(props) }>
		// Label
		if props.Label != "" {
			<label
				if props.ID != "" {
					for={ props.ID }
				}
				class={ labelClasses(props) }
			>
				{ props.Label }
			</label>
		}

		// Input based on type
		switch props.Type {
		case FormFieldText:
			@atoms.TextInput(atoms.InputProps{
				Type:         atoms.InputTypeText,
				Size:         atoms.InputSize(props.Size),
				ID:           props.ID,
				Name:         props.Name,
				Value:        props.Value,
				Placeholder:  props.Placeholder,
				Required:     props.Required,
				Disabled:     props.Disabled,
				Readonly:     props.Readonly,
				Error:        props.ErrorText != "",
				MinLength:    props.MinLength,
				MaxLength:    props.MaxLength,
				Pattern:      props.Pattern,
				Autocomplete: props.Autocomplete,
				HXPost:       props.HXPost,
				HXGet:        props.HXGet,
				HXTarget:     props.HXTarget,
				HXSwap:       props.HXSwap,
				HXTrigger:    props.HXTrigger,
				AlpineModel:  props.AlpineModel,
				AlpineChange: props.AlpineChange,
				AlpineBlur:   props.AlpineBlur,
				AlpineFocus:  props.AlpineFocus,
			})
		case FormFieldEmail:
			@atoms.EmailInput(atoms.InputProps{
				Size:         atoms.InputSize(props.Size),
				ID:           props.ID,
				Name:         props.Name,
				Value:        props.Value,
				Placeholder:  props.Placeholder,
				Required:     props.Required,
				Disabled:     props.Disabled,
				Readonly:     props.Readonly,
				Error:        props.ErrorText != "",
				MaxLength:    props.MaxLength,
				HXPost:       props.HXPost,
				HXGet:        props.HXGet,
				HXTarget:     props.HXTarget,
				HXSwap:       props.HXSwap,
				HXTrigger:    props.HXTrigger,
				AlpineModel:  props.AlpineModel,
				AlpineChange: props.AlpineChange,
				AlpineBlur:   props.AlpineBlur,
				AlpineFocus:  props.AlpineFocus,
			})
		case FormFieldPassword:
			@atoms.PasswordInput(atoms.InputProps{
				Size:         atoms.InputSize(props.Size),
				ID:           props.ID,
				Name:         props.Name,
				Value:        props.Value,
				Placeholder:  props.Placeholder,
				Required:     props.Required,
				Disabled:     props.Disabled,
				Readonly:     props.Readonly,
				Error:        props.ErrorText != "",
				MinLength:    props.MinLength,
				MaxLength:    props.MaxLength,
				HXPost:       props.HXPost,
				HXGet:        props.HXGet,
				HXTarget:     props.HXTarget,
				HXSwap:       props.HXSwap,
				HXTrigger:    props.HXTrigger,
				AlpineModel:  props.AlpineModel,
				AlpineChange: props.AlpineChange,
				AlpineBlur:   props.AlpineBlur,
				AlpineFocus:  props.AlpineFocus,
			})
		case FormFieldNumber:
			@atoms.NumberInput(atoms.InputProps{
				Size:         atoms.InputSize(props.Size),
				ID:           props.ID,
				Name:         props.Name,
				Value:        props.Value,
				Placeholder:  props.Placeholder,
				Required:     props.Required,
				Disabled:     props.Disabled,
				Readonly:     props.Readonly,
				Error:        props.ErrorText != "",
				Min:          props.Min,
				Max:          props.Max,
				Step:         props.Step,
				HXPost:       props.HXPost,
				HXGet:        props.HXGet,
				HXTarget:     props.HXTarget,
				HXSwap:       props.HXSwap,
				HXTrigger:    props.HXTrigger,
				AlpineModel:  props.AlpineModel,
				AlpineChange: props.AlpineChange,
				AlpineBlur:   props.AlpineBlur,
				AlpineFocus:  props.AlpineFocus,
			})
		case FormFieldSearch:
			@atoms.SearchInput(atoms.InputProps{
				Size:         atoms.InputSize(props.Size),
				ID:           props.ID,
				Name:         props.Name,
				Value:        props.Value,
				Placeholder:  props.Placeholder,
				Required:     props.Required,
				Disabled:     props.Disabled,
				Readonly:     props.Readonly,
				Error:        props.ErrorText != "",
				MaxLength:    props.MaxLength,
				HXPost:       props.HXPost,
				HXGet:        props.HXGet,
				HXTarget:     props.HXTarget,
				HXSwap:       props.HXSwap,
				HXTrigger:    props.HXTrigger,
				AlpineModel:  props.AlpineModel,
				AlpineChange: props.AlpineChange,
				AlpineBlur:   props.AlpineBlur,
				AlpineFocus:  props.AlpineFocus,
			})
		case FormFieldTextarea:
			@textareaInput(props)
		case FormFieldSelect:
			@selectInput(props)
		case FormFieldTags:
			@tagsInput(props)
		}

		// Help text or error message
		if props.ErrorText != "" {
			<p class={ helpTextClasses(props) }>
				{ props.ErrorText }
			</p>
		} else if props.HelpText != "" {
			<p class={ helpTextClasses(props) }>
				{ props.HelpText }
			</p>
		}
	</div>
}

// textareaInput renders a textarea input
templ textareaInput(props FormFieldProps) {
	<textarea
		if props.ID != "" {
			id={ props.ID }
		}
		if props.Name != "" {
			name={ props.Name }
		}
		if props.Placeholder != "" {
			placeholder={ props.Placeholder }
		}
		if props.Required {
			required
		}
		if props.Disabled {
			disabled
		}
		if props.Readonly {
			readonly
		}
		if props.Rows > 0 {
			rows={ strconv.Itoa(props.Rows) }
		} else {
			rows="3"
		}
		if props.Cols > 0 {
			cols={ strconv.Itoa(props.Cols) }
		}
		if props.MinLength > 0 {
			minlength={ strconv.Itoa(props.MinLength) }
		}
		if props.MaxLength > 0 {
			maxlength={ strconv.Itoa(props.MaxLength) }
		}
		class={ textareaClasses(props) }
		if props.HXPost != "" {
			hx-post={ props.HXPost }
		}
		if props.HXGet != "" {
			hx-get={ props.HXGet }
		}
		if props.HXTarget != "" {
			hx-target={ props.HXTarget }
		}
		if props.HXSwap != "" {
			hx-swap={ props.HXSwap }
		}
		if props.HXTrigger != "" {
			hx-trigger={ props.HXTrigger }
		}
		if props.AlpineModel != "" {
			x-model={ props.AlpineModel }
		}
		if props.AlpineChange != "" {
			x-on:change={ props.AlpineChange }
		}
		if props.AlpineBlur != "" {
			x-on:blur={ props.AlpineBlur }
		}
		if props.AlpineFocus != "" {
			x-on:focus={ props.AlpineFocus }
		}
		if props.ErrorText != "" {
			aria-invalid="true"
		}
	>{ props.Value }</textarea>
}

// textareaClasses generates classes for textarea
func textareaClasses(props FormFieldProps) string {
	var classes []string

	// Base classes
	classes = append(classes,
		"flex",
		"w-full",
		"rounded-md",
		"border",
		"border-input",
		"bg-background",
		"px-3",
		"py-2",
		"text-sm",
		"ring-offset-background",
		"placeholder:text-muted-foreground",
		"focus-visible:outline-none",
		"focus-visible:ring-2",
		"focus-visible:ring-ring",
		"focus-visible:ring-offset-2",
		"disabled:cursor-not-allowed",
		"disabled:opacity-50",
		"resize-none",
	)

	// Error state
	if props.ErrorText != "" {
		classes = append(classes, "border-destructive", "focus-visible:ring-destructive")
	}

	return strings.Join(classes, " ")
}

// selectInput renders a select dropdown
templ selectInput(props FormFieldProps) {
	<select
		if props.ID != "" {
			id={ props.ID }
		}
		if props.Name != "" {
			name={ props.Name }
		}
		if props.Required {
			required
		}
		if props.Disabled {
			disabled
		}
		if props.Multiple {
			multiple
		}
		class={ selectClasses(props) }
		if props.HXPost != "" {
			hx-post={ props.HXPost }
		}
		if props.HXGet != "" {
			hx-get={ props.HXGet }
		}
		if props.HXTarget != "" {
			hx-target={ props.HXTarget }
		}
		if props.HXSwap != "" {
			hx-swap={ props.HXSwap }
		}
		if props.HXTrigger != "" {
			hx-trigger={ props.HXTrigger }
		}
		if props.AlpineModel != "" {
			x-model={ props.AlpineModel }
		}
		if props.AlpineChange != "" {
			x-on:change={ props.AlpineChange }
		}
		if props.ErrorText != "" {
			aria-invalid="true"
		}
	>
		if props.Placeholder != "" && !props.Multiple {
			<option value="" disabled selected={ props.Value == "" }>
				{ props.Placeholder }
			</option>
		}
		for _, option := range props.Options {
			<option
				value={ option.Value }
				if option.Disabled {
					disabled
				}
				if option.Selected || option.Value == props.Value {
					selected
				}
			>
				{ option.Label }
			</option>
		}
	</select>
}

// selectClasses generates classes for select
func selectClasses(props FormFieldProps) string {
	var classes []string

	// Base classes
	classes = append(classes,
		"flex",
		"w-full",
		"rounded-md",
		"border",
		"border-input",
		"bg-background",
		"px-3",
		"py-2",
		"text-sm",
		"ring-offset-background",
		"focus-visible:outline-none",
		"focus-visible:ring-2",
		"focus-visible:ring-ring",
		"focus-visible:ring-offset-2",
		"disabled:cursor-not-allowed",
		"disabled:opacity-50",
	)

	// Add height based on size
	switch props.Size {
	case FormFieldSizeSM:
		classes = append(classes, "h-8")
	case FormFieldSizeMD:
		classes = append(classes, "h-10")
	case FormFieldSizeLG:
		classes = append(classes, "h-11")
	default:
		classes = append(classes, "h-10")
	}

	// Error state
	if props.ErrorText != "" {
		classes = append(classes, "border-destructive", "focus-visible:ring-destructive")
	}

	return strings.Join(classes, " ")
}

// getTagsErrorClass returns the error class for tags input
func getTagsErrorClass(hasError bool) string {
	if hasError {
		return "border-destructive focus-within:ring-destructive"
	}
	return ""
}

// getSelectableTagsErrorClass returns the error class for selectable tags
func getSelectableTagsErrorClass(hasError bool) string {
	if hasError {
		return "border-destructive"
	}
	return ""
}

// tagsInput renders a tags input using the Tags component
templ tagsInput(props FormFieldProps) {
	if props.TagsEditable {
		@atoms.EditableTags(atoms.TagsProps{
			Placeholder: props.Placeholder,
			Class:       getTagsErrorClass(props.ErrorText != ""),
			ID:          props.ID,
			Name:        props.Name,
			HXPost:      props.HXPost,
			HXGet:       props.HXGet,
			HXTarget:    props.HXTarget,
			HXSwap:      props.HXSwap,
		})
	} else {
		@atoms.SelectableTags(atoms.TagsProps{
			Tags:     convertSelectOptionsToTagProps(props.TagsOptions),
			Class:    getSelectableTagsErrorClass(props.ErrorText != ""),
			ID:       props.ID,
			HXPost:   props.HXPost,
			HXGet:    props.HXGet,
			HXTarget: props.HXTarget,
			HXSwap:   props.HXSwap,
		})
	}
}

// Helper function to convert SelectOptions to TagProps
func convertSelectOptionsToTagProps(options []SelectOption) []atoms.TagProps {
	tags := make([]atoms.TagProps, len(options))
	for i, option := range options {
		tags[i] = atoms.TagProps{
			Text:     option.Label,
			Value:    option.Value,
			Selected: option.Selected,
			Disabled: option.Disabled,
		}
	}
	return tags
}