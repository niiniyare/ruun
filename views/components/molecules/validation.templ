package molecules

import (
	"strings"
	"github.com/niiniyare/ruun/views/components/atoms"
)

// ValidationMessageType defines the type of validation message
type ValidationMessageType string

const (
	ValidationSuccess ValidationMessageType = "success"
	ValidationWarning ValidationMessageType = "warning"
	ValidationError   ValidationMessageType = "error"
	ValidationInfo    ValidationMessageType = "info"
)

// ValidationRule represents a validation rule
type ValidationRule struct {
	Name     string `json:"name"`
	Required bool   `json:"required"`
	Pattern  string `json:"pattern,omitempty"`
	MinLength int   `json:"minLength,omitempty"`
	MaxLength int   `json:"maxLength,omitempty"`
	Min      int    `json:"min,omitempty"`
	Max      int    `json:"max,omitempty"`
	Message  string `json:"message,omitempty"`
}

// ValidationResult represents the result of validation
type ValidationResult struct {
	Valid       bool                   `json:"valid"`
	FieldName   string                 `json:"fieldName"`
	Messages    []ValidationMessage    `json:"messages"`
	Errors      []string               `json:"errors"`
	Warnings    []string               `json:"warnings"`
	Suggestions []string               `json:"suggestions"`
}

// ValidationMessage represents a single validation message
type ValidationMessage struct {
	Type        ValidationMessageType  `json:"type"`
	Message     string                 `json:"message"`
	Field       string                 `json:"field"`
	Code        string                 `json:"code"`
	Details     map[string]any `json:"details"`
}

// ValidationProps defines properties for validation components
type ValidationProps struct {
	FieldName    string              `json:"fieldName"`
	Rules        []ValidationRule    `json:"rules"`
	Messages     []ValidationMessage `json:"messages"`
	ShowSuccess  bool                `json:"showSuccess"`
	ShowWarnings bool                `json:"showWarnings"`
	Inline       bool                `json:"inline"`       // Show inline vs block
	Position     string              `json:"position"`     // "bottom", "right", "top"
	Class        string              `json:"class"`
	ID           string              `json:"id"`
	// Real-time validation
	ValidateOnBlur   bool            `json:"validateOnBlur"`
	ValidateOnChange bool            `json:"validateOnChange"`
	ValidateOnSubmit bool            `json:"validateOnSubmit"`
	// HTMX attributes for server validation
	HXPost       string              `json:"hxPost"`
	HXGet        string              `json:"hxGet"`
	HXTarget     string              `json:"hxTarget"`
	HXSwap       string              `json:"hxSwap"`
	HXTrigger    string              `json:"hxTrigger"`
	// Alpine.js integration
	AlpineData   string              `json:"alpineData"`
	// Events
	OnValidate   string              `json:"onValidate"`
	OnError      string              `json:"onError"`
	OnSuccess    string              `json:"onSuccess"`
}

// validationClasses generates classes for validation containers
func validationClasses(props ValidationProps) string {
	var classes []string

	// Base classes
	if props.Inline {
		classes = append(classes, "inline-flex", "items-center", "gap-1")
	} else {
		classes = append(classes, "space-y-1")
	}

	// Position classes
	switch props.Position {
	case "right":
		classes = append(classes, "ml-2")
	case "top":
		classes = append(classes, "mb-2")
	default:
		classes = append(classes, "mt-1")
	}

	// Custom classes
	if props.Class != "" {
		classes = append(classes, props.Class)
	}

	return strings.Join(classes, " ")
}

// ValidationMessages renders validation messages for a field
templ ValidationMessages(props ValidationProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ validationClasses(props) }
		if props.AlpineData != "" {
			x-data={ props.AlpineData }
		} else {
			x-data={ getValidationAlpineData(props) }
		}
		if props.HXPost != "" || props.HXGet != "" {
			hx-post={ props.HXPost }
			hx-get={ props.HXGet }
			hx-target={ getHXTargetValue(props.HXTarget) }
			hx-swap={ getValidationHXSwapValue(props.HXSwap) }
			hx-trigger={ getValidationHXTriggerValue(props.HXTrigger) }
		}
	>
		// Error messages
		for _, message := range props.Messages {
			if message.Type == ValidationError {
				@validationMessage(message, props.Inline)
			}
		}

		// Warning messages
		if props.ShowWarnings {
			for _, message := range props.Messages {
				if message.Type == ValidationWarning {
					@validationMessage(message, props.Inline)
				}
			}
		}

		// Success message
		if props.ShowSuccess {
			for _, message := range props.Messages {
				if message.Type == ValidationSuccess {
					@validationMessage(message, props.Inline)
				}
			}
		}

		// Info messages
		for _, message := range props.Messages {
			if message.Type == ValidationInfo {
				@validationMessage(message, props.Inline)
			}
		}

		// Alpine.js dynamic messages
		<template x-for="message in validationMessages" x-key="message.code">
			<div x-bind:class="getMessageClasses(message)" x-show="shouldShowMessage(message)">
				<span x-text="message.message"></span>
			</div>
		</template>
	</div>
}

// validationMessage renders a single validation message
templ validationMessage(message ValidationMessage, inline bool) {
	<div class={ getValidationMessageClasses(message, inline) }>
		<div class="flex items-start gap-2">
			@atoms.Icon(atoms.IconProps{
				Name:  getValidationIcon(message.Type),
				Size:  atoms.IconSizeXS,
				ClassName: "mt-0.5 shrink-0 " + getValidationIconColor(message.Type),
			})
			<span class="text-sm">{ message.Message }</span>
		</div>
	</div>
}

// FieldValidator renders a validation container for form fields
templ FieldValidator(fieldName string, rules []ValidationRule, children ...templ.Component) {
	<div
		class="field-validator"
		x-data={ getFieldValidatorAlpineData(fieldName, rules) }
		x-init="initValidator()"
	>
		// Field content
		<div class="relative">
			for _, child := range children {
				@child
			}
			
			// Validation indicator
			<div class="absolute right-3 top-1/2 transform -translate-y-1/2">
				<div x-show="isValidating" class="text-muted-foreground">
					@atoms.Icon(atoms.IconProps{Name: "loader", Size: atoms.IconSizeXS, ClassName: "animate-spin"})
				</div>
				<div x-show="!isValidating && isValid" class="text-success">
					@atoms.Icon(atoms.IconProps{Name: "check", Size: atoms.IconSizeXS})
				</div>
				<div x-show="!isValidating && !isValid && hasErrors" class="text-destructive">
					@atoms.Icon(atoms.IconProps{Name: "alert-circle", Size: atoms.IconSizeXS})
				</div>
			</div>
		</div>

		// Validation messages
		<div x-show="showMessages">
			@ValidationMessages(ValidationProps{
				FieldName:   fieldName,
				ShowSuccess: true,
				ShowWarnings: true,
				AlpineData: "validationState",
			})
		</div>
	</div>
}

// FormValidator renders validation for an entire form
templ FormValidator(formID string, children ...templ.Component) {
	<div
		class="form-validator"
		x-data={ getFormValidatorAlpineData(formID) }
		x-init="initFormValidator()"
	>
		// Form content
		for _, child := range children {
			@child
		}

		// Form-level validation summary
		<div x-show="hasFormErrors" class="form-validation-summary mt-4">
			@ValidationSummary(ValidationSummaryProps{
				Title: "Please fix the following errors:",
				AlpineData: "formValidationState",
			})
		</div>
	</div>
}

// ValidationSummaryProps defines properties for validation summaries
type ValidationSummaryProps struct {
	Title        string
	Messages     []ValidationMessage
	Collapsible  bool
	ShowCounts   bool
	GroupByField bool
	Class        string
	ID           string
	AlpineData   string
}

// ValidationSummary renders a summary of all validation messages
templ ValidationSummary(props ValidationSummaryProps) {
	<div
		if props.ID != "" {
			id={ props.ID }
		}
		class={ "validation-summary rounded-lg border p-4 " + props.Class }
		if props.AlpineData != "" {
			x-data={ props.AlpineData }
		} else {
			x-data="{ collapsed: false }"
		}
	>
		// Header
		<div class="flex items-center justify-between">
			<div class="flex items-center gap-2">
				@atoms.Icon(atoms.IconProps{
					Name:  "alert-triangle",
					Size:  atoms.IconSizeSM,
					ClassName: "text-destructive",
				})
				<h3 class="font-medium text-destructive">{ props.Title }</h3>
				if props.ShowCounts {
					<span class="text-sm text-muted-foreground" x-text="`(${errorCount} errors, ${warningCount} warnings)`"></span>
				}
			</div>
			
			if props.Collapsible {
				<button
					class="p-1 hover:bg-accent rounded-sm"
					x-on:click="collapsed = !collapsed"
				>
					@atoms.Icon(atoms.IconProps{
						Name:  "chevron-down",
						Size:  atoms.IconSizeXS,
						ClassName: "transition-transform x-bind:class=\"{'rotate-180': collapsed}\"",
					})
				</button>
			}
		</div>

		// Messages
		<div 
			class="mt-3"
			if props.Collapsible {
				x-show="!collapsed"
				x-transition
			}
		>
			if len(props.Messages) > 0 {
				// Static messages
				@validationMessageList(props.Messages, props.GroupByField)
			} else {
				// Dynamic messages via Alpine.js
				<template x-for="(messages, field) in groupedMessages" x-key="field">
					<div class="mb-3 last:mb-0">
						<div x-show="field !== 'general'" class="font-medium text-sm mb-1" x-text="getFieldLabel(field)"></div>
						<ul class="space-y-1">
							<template x-for="message in messages" x-key="message.code">
								<li class="flex items-start gap-2 text-sm">
									<span x-bind:class="getMessageIconClass(message.type)">
										<span x-show="message.type === 'error'">⚠️</span>
										<span x-show="message.type === 'warning'">⚠️</span>
										<span x-show="message.type === 'info'">ℹ️</span>
									</span>
									<span x-text="message.message"></span>
								</li>
							</template>
						</ul>
					</div>
				</template>
			}
		</div>
	</div>
}

// validationMessageList renders a list of validation messages
templ validationMessageList(messages []ValidationMessage, groupByField bool) {
	if groupByField {
		// Group messages by field
		@groupedValidationMessages(messages)
	} else {
		// Simple list
		<ul class="space-y-1">
			for _, message := range messages {
				<li class="flex items-start gap-2 text-sm">
					@atoms.Icon(atoms.IconProps{
						Name:  getValidationIcon(message.Type),
						Size:  atoms.IconSizeXS,
						ClassName: getValidationIconColor(message.Type) + " mt-0.5",
					})
					<span>{ message.Message }</span>
				</li>
			}
		</ul>
	}
}

// groupedValidationMessages renders messages grouped by field
templ groupedValidationMessages(messages []ValidationMessage) {
	// This would group messages by field in a real implementation
	<div class="space-y-3">
		<div class="mb-3">
			<div class="font-medium text-sm mb-1">General</div>
			<ul class="space-y-1">
				for _, message := range messages {
					if message.Field == "" {
						<li class="flex items-start gap-2 text-sm">
							@atoms.Icon(atoms.IconProps{
								Name:  getValidationIcon(message.Type),
								Size:  atoms.IconSizeXS,
								ClassName: getValidationIconColor(message.Type) + " mt-0.5",
							})
							<span>{ message.Message }</span>
						</li>
					}
				}
			</ul>
		</div>
	</div>
}

// Helper functions

// getHXTargetValue returns the HX target value, defaulting to "this" if empty
func getHXTargetValue(target string) string {
	if target != "" {
		return target
	}
	return "this"
}

// getValidationHXSwapValue returns the HX swap value, defaulting to "innerHTML" if empty
func getValidationHXSwapValue(swap string) string {
	if swap != "" {
		return swap
	}
	return "innerHTML"
}

// getValidationHXTriggerValue returns the HX trigger value, defaulting to "validate" if empty
func getValidationHXTriggerValue(trigger string) string {
	if trigger != "" {
		return trigger
	}
	return "validate"
}

// formatBool converts bool to string for JavaScript
func formatBool(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// getInlineClasses returns the inline classes based on bool value
func getInlineClasses(inline bool) string {
	if inline {
		return "inline-flex items-center gap-1"
	}
	return ""
}

// getRulesJSON converts rules to JSON string (placeholder)
func getValidationRulesJSONPlaceholder(rules []ValidationRule) string {
	// This would need proper JSON marshalling in production
	return "[]"
}

func getValidationMessageClasses(message ValidationMessage, inline bool) string {
	var classes []string

	if inline {
		classes = append(classes, "inline-flex", "items-center", "gap-1")
	}

	switch message.Type {
	case ValidationError:
		classes = append(classes, "text-destructive")
	case ValidationWarning:
		classes = append(classes, "text-warning")
	case ValidationSuccess:
		classes = append(classes, "text-success")
	case ValidationInfo:
		classes = append(classes, "text-muted-foreground")
	}

	return strings.Join(classes, " ")
}

func getValidationIcon(messageType ValidationMessageType) string {
	switch messageType {
	case ValidationError:
		return "alert-circle"
	case ValidationWarning:
		return "alert-triangle"
	case ValidationSuccess:
		return "check-circle"
	case ValidationInfo:
		return "info"
	default:
		return "info"
	}
}

func getValidationIconColor(messageType ValidationMessageType) string {
	switch messageType {
	case ValidationError:
		return "text-destructive"
	case ValidationWarning:
		return "text-warning"
	case ValidationSuccess:
		return "text-success"
	case ValidationInfo:
		return "text-muted-foreground"
	default:
		return "text-muted-foreground"
	}
}

func getValidationAlpineData(props ValidationProps) string {
	return `{
		validationMessages: [],
		isValidating: false,
		
		shouldShowMessage(message) {
			if (message.type === 'success' && !` + formatBool(props.ShowSuccess) + `) return false;
			if (message.type === 'warning' && !` + formatBool(props.ShowWarnings) + `) return false;
			return true;
		},
		
		getMessageClasses(message) {
			const baseClasses = '` + getInlineClasses(props.Inline) + `';
			const typeClasses = {
				error: 'text-destructive',
				warning: 'text-warning',
				success: 'text-success',
				info: 'text-muted-foreground'
			};
			return baseClasses + ' ' + (typeClasses[message.type] || 'text-muted-foreground');
		}
	}`
}

func getFieldValidatorAlpineData(fieldName string, rules []ValidationRule) string {
	return `{
		fieldName: '` + fieldName + `',
		rules: ` + getValidationRulesJSON(rules) + `,
		isValid: true,
		isValidating: false,
		hasErrors: false,
		showMessages: false,
		validationMessages: [],
		
		initValidator() {
			// Set up validation triggers
			this.setupValidationTriggers();
		},
		
		async validateField(value) {
			this.isValidating = true;
			this.validationMessages = [];
			
			// Client-side validation
			const clientResults = this.runClientValidation(value);
			this.validationMessages.push(...clientResults);
			
			// Server-side validation for async rules
			const asyncRules = this.rules.filter(r => r.async);
			if (asyncRules.length > 0) {
				const serverResults = await this.runServerValidation(value, asyncRules);
				this.validationMessages.push(...serverResults);
			}
			
			this.isValid = this.validationMessages.filter(m => m.type === 'error').length === 0;
			this.hasErrors = !this.isValid;
			this.showMessages = this.validationMessages.length > 0;
			this.isValidating = false;
			
			return this.isValid;
		},
		
		runClientValidation(value) {
			const messages = [];
			
			this.rules.forEach(rule => {
				if (rule.async) return; // Skip async rules
				
				const result = this.validateRule(value, rule);
				if (!result.valid) {
					messages.push({
						type: 'error',
						message: rule.message || this.getDefaultMessage(rule),
						code: rule.name,
						field: this.fieldName
					});
				}
			});
			
			return messages;
		},
		
		async runServerValidation(value, rules) {
			// This would make HTMX requests for server validation
			return [];
		},
		
		validateRule(value, rule) {
			switch (rule.type) {
				case 'required':
					return { valid: value !== null && value !== undefined && value.toString().trim() !== '' };
				case 'minLength':
					return { valid: !value || value.length >= rule.value };
				case 'maxLength':
					return { valid: !value || value.length <= rule.value };
				case 'pattern':
					return { valid: !value || new RegExp(rule.value).test(value) };
				case 'min':
					return { valid: !value || parseFloat(value) >= rule.value };
				case 'max':
					return { valid: !value || parseFloat(value) <= rule.value };
				default:
					return { valid: true };
			}
		},
		
		getDefaultMessage(rule) {
			const messages = {
				required: 'This field is required',
				minLength: 'Minimum length is ' + rule.value,
				maxLength: 'Maximum length is ' + rule.value,
				pattern: 'Invalid format',
				min: 'Minimum value is ' + rule.value,
				max: 'Maximum value is ' + rule.value
			};
			return messages[rule.type] || 'Validation failed';
		},
		
		setupValidationTriggers() {
			// Set up event listeners for validation
		}
	}`
}

func getFormValidatorAlpineData(formID string) string {
	return `{
		formId: '` + formID + `',
		fieldValidators: {},
		formValidationState: {
			errorCount: 0,
			warningCount: 0,
			groupedMessages: {}
		},
		hasFormErrors: false,
		
		initFormValidator() {
			this.registerFieldValidators();
			this.setupFormValidation();
		},
		
		registerFieldValidators() {
			// Register all field validators in this form
		},
		
		async validateForm() {
			let allValid = true;
			const allMessages = [];
			
			// Validate all fields
			for (const [fieldName, validator] of Object.entries(this.fieldValidators)) {
				const isValid = await validator.validateField();
				if (!isValid) {
					allValid = false;
				}
				allMessages.push(...validator.validationMessages);
			}
			
			this.updateFormValidationState(allMessages);
			return allValid;
		},
		
		updateFormValidationState(messages) {
			const grouped = {};
			let errorCount = 0;
			let warningCount = 0;
			
			messages.forEach(message => {
				const field = message.field || 'general';
				if (!grouped[field]) grouped[field] = [];
				grouped[field].push(message);
				
				if (message.type === 'error') errorCount++;
				if (message.type === 'warning') warningCount++;
			});
			
			this.formValidationState.groupedMessages = grouped;
			this.formValidationState.errorCount = errorCount;
			this.formValidationState.warningCount = warningCount;
			this.hasFormErrors = errorCount > 0;
		},
		
		setupFormValidation() {
			// Set up form submit validation
		}
	}`
}

func getValidationRulesJSON(rules []ValidationRule) string {
	// This would properly serialize the rules to JSON
	return "[]"
}