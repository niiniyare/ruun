package molecules

import (
	"fmt"
	"strings"
	"github.com/niiniyare/ruun/views/components/atoms"
)

// SearchBoxSize defines the size variants for the search box
type SearchBoxSize string

const (
	SearchBoxSizeSM SearchBoxSize = "sm"
	SearchBoxSizeMD SearchBoxSize = "md"
	SearchBoxSizeLG SearchBoxSize = "lg"
)

// SearchSuggestion represents a suggestion item
type SearchSuggestion struct {
	Value       string `json:"value"`
	Label       string `json:"label"`
	Description string `json:"description,omitempty"`
	Icon        string `json:"icon,omitempty"`
	Category    string `json:"category,omitempty"`
	URL         string `json:"url,omitempty"` // For navigation suggestions
}

// SearchBoxProps defines the properties for the SearchBox component
type SearchBoxProps struct {
	// Basic properties
	ID          string        `json:"id"`
	Name        string        `json:"name"`
	Value       string        `json:"value,omitempty"`
	Placeholder string        `json:"placeholder,omitempty"`
	Size        SearchBoxSize `json:"size,omitempty"`
	Disabled    bool          `json:"disabled,omitempty"`
	
	// Search behavior
	Suggestions   []SearchSuggestion `json:"suggestions,omitempty"`
	Loading       bool               `json:"loading,omitempty"`
	MinChars      int                `json:"minChars,omitempty"`      // Minimum characters before showing suggestions
	Debounce      int                `json:"debounce,omitempty"`      // Debounce delay in milliseconds
	ClearOnSelect bool               `json:"clearOnSelect,omitempty"` // Clear input after selection
	
	// HTMX attributes
	HXPost    string `json:"hxPost,omitempty"`    // URL for search API
	HXGet     string `json:"hxGet,omitempty"`     // URL for search API
	HXTarget  string `json:"hxTarget,omitempty"`  // Target for search results
	HXSwap    string `json:"hxSwap,omitempty"`    // Swap strategy
	HXTrigger string `json:"hxTrigger,omitempty"` // Custom trigger
	
	// Alpine.js attributes
	AlpineData   string `json:"alpineData,omitempty"`   // Custom x-data
	AlpineModel  string `json:"alpineModel,omitempty"`  // x-model for input
	AlpineSearch string `json:"alpineSearch,omitempty"` // Custom search method
	AlpineSelect string `json:"alpineSelect,omitempty"` // Method called when suggestion is selected
	AlpineClear  string `json:"alpineClear,omitempty"`  // Method called when clear button is clicked
	
	// Events
	OnSearch string `json:"onSearch,omitempty"` // JavaScript function for search
	OnSelect string `json:"onSelect,omitempty"` // JavaScript function for selection
	OnClear  string `json:"onClear,omitempty"`  // JavaScript function for clear
}

// getSearchBoxClasses returns static Basecoat classes for the search box
func getSearchBoxClasses(props SearchBoxProps) string {
	classes := []string{"search-box"}
	
	// Size variant - static switch instead of fmt.Sprintf
	switch string(props.Size) {
	case "sm":
		classes = append(classes, "search-box-sm")
	case "lg":
		classes = append(classes, "search-box-lg")
	case "xl":
		classes = append(classes, "search-box-xl")
	default: // md or empty
		classes = append(classes, "search-box-md")
	}
	
	// State classes
	if props.Loading {
		classes = append(classes, "search-box-loading")
	}
	if props.Disabled {
		classes = append(classes, "search-box-disabled")
	}
	
	return strings.Join(classes, " ")
}

// getSuggestionsClasses returns compiled Basecoat classes for the suggestions dropdown
func getSuggestionsClasses() string {
	return "search-suggestions search-suggestions-dropdown"
}

// getSuggestionItemClasses returns compiled Basecoat classes for suggestion items
func getSuggestionItemClasses() string {
	return "search-suggestion-item"
}

// buildSearchInputProps creates input props for the search input
func buildSearchInputProps(props SearchBoxProps) atoms.InputProps {
	// Set default placeholder
	placeholder := props.Placeholder
	if placeholder == "" {
		placeholder = "Search..."
	}

	return atoms.InputProps{
		ID:           props.ID,
		Name:         props.Name,
		Type:         atoms.InputSearch,
		Value:        props.Value,
		Placeholder:  placeholder,
		Disabled:     props.Disabled,
	}
}

// SearchBox renders a search input with suggestions dropdown using refactored atoms
templ SearchBox(props SearchBoxProps) {
	<div 
		class={ getSearchBoxClasses(props) }
		x-data={ getSearchBoxAlpineData(props) }
		x-on:click.away="hideSuggestions()"
	>
		// Search input container
		<div class="search-box-input-container">
			@atoms.Input(buildSearchInputProps(props))
			
			// Clear button
			if !props.Disabled {
				<button
					type="button"
					class="search-box-clear"
					x-show="searchQuery.length > 0"
					x-on:click="clearSearch()"
					aria-label="Clear search"
				>
					@atoms.Icon(atoms.IconProps{
						Name: "x",
						Size: "sm",
					})
				</button>
			}
			
			// Loading indicator
			if props.Loading {
				<div class="search-box-loading-indicator">
					@atoms.Icon(atoms.IconProps{
						Name: "loader",
						Size: "sm",
					})
				</div>
			}
		</div>

		// Suggestions dropdown
		<div
			class={ getSuggestionsClasses() }
			x-show="showSuggestions && (suggestions.length > 0 || staticSuggestions.length > 0)"
			x-transition:enter="search-suggestions-enter"
			x-transition:enter-start="search-suggestions-enter-start"
			x-transition:enter-end="search-suggestions-enter-end"
			x-transition:leave="search-suggestions-leave"
			x-transition:leave-start="search-suggestions-leave-start"
			x-transition:leave-end="search-suggestions-leave-end"
		>
			// Static suggestions (from props)
			<template x-for="(suggestion, index) in staticSuggestions" x-key="'static-' + index">
				<div
					class={ getSuggestionItemClasses() }
					x-on:click="selectSuggestion(suggestion)"
					x-bind:class="{ 'search-suggestion-item-selected': index === selectedIndex && !hasDynamicSuggestions }"
				>
					<div x-show="suggestion.icon" class="search-suggestion-icon">
						@atoms.Icon(atoms.IconProps{
							Name: "",
							Size: "sm",
						})
					</div>
					<div class="search-suggestion-content">
						<div class="search-suggestion-label" x-text="suggestion.label"></div>
						<div x-show="suggestion.description" class="search-suggestion-description" x-text="suggestion.description"></div>
					</div>
					<div x-show="suggestion.category" class="search-suggestion-category" x-text="suggestion.category"></div>
				</div>
			</template>
			
			// Dynamic suggestions (from Alpine.js)
			<template x-for="(suggestion, index) in suggestions" x-key="'dynamic-' + index">
				<div
					class={ getSuggestionItemClasses() }
					x-on:click="selectSuggestion(suggestion)"
					x-bind:class="{ 'search-suggestion-item-selected': (index + staticSuggestions.length) === selectedIndex }"
				>
					<div x-show="suggestion.icon" class="search-suggestion-icon">
						@atoms.Icon(atoms.IconProps{
							Name: "",
							Size: "sm",
						})
					</div>
					<div class="search-suggestion-content">
						<div class="search-suggestion-label" x-text="suggestion.label"></div>
						<div x-show="suggestion.description" class="search-suggestion-description" x-text="suggestion.description"></div>
					</div>
					<div x-show="suggestion.category" class="search-suggestion-category" x-text="suggestion.category"></div>
				</div>
			</template>
			
			// No results message
			<div
				class="search-suggestion-no-results"
				x-show="searchQuery.length >= minChars && suggestions.length === 0 && staticSuggestions.length === 0 && !loading"
			>
				No results found
			</div>
		</div>
	</div>
}

// getSearchBoxAlpineData generates the Alpine.js data for the search box
func getSearchBoxAlpineData(props SearchBoxProps) string {
	minChars := props.MinChars
	if minChars <= 0 {
		minChars = 2
	}
	debounce := props.Debounce
	if debounce <= 0 {
		debounce = 300
	}
	
	// Convert suggestions to JSON-safe format
	staticSuggestions := "[]"
	if len(props.Suggestions) > 0 {
		staticSuggestions = formatSuggestionsForJS(props.Suggestions)
	}

	// Prepare conditional values
	onSearch := ""
	if props.OnSearch != "" {
		onSearch = props.OnSearch
	}
	
	clearOrSelect := "this.searchQuery = suggestion.label;"
	if props.ClearOnSelect {
		clearOrSelect = "this.searchQuery = '';"
	}
	
	onSelect := ""
	if props.OnSelect != "" {
		onSelect = props.OnSelect
	}
	
	hxSwap := "innerHTML"
	if props.HXSwap != "" {
		hxSwap = props.HXSwap
	}
	
	onClear := ""
	if props.OnClear != "" {
		onClear = props.OnClear
	}

	return fmt.Sprintf(`{
		searchQuery: '%s',
		suggestions: [],
		staticSuggestions: %s,
		showSuggestions: false,
		selectedIndex: -1,
		loading: %t,
		minChars: %d,
		debounceTimer: null,
		hasDynamicSuggestions: false,
		
		init() {
			this.$watch('searchQuery', () => this.handleSearch());
		},
		
		handleSearch() {
			if (this.debounceTimer) {
				clearTimeout(this.debounceTimer);
			}
			
			this.debounceTimer = setTimeout(() => {
				if (this.searchQuery.length >= this.minChars) {
					this.performSearch();
				} else {
					this.hideSuggestions();
				}
			}, %d);
		},
		
		performSearch() {
			this.loading = true;
			this.showSuggestions = true;
			
			// Custom search logic
			if (%t) {
				%s;
			}
			
			// Filter static suggestions based on query
			if (this.searchQuery.length > 0) {
				this.staticSuggestions = %s.filter(suggestion => 
					suggestion.label.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
					(suggestion.description && suggestion.description.toLowerCase().includes(this.searchQuery.toLowerCase()))
				);
			} else {
				this.staticSuggestions = %s;
			}
		},
		
		selectSuggestion(suggestion) {
			%s
			this.hideSuggestions();
			
			// Custom select logic
			if (%t) {
				%s;
			}
			
			// Navigate if URL is provided
			if (suggestion.url && '%s') {
				htmx.ajax('GET', suggestion.url, { 
					target: '%s', 
					swap: '%s' 
				});
			}
		},
		
		clearSearch() {
			this.searchQuery = '';
			this.suggestions = [];
			this.hideSuggestions();
			
			// Custom clear logic
			if (%t) {
				%s;
			}
		},
		
		hideSuggestions() {
			this.showSuggestions = false;
			this.selectedIndex = -1;
			this.loading = false;
		},
		
		showSuggestionsDropdown() {
			if (this.searchQuery.length >= this.minChars || this.staticSuggestions.length > 0) {
				this.showSuggestions = true;
			}
		}
	}`,
		props.Value,
		staticSuggestions,
		props.Loading,
		minChars,
		debounce,
		props.OnSearch != "",
		onSearch,
		staticSuggestions,
		staticSuggestions,
		clearOrSelect,
		props.OnSelect != "",
		onSelect,
		props.HXTarget,
		props.HXTarget,
		hxSwap,
		props.OnClear != "",
		onClear,
	)
}

// formatSuggestionsForJS converts suggestions array to JavaScript array string
func formatSuggestionsForJS(suggestions []SearchSuggestion) string {
	if len(suggestions) == 0 {
		return "[]"
	}
	
	result := "["
	for i, suggestion := range suggestions {
		if i > 0 {
			result += ","
		}
		result += fmt.Sprintf(`{
			value: '%s',
			label: '%s',
			description: '%s',
			icon: '%s',
			category: '%s',
			url: '%s'
		}`,
			suggestion.Value,
			suggestion.Label,
			suggestion.Description,
			suggestion.Icon,
			suggestion.Category,
			suggestion.URL,
		)
	}
	result += "]"
	return result
}

// Note: QuickSearchBox and GlobalSearchBox helper functions have been removed
// as they relied on utils.IfElse and ClassName props that are no longer supported.
// Use SearchBox directly with appropriate props instead.